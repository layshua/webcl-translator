
/* WebCL Validator JSON header
{
    "version" : "1.0",
    "kernels" :
        {
            "render_gpu" :
                {
                    "scene" :
                        {
                            "index" : 0,
                            "type" : "struct Scene *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_scene_size"
                        },
                    "_wcl_scene_size" :
                        {
                            "index" : 1,
                            "type" : "ulong"
                        },
                    "Image" :
                        {
                            "index" : 2,
                            "type" : "uchar4 *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_Image_size"
                        },
                    "_wcl_Image_size" :
                        {
                            "index" : 3,
                            "type" : "ulong"
                        }
                }
        }
}
*/

// WebCL Validator: validation stage.
#define _WCL_ADDRESS_SPACE_private_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_private_ALIGNMENT (8/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_global_MIN (((53760 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_global_ALIGNMENT (32768/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_local_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_local_ALIGNMENT (8/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_constant_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_constant_ALIGNMENT (8/CHAR_BIT)
struct Ray {
 float3 base;
 float3 dir;
};

struct Camera {
 const float3 eye; // eye point
 const float3 sky; // sky vector
 const float3 viewCenter; // center of view rect
 const float3 viewRight; // horizontal direction of view rect
 const float3 viewUp; // vertical direction of view rect
 const int imgWidth; // image width in pixels
 const int imgHeight; // image height in pixels
};

struct Sphere {
 // geometry of sphere
 const float3 center;
 const float radius;

 // material
 const float3 color; // pigment
 const float ambient; // ambient amount
 const float diffuse; // diffuse amount
 const float highlight; // highlight intensity
 const float roughness; // controls highlight size
 const float reflection; // weight of reflected ray
};

struct Scene {
 const struct Camera cam; // the camera
 const float3 lightDir; // direction towards light
 const int numSpheres; // number of valid spheres
 const struct Sphere spheres[84]; // storage space for the spheres
};

typedef struct {
    struct Ray _wcl_ray;
} __attribute__ ((aligned (_WCL_ADDRESS_SPACE_private_ALIGNMENT))) _WclPrivates;

typedef struct {
    const __global struct Scene *restrict render_gpu__scene_min;
    const __global struct Scene *restrict render_gpu__scene_max;
    __global uchar4 *restrict render_gpu__Image_min;
    __global uchar4 *restrict render_gpu__Image_max;
} _WclGlobalLimits;

typedef struct {
    _WclGlobalLimits gl;
    __global uint *gn;
    _WclPrivates pa;
    __private uint *pn;
} _WclProgramAllocations;

__constant uint _wcl_constant_null[_WCL_ADDRESS_SPACE_constant_MIN] = { 0 };

// => General code that doesn't depend on input.

#define _WCL_MEMCPY(dst, src) for(ulong i = 0; i < sizeof((src))/sizeof((src)[0]); i++) { (dst)[i] = (src)[i]; }

#define _WCL_LAST(type, ptr) (((type)(ptr)) - 1)
#define _WCL_FILLCHAR ((uchar)0xCC)

// POCL crashes at run time if the parameters are local character
// pointers.
typedef uint _WclInitType;

// NOTE: this expects that null pointer is type of uint*
#define _WCL_SET_NULL(type, req_bytes, min, max, null) ( ((((type)max)-((type)min))*sizeof(uint) >= req_bytes) ? ((type)min) : (null) )

#ifdef cl_khr_initialize_memory
#pragma OPENCL EXTENSION cl_khr_initialize_memory : enable
#define _WCL_LOCAL_RANGE_INIT(begin, end)
#else

#define _WCL_LOCAL_RANGE_INIT(begin, end) do {               \
    __local uchar *start = (__local uchar *)begin;           \
    __local uchar *stop = (__local uchar *)end;              \
    const size_t z_items = get_local_size(2);                \
    const size_t yz_items = get_local_size(1) * z_items;     \
    const size_t xyz_items = get_local_size(0) * yz_items;   \
    const size_t item_index =                                \
        (get_local_id(0) * yz_items) +                       \
        (get_local_id(1) * z_items) +                        \
        get_local_id(2);                                     \
    size_t item_count = stop - start;                        \
    size_t items_per_kernel = item_count / xyz_items;        \
    size_t items_offset = items_per_kernel * item_index;     \
    size_t reminders = item_count % xyz_items;               \
    if (item_index < reminders) {                            \
        start[xyz_items*items_per_kernel + item_index] = _WCL_FILLCHAR; \
    }                                                                   \
    for (size_t i = 0; i < items_per_kernel; i++) {                     \
        start[items_offset+i] = _WCL_FILLCHAR;                          \
    }                                                                   \
} while (0)                                                             \

#endif // cl_khr_initialize_memory

// <= General code that doesn't depend on input.

#define _WCL_ADDR_CHECK_global_2(type, addr, size, min0, max0, min1, max1) \
    ( 0\
    || ( ((addr) >= ((type)min0)) && ((addr + size - 1) <= _WCL_LAST(type, max0)) ) \
        || ( ((addr) >= ((type)min1)) && ((addr + size - 1) <= _WCL_LAST(type, max1)) ) \
             )
#define _WCL_ADDR_CLAMP_global_2(type, addr, size, min0, max0, min1, max1, asnull) \
    ( _WCL_ADDR_CHECK_global_2(type, addr, size, min0, max0, min1, max1) ? (addr) : (type)(asnull))


// WebCL Validator: matching stage 2.
// WebCL Validator: matching stage 1.
/*****************************************************************************
 *                                 jugCLer                                   *
 *              realtime raytracing experiment: OpenCL kernel                *
 *                                                                           *
 *  Copyright (C) 2013  Holger Bettag               (hobold@vectorizer.org)  *
 *                                                                           *
 *  This program is free software; you can redistribute it and/or modify     *
 *  it under the terms of the GNU General Public License as published by     *
 *  the Free Software Foundation; either version 2 of the License, or        *
 *  (at your option) any later version.                                      *
 *                                                                           *
 *  This program is distributed in the hope that it will be useful,          *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of           *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *
 *  GNU General Public License for more details.                             *
 *                                                                           *
 *  You should have received a copy of the GNU General Public License along  *
 *  with this program; if not, write to the Free Software Foundation, Inc.,  *
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              *
 *****************************************************************************/

/***************
 *  view rays  *
 ***************/
;

/************************
 *  perspective camera  *
 ************************/
;

// ray through center of pixel

struct Ray camMakePrimaryRay(_WclProgramAllocations *_wcl_allocs, __global const struct Camera* restrict c,
  const int x, const int y) {
 const int imgWidth = (*(_WCL_ADDR_CLAMP_global_2(const __global struct Camera *, (c), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).imgWidth;
 const int imgHeight = (*(_WCL_ADDR_CLAMP_global_2(const __global struct Camera *, (c), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).imgHeight;
 const float ratio = imgWidth / (float)imgHeight;

 // start from relative pixel coordinates in [0.0 .. 1.0]
 // with y axis pointing down, pixel center is at (+0.5, +0.5)
 float fx = ((float) x + 0.5f) / imgWidth;
 float fy = ((float) y + 0.5f) / imgHeight;

 // map to [-1.0 .. 1.0], with y axis pointing down, because ...
 // ... GLUT y-flips the bitmap later on
 fx = (2.0f * fx - 1.0f) * ratio;
 fy = 2.0f * fy - 1.0f;

 // ray direction is from eye to that point in view rect  

 return (struct Ray) {
  (*(_WCL_ADDR_CLAMP_global_2(const __global struct Camera *, (c), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).eye, fast_normalize((*(_WCL_ADDR_CLAMP_global_2(const __global struct Camera *, (c), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).viewCenter
    + fx * (*(_WCL_ADDR_CLAMP_global_2(const __global struct Camera *, (c), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).viewRight + fy * (*(_WCL_ADDR_CLAMP_global_2(const __global struct Camera *, (c), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).viewUp - (*(_WCL_ADDR_CLAMP_global_2(const __global struct Camera *, (c), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).eye)
 };
}

/************
 *  sphere  *
 ************/
;

// return smallest positive t

float sphIntersect(_WclProgramAllocations *_wcl_allocs, __global const struct Sphere* restrict s,
  const struct Ray ray) {
 // translate sphere center to origin, i.e. translate ray base
 float3 base = ray.base - (*(_WCL_ADDR_CLAMP_global_2(const __global struct Sphere *, (s), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).center;

 // quadratic coefficients
 // immediately divide out leading coefficient
 // and immediately multiply b by -0.5 to simplify further computation
 float a = dot(ray.dir, ray.dir);
 float b = dot(base, ray.dir) / -a;
 float c = (dot(base, base) - (*(_WCL_ADDR_CLAMP_global_2(const __global struct Sphere *, (s), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).radius * (*(_WCL_ADDR_CLAMP_global_2(const __global struct Sphere *, (s), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).radius) / a;

 // so now we have to solve:   t*t - 2.0*t*b + c = 0;
 a = b * b - c; // discriminant

 float t = MAXFLOAT; // initialize as "ray misses sphere"

 if (a >= 0.0f) {
  // if ray hits sphere
  a = sqrt(a);
  float tmp = b - a; // check near hit
  if (tmp > 0.0f) {
   // if near hit is > 0, keep it
   t = tmp;
  } else {
   tmp = b + a; // check far hit
   if (tmp > 0.0f) {
    // if far hit is > 0, keep it
    t = tmp;
   }
  }
 }
 return t; // return hit or miss
}

// normal vector at point, unit length

float3 sphNormal(_WclProgramAllocations *_wcl_allocs, __global const struct Sphere* restrict s, const float3 where) {
 return fast_normalize(where - (*(_WCL_ADDR_CLAMP_global_2(const __global struct Sphere *, (s), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).center);
}

/*********************
 *  scene container  *
 *********************/
;


/****************
 *  trace rays  *
 ****************/
// returns true if light ray is blocked

bool shadow(_WclProgramAllocations *_wcl_allocs, const struct Ray ray, __global const struct Scene* restrict scene) {
 for (int i = (*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).numSpheres - 1; i >= 0; i--) {
  if (sphIntersect(_wcl_allocs, &((*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).spheres[i]), ray) < MAXFLOAT) {
   return true;
  }
 }
 return false;
}

// returns color for ray

float3 trace(_WclProgramAllocations *_wcl_allocs, struct Ray ray, __global const struct Scene* restrict scene) {
 float weight = 1.0f; // weight of remaining reflected ray, if any
 int rayDepth = 0; // number of reflections so far
 float3 result = {0.0f, 0.0f, 0.0f}; // accumulates ray intensities

 float floorDist; // distance to floor
 int sphereIdx; // closest valid sphere hit, if any
 float sphereDist; // distance to closest valid sphere hit, if any

 float3 normal;
 float3 position;
 float3 reflected;
 float3 color;
 float3 ambientColor;
 float ambient;
 float diffuse;
 float highlight;
 float roughness;
 float reflection;

 const float3 lightDir = (*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).lightDir; // direction towards to light

 while ((weight > 0.004f) && (rayDepth < 10)) { // loop over reflections
  rayDepth++;

  // test ground floor (at y = 0) first
  floorDist = MAXFLOAT;
  if (ray.dir.y != 0.0f) {
   floorDist = -ray.base.y / ray.dir.y; // in terms of ray parameter t
   if (floorDist < 0.0f) {
    floorDist = MAXFLOAT; // floor is behind camera, so it's a miss
   }
  }

  sphereIdx = -1; // remember closest valid sphere hit
  sphereDist = MAXFLOAT; // and that hit's distance

  for (int i = (*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).numSpheres - 1; i >= 0; i--) { // test all spheres
   float dist = sphIntersect(_wcl_allocs, &((*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).spheres[i]), ray);
   if (dist < sphereDist) {
    sphereDist = dist; // remember closest hit
    sphereIdx = i;
   }
  }

  // initialize as default material (for floor)
  ambient = 0.3f;
  diffuse = 0.7f;
  highlight = 0.0f;
  roughness = 0.05f;
  reflection = 0.0f;

  // did we hit anything?  
  if (fmin(sphereDist, floorDist) >= MAXFLOAT) {
   // we missed the floor and all spheres, so it's sky dome color
   color = (float3) (0.7f, 0.8f, 0.9f) * (1.0f - ray.dir.y)
     + (float3) (0.1f, 0.1f, 0.9f) * ray.dir.y;
  } else {
   // what is closer, floor or sphere?
   if (floorDist < sphereDist) {
    // ray did hit the floor, make checkerboard pattern
    position = ray.base + floorDist * ray.dir; // location of floor hit
    float2 checker;
    checker.x = 0.125f * position.x + 0.5f;
    checker.y = 0.125f * position.z + 0.5f;

    // fake floor antialiasing by blurring the pattern with distance
    float toggle = fabs(checker.x - floor(checker.x) - 0.5f);
    toggle = fmax(toggle, fabs(checker.y - floor(checker.y) - 0.5f));
    toggle = fmax(toggle, (float) (((int) (floor(checker.x)) ^
      (int) (floor(checker.y))) & 1) - toggle);
    float m = fast_distance(position, (*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).cam.eye);
    m = 100000.0f / (m * m * (16.0f * ((float) rayDepth) - 15.0f));
    float b = 0.5f * m - 0.5f;
    toggle = m * toggle - b;
    toggle = clamp(toggle, 0.0f, 1.0f);

    color = (float3) (0.9f, 0.9f, 0.1f) * toggle
      + (float3) (0.1f, 0.9f, 0.1f) * (1.0f - toggle);
    normal = (float3) (0.0f, 1.0f, 0.0f); // floor normal
   } else {
    // ray did hit a sphere
    position = ray.base + sphereDist * ray.dir; // location of sphere hit
    normal = sphNormal(_wcl_allocs, &((*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).spheres[sphereIdx]), position); // normal

    // sphere material
    color = (*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).spheres[sphereIdx].color;
    ambient = (*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).spheres[sphereIdx].ambient;
    diffuse = (*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).spheres[sphereIdx].diffuse;
    highlight = (*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).spheres[sphereIdx].highlight;
    roughness = (*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).spheres[sphereIdx].roughness;
    reflection = (*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).spheres[sphereIdx].reflection;
   }
   // light that point

   // cheat to avoid erroneous self intersections
   position += 0.0008f * normal;

   // reflected direction
   reflected = ray.dir - ((2.0f * dot(normal, ray.dir)) * normal);

   // fake ambient illumination: mix average floor and sky colors depending
   // on y component of surface normal
   ambientColor = 1.65f * (color + 0.1f) * mix((float3) (0.4f, 0.45f, 0.9f),
     (float3) (0.5f, 0.9f, 0.1f) * lightDir.y,
     (float3) (0.5f - 0.5f * normal.y)) * ambient;

   float brightness = 0.0f;
   float cosAngle = 0.0f; // temporary for diffuse and highlight

   if (!shadow(_wcl_allocs, (struct Ray) {
     position, lightDir}, scene)) {
   // if light source is visible, add its diffuse contribution
   cosAngle = dot(lightDir, normal);
   cosAngle = fmax(cosAngle, 0.0f); // only if we're facing the light
   brightness = diffuse*cosAngle;

   // add specular highlight, i.e. a reflection of the light source	
   cosAngle = dot(reflected, lightDir);
   cosAngle = fmax(cosAngle, 0.0f); // if reflection is towards light

   // resize highlight (shrinks with increasing factor)
   cosAngle = ((cosAngle - 1.0f) / roughness) + 1.0f;
   cosAngle = fmax(cosAngle, 0.0f); // only if inside the highlight
   cosAngle = cosAngle * cosAngle * highlight;
  }
   // ambient and diffuse contributions + highlight
   color = (color * brightness) + ambientColor + (float3) (cosAngle);
  }
  result += color * weight; // add weighted contribution of (reflected) ray
  weight *= reflection; // diminish weight of further reflections

  // follow the reflected ray next
  ray.base = position;
  ray.dir = reflected;
 }

 return result;
}

// trace a ray through each pixel

__kernel
void render_gpu(__global const struct Scene* restrict scene, ulong _wcl_scene_size, __global uchar4* restrict Image, ulong _wcl_Image_size) {
    __local uint _wcl_local_null[_WCL_ADDRESS_SPACE_local_MIN];

    _WclProgramAllocations _wcl_allocations_allocation = {
        { &scene[0], &scene[_wcl_scene_size],&Image[0], &Image[_wcl_Image_size] },
        0,
        { },
        0

    };
    _WclProgramAllocations *_wcl_allocs = &_wcl_allocations_allocation;
    _wcl_allocs->gn = _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, (__global uint*)0));
    if (_wcl_allocs->gn == (__global uint*)0) return; // not enough space to meet the minimum access. Would be great if we could give info about the problem for the user. 
    _wcl_allocs->pn = _WCL_SET_NULL(__private uint*, _WCL_ADDRESS_SPACE_private_MIN, &_wcl_allocs->pa, (&_wcl_allocs->pa + 1), (__private uint*)0);
    if (_wcl_allocs->pn == (__private uint*)0) return; // not enough space to meet the minimum access. Would be great if we could give info about the problem for the user. 

 const int imgWidth = (*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).cam.imgWidth;
 const int imgHeight = (*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).cam.imgHeight;

 const int gid = get_global_id(0);
 if (gid > imgWidth * imgHeight)
  return;

 const int x = gid % imgWidth;
 const int y = gid / imgWidth;

 // trace the ray through that pixel
 struct Ray ray = camMakePrimaryRay(_wcl_allocs, &((*(_WCL_ADDR_CLAMP_global_2(const __global struct Scene *, (scene), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).cam), x, y);;_wcl_allocs->pa._wcl_ray = ray;
 float3 color = trace(_wcl_allocs, _wcl_allocs->pa._wcl_ray, scene);

 // apply 2x2 ordered dithering during conversion from float to uchar
 float dither = (float) ((((x^y) & 1) << 1) + (y & 1)) * 0.25f;
 (*(_WCL_ADDR_CLAMP_global_2(__global uchar4 *, (Image)+(y * imgWidth + x), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).x =
   (unsigned char) (fmin(color.x, 1.0f) * 255.125f + dither);
 (*(_WCL_ADDR_CLAMP_global_2(__global uchar4 *, (Image)+(y * imgWidth + x), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).y =
   (unsigned char) (fmin(color.y, 1.0f) * 255.125f + dither);
 (*(_WCL_ADDR_CLAMP_global_2(__global uchar4 *, (Image)+(y * imgWidth + x), 1, _wcl_allocs->gl.render_gpu__scene_min, _wcl_allocs->gl.render_gpu__scene_max, _wcl_allocs->gl.render_gpu__Image_min, _wcl_allocs->gl.render_gpu__Image_max, _wcl_allocs->gn))).z =
   (unsigned char) (fmin(color.z, 1.0f) * 255.125f + dither);
}
