
/* WebCL Validator JSON header
{
    "version" : "1.0",
    "kernels" :
        {
            "JuliaGPU" :
                {
                    "pixels" :
                        {
                            "index" : 0,
                            "type" : "float *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_pixels_size"
                        },
                    "_wcl_pixels_size" :
                        {
                            "index" : 1,
                            "type" : "ulong"
                        },
                    "config" :
                        {
                            "index" : 2,
                            "type" : "struct _Wcl3Struct *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_config_size"
                        },
                    "_wcl_config_size" :
                        {
                            "index" : 3,
                            "type" : "ulong"
                        },
                    "enableAccumulation" :
                        {
                            "index" : 4,
                            "type" : "int"
                        },
                    "sampleCount" :
                        {
                            "index" : 5,
                            "type" : "int"
                        },
                    "sampleX" :
                        {
                            "index" : 6,
                            "type" : "float"
                        },
                    "sampleY" :
                        {
                            "index" : 7,
                            "type" : "float"
                        }
                }
        }
}
*/

// WebCL Validator: validation stage.
#define _WCL_ADDRESS_SPACE_private_MIN (((128 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_private_ALIGNMENT (128/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_global_MIN (((480 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_global_ALIGNMENT (256/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_local_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_local_ALIGNMENT (8/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_constant_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_constant_ALIGNMENT (8/CHAR_BIT)
typedef struct _WclStruct {
 float x, y, z;
} Vec;

typedef struct _Wcl2Struct {

 Vec orig, target;

 Vec dir, x, y;
} Camera;

typedef struct _Wcl3Struct {
 unsigned int width, height;
 int superSamplingSize;
 int activateFastRendering;
 int enableShadow;

 unsigned int maxIterations;
 float epsilon;
 float mu[4];
 float light[3];
 Camera camera;
} RenderingConfig;

typedef struct {
    float4 _wcl_r;
    float4 _wcl_2_r;
    float _wcl_dist;
    float4 _wcl_z;
    float4 _wcl_zp;
    float4 _wcl_N;
    float _wcl_gradX;
    float _wcl_gradY;
    float _wcl_gradZ;
    const __global Camera *_wcl_camera;
    float4 _wcl_hitPoint;
    uint _wcl_steps;
    float4 _wcl_diffuse;
    float4 _wcl_n;
    float4 _wcl_color;
    float4 _wcl_shadowHitPoint;
    uint _wcl_2_steps;
} __attribute__ ((aligned (_WCL_ADDRESS_SPACE_private_ALIGNMENT))) _WclPrivates;

typedef struct {
    __global float *JuliaGPU__pixels_min;
    __global float *JuliaGPU__pixels_max;
    const __global RenderingConfig *JuliaGPU__config_min;
    const __global RenderingConfig *JuliaGPU__config_max;
} _WclGlobalLimits;

typedef struct {
    _WclGlobalLimits gl;
    __global uint *gn;
    _WclPrivates pa;
    __private uint *pn;
} _WclProgramAllocations;

__constant uint _wcl_constant_null[_WCL_ADDRESS_SPACE_constant_MIN] = { 0 };

// => General code that doesn't depend on input.

#define _WCL_MEMCPY(dst, src) for(ulong i = 0; i < sizeof((src))/sizeof((src)[0]); i++) { (dst)[i] = (src)[i]; }

#define _WCL_LAST(type, ptr) (((type)(ptr)) - 1)
#define _WCL_FILLCHAR ((uchar)0xCC)

// POCL crashes at run time if the parameters are local character
// pointers.
typedef uint _WclInitType;

// NOTE: this expects that null pointer is type of uint*
#define _WCL_SET_NULL(type, req_bytes, min, max, null) ( ((((type)max)-((type)min))*sizeof(uint) >= req_bytes) ? ((type)min) : (null) )

#ifdef cl_khr_initialize_memory
#pragma OPENCL EXTENSION cl_khr_initialize_memory : enable
#define _WCL_LOCAL_RANGE_INIT(begin, end)
#else

#define _WCL_LOCAL_RANGE_INIT(begin, end) do {               \
    __local uchar *start = (__local uchar *)begin;           \
    __local uchar *stop = (__local uchar *)end;              \
    const size_t z_items = get_local_size(2);                \
    const size_t yz_items = get_local_size(1) * z_items;     \
    const size_t xyz_items = get_local_size(0) * yz_items;   \
    const size_t item_index =                                \
        (get_local_id(0) * yz_items) +                       \
        (get_local_id(1) * z_items) +                        \
        get_local_id(2);                                     \
    size_t item_count = stop - start;                        \
    size_t items_per_kernel = item_count / xyz_items;        \
    size_t items_offset = items_per_kernel * item_index;     \
    size_t reminders = item_count % xyz_items;               \
    if (item_index < reminders) {                            \
        start[xyz_items*items_per_kernel + item_index] = _WCL_FILLCHAR; \
    }                                                                   \
    for (size_t i = 0; i < items_per_kernel; i++) {                     \
        start[items_offset+i] = _WCL_FILLCHAR;                          \
    }                                                                   \
} while (0)                                                             \

#endif // cl_khr_initialize_memory

// <= General code that doesn't depend on input.

bool _wcl_addr_check_private_1_float4__Ptr(float4 *addr, unsigned size, float4 * min0, float4 * max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(float4 *, max0)) );
}
float4 *_wcl_addr_clamp_private_1_float4__Ptr(float4 *addr, unsigned size, float4 * min0, float4 * max0, float4 * asnull)
{
     return _wcl_addr_check_private_1_float4__Ptr(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_private_1_uint__Ptr(uint *addr, unsigned size, uint * min0, uint * max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(uint *, max0)) );
}
uint *_wcl_addr_clamp_private_1_uint__Ptr(uint *addr, unsigned size, uint * min0, uint * max0, uint * asnull)
{
     return _wcl_addr_check_private_1_uint__Ptr(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_global_2__u_uglobal__float__Ptr(__global float *addr, unsigned size, __global float * min0, __global float * max0, __global float * min1, __global float * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(__global float *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(__global float *, max1)) );
}
__global float *_wcl_addr_clamp_global_2__u_uglobal__float__Ptr(__global float *addr, unsigned size, __global float * min0, __global float * max0, __global float * min1, __global float * max1, __global float * asnull)
{
     return _wcl_addr_check_global_2__u_uglobal__float__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_global_2_const___u_uglobal__Camera__Ptr(const __global Camera *addr, unsigned size, const __global Camera * min0, const __global Camera * max0, const __global Camera * min1, const __global Camera * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __global Camera *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(const __global Camera *, max1)) );
}
const __global Camera *_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr(const __global Camera *addr, unsigned size, const __global Camera * min0, const __global Camera * max0, const __global Camera * min1, const __global Camera * max1, const __global Camera * asnull)
{
     return _wcl_addr_check_global_2_const___u_uglobal__Camera__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_global_2_const___u_uglobal__RenderingConfig__Ptr(const __global RenderingConfig *addr, unsigned size, const __global RenderingConfig * min0, const __global RenderingConfig * max0, const __global RenderingConfig * min1, const __global RenderingConfig * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __global RenderingConfig *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(const __global RenderingConfig *, max1)) );
}
const __global RenderingConfig *_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr(const __global RenderingConfig *addr, unsigned size, const __global RenderingConfig * min0, const __global RenderingConfig * max0, const __global RenderingConfig * min1, const __global RenderingConfig * max1, const __global RenderingConfig * asnull)
{
     return _wcl_addr_check_global_2_const___u_uglobal__RenderingConfig__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_global_2_const___u_uglobal__float__Ptr(const __global float *addr, unsigned size, const __global float * min0, const __global float * max0, const __global float * min1, const __global float * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __global float *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(const __global float *, max1)) );
}
const __global float *_wcl_addr_clamp_global_2_const___u_uglobal__float__Ptr(const __global float *addr, unsigned size, const __global float * min0, const __global float * max0, const __global float * min1, const __global float * max1, const __global float * asnull)
{
     return _wcl_addr_check_global_2_const___u_uglobal__float__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}


// WebCL Validator: matching stage 2.
// WebCL Validator: matching stage 1.
;

;

;





 float4 QuatMult(_WclProgramAllocations *_wcl_allocs, const float4 q1, const float4 q2) {
 float4 r;


 _wcl_allocs->pa._wcl_r.x = q1.x * q2.x - q1.y * q2.y - q1.z * q2.z - q1.w * q2.w;

 _wcl_allocs->pa._wcl_r.y = q1.x * q2.y + q1.y * q2.x + q1.z * q2.w - q1.w * q2.z;

 _wcl_allocs->pa._wcl_r.z = q1.x * q2.z - q1.y * q2.w + q1.z * q2.x + q1.w * q2.y;

 _wcl_allocs->pa._wcl_r.w = q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x;

 return _wcl_allocs->pa._wcl_r;
}

 float4 QuatSqr(_WclProgramAllocations *_wcl_allocs, const float4 q) {
 float4 r;

 _wcl_allocs->pa._wcl_2_r.x = q.x * q.x - q.y * q.y - q.z * q.z - q.w * q.w;
 _wcl_allocs->pa._wcl_2_r.y = 2.f * q.x * q.y;
 _wcl_allocs->pa._wcl_2_r.z = 2.f * q.x * q.z;
 _wcl_allocs->pa._wcl_2_r.w = 2.f * q.x * q.w;

 return _wcl_allocs->pa._wcl_2_r;
}

 void IterateIntersect(_WclProgramAllocations *_wcl_allocs, float4 *q, float4 *qp,
  const float4 c, const uint maxIterations) {
 float4 q0 = (*(_wcl_addr_clamp_private_1_float4__Ptr((q), 1, (float4 *)&_wcl_allocs->pa, (float4 *)(&_wcl_allocs->pa + 1), (float4 *)_wcl_allocs->pn)));
 float4 qp0 = (*(_wcl_addr_clamp_private_1_float4__Ptr((qp), 1, (float4 *)&_wcl_allocs->pa, (float4 *)(&_wcl_allocs->pa + 1), (float4 *)_wcl_allocs->pn)));

 for (uint i = 0; i < maxIterations; ++i) {
  qp0 = 2.f * QuatMult(_wcl_allocs, q0, qp0);
  q0 = QuatSqr(_wcl_allocs, q0) + c;

  if (dot(q0, q0) > 1e1f)
   break;
 }

 (*(_wcl_addr_clamp_private_1_float4__Ptr((q), 1, (float4 *)&_wcl_allocs->pa, (float4 *)(&_wcl_allocs->pa + 1), (float4 *)_wcl_allocs->pn))) = q0;
 (*(_wcl_addr_clamp_private_1_float4__Ptr((qp), 1, (float4 *)&_wcl_allocs->pa, (float4 *)(&_wcl_allocs->pa + 1), (float4 *)_wcl_allocs->pn))) = qp0;
}

 float IntersectJulia(_WclProgramAllocations *_wcl_allocs, const float4 eyeRayOrig, const float4 eyeRayDir,
  const float4 c, const uint maxIterations, const float epsilon,
  float4 *hitPoint, uint *steps) {
 float dist;
 float4 r0 = eyeRayOrig;

 uint s = 0;
 do {
  float4 z = r0;;_wcl_allocs->pa._wcl_z = z;
  float4 zp = (float4) (1.f, 0.f, 0.f, 0.f);;_wcl_allocs->pa._wcl_zp = zp;

  IterateIntersect(_wcl_allocs, &_wcl_allocs->pa._wcl_z, &_wcl_allocs->pa._wcl_zp, c, maxIterations);

  const float normZP = length(_wcl_allocs->pa._wcl_zp);


  if (normZP == 0.f)
   break;

  const float normZ = length(_wcl_allocs->pa._wcl_z);
  _wcl_allocs->pa._wcl_dist = .5f * normZ * log(normZ) / normZP;

  r0 += eyeRayDir * _wcl_allocs->pa._wcl_dist;
  s++;
 } while ((_wcl_allocs->pa._wcl_dist > epsilon) && (dot(r0, r0) < 4.f));

 (*(_wcl_addr_clamp_private_1_float4__Ptr((hitPoint), 1, (float4 *)&_wcl_allocs->pa, (float4 *)(&_wcl_allocs->pa + 1), (float4 *)_wcl_allocs->pn))) = r0;
 (*(_wcl_addr_clamp_private_1_uint__Ptr((steps), 1, (uint *)&_wcl_allocs->pa, (uint *)(&_wcl_allocs->pa + 1), (uint *)_wcl_allocs->pn))) = s;
 return _wcl_allocs->pa._wcl_dist;
}



float IntersectFloorSphere(_WclProgramAllocations *_wcl_allocs, const float4 eyeRayOrig, const float4 eyeRayDir) {
 const float4 op = ((float4)(0.f, -1000.f - 2.f, 0.f, 0.f)) - eyeRayOrig;
 const float b = dot(op, eyeRayDir);
 float det = b * b - dot(op, op) + 1000.f * 1000.f;

 if (det < 0.f)
  return -1.f;
 else
  det = sqrt(det);

 float t = b - det;
 if (t > 0.f)
  return t;
 else {

  return -1.f;
 }
}

float IntersectBoundingSphere(_WclProgramAllocations *_wcl_allocs, const float4 eyeRayOrig, const float4 eyeRayDir) {
 const float4 op = -eyeRayOrig;
 const float b = dot(op, eyeRayDir);
 float det = b * b - dot(op, op) + 4.f;

 if (det < 0.f)
  return -1.f;
 else
  det = sqrt(det);

 float t = b - det;
 if (t > 0.f)
  return t;
 else {
  t = b + det;

  if (t > 0.f) {

   return 0.f;
  } else
   return -1.f;
 }
}

 float4 NormEstimate(_WclProgramAllocations *_wcl_allocs, const float4 p, const float4 c,
  const float delta, const uint maxIterations) {
 float4 N;
 float4 qP = p;
 float gradX, gradY, gradZ;

 float4 gx1 = qP - (float4)(1e-4f, 0.f, 0.f, 0.f);
 float4 gx2 = qP + (float4)(1e-4f, 0.f, 0.f, 0.f);
 float4 gy1 = qP - (float4)(0.f, 1e-4f, 0.f, 0.f);
 float4 gy2 = qP + (float4)(0.f, 1e-4f, 0.f, 0.f);
 float4 gz1 = qP - (float4)(0.f, 0.f, 1e-4f, 0.f);
 float4 gz2 = qP + (float4)(0.f, 0.f, 1e-4f, 0.f);

 for (uint i = 0; i < maxIterations; ++i) {
  gx1 = QuatSqr(_wcl_allocs, gx1) + c;
  gx2 = QuatSqr(_wcl_allocs, gx2) + c;
  gy1 = QuatSqr(_wcl_allocs, gy1) + c;
  gy2 = QuatSqr(_wcl_allocs, gy2) + c;
  gz1 = QuatSqr(_wcl_allocs, gz1) + c;
  gz2 = QuatSqr(_wcl_allocs, gz2) + c;
 }

 _wcl_allocs->pa._wcl_gradX = length(gx2) - length(gx1);
 _wcl_allocs->pa._wcl_gradY = length(gy2) - length(gy1);
 _wcl_allocs->pa._wcl_gradZ = length(gz2) - length(gz1);

 _wcl_allocs->pa._wcl_N = normalize((float4)(_wcl_allocs->pa._wcl_gradX, _wcl_allocs->pa._wcl_gradY, _wcl_allocs->pa._wcl_gradZ, 0.f));

 return _wcl_allocs->pa._wcl_N;
}

 float4 Phong(_WclProgramAllocations *_wcl_allocs, const float4 light, const float4 eye, const float4 pt,
  const float4 N, const float4 diffuse) {
 const float4 ambient = (float4) (0.05f, 0.05f, 0.05f, 0.f);
 float4 L = normalize(light - pt);
 float NdotL = dot(N, L);
 if (NdotL < 0.f)
  return diffuse * ambient;

 const float specularExponent = 30.f;
 const float specularity = .65f;

 float4 E = normalize(eye - pt);
 float4 H = (L + E) * .5f;

 return diffuse * NdotL +
   specularity * pow(dot(N, H), specularExponent) +
   diffuse * ambient;
}

__kernel void JuliaGPU(
 __global float *pixels, ulong _wcl_pixels_size,
 const __global RenderingConfig *config, ulong _wcl_config_size,
 const int enableAccumulation,
 const int sampleCount,
 const float sampleX,
 const float sampleY) {
    __local uint _wcl_local_null[_WCL_ADDRESS_SPACE_local_MIN];

    _WclProgramAllocations _wcl_allocations_allocation = {
        { &pixels[0], &pixels[_wcl_pixels_size],&config[0], &config[_wcl_config_size] },
        0,
        { },
        0

    };
    _WclProgramAllocations *_wcl_allocs = &_wcl_allocations_allocation;
    _wcl_allocs->gn = _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.JuliaGPU__pixels_min, _wcl_allocs->gl.JuliaGPU__pixels_max, _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.JuliaGPU__config_min, _wcl_allocs->gl.JuliaGPU__config_max, (__global uint*)0));
    if (_wcl_allocs->gn == (__global uint*)0) return; // not enough space to meet the minimum access. Would be great if we could give info about the problem for the user. 
    _wcl_allocs->pn = _WCL_SET_NULL(__private uint*, _WCL_ADDRESS_SPACE_private_MIN, &_wcl_allocs->pa, (&_wcl_allocs->pa + 1), (__private uint*)0);
    if (_wcl_allocs->pn == (__private uint*)0) return; // not enough space to meet the minimum access. Would be great if we could give info about the problem for the user. 

    const int gid = get_global_id(0);
 const unsigned int width = (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).width;
 const unsigned int height = (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).height;

 const unsigned int x = gid % width;
 const int y = gid / width;


 if (y >= height)
  return;

 const float epsilon = (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).activateFastRendering ? ((*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).epsilon * (1.f / 0.75f)) : (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).epsilon;
 const uint maxIterations = max(1u,
   (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).activateFastRendering ? ((*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).maxIterations - 1) : (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).maxIterations);

 const float4 mu = (float4)((*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).mu[0], (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).mu[1], (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).mu[2], (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).mu[3]);
 const float4 light = (float4)((*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).light[0], (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).light[1], (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).light[2], 0.f);
 const __global Camera *camera = &(*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).camera;;_wcl_allocs->pa._wcl_camera = camera;





 const float invWidth = 1.f / width;
 const float invHeight = 1.f / height;
 const float kcx = (x + sampleX) * invWidth - .5f;
 const float4 kcx4 = (float4)kcx;
 const float kcy = (y + sampleY) * invHeight - .5f;
 const float4 kcy4 = (float4)kcy;

 const float4 cameraX = (float4)((*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).x.x, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).x.y, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).x.z, 0.f);
 const float4 cameraY = (float4)((*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).y.x, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).y.y, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).y.z, 0.f);
 const float4 cameraDir = (float4)((*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).dir.x, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).dir.y, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).dir.z, 0.f);
 const float4 cameraOrig = (float4)((*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).orig.x, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).orig.y, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).orig.z, 0.f);

 const float4 eyeRayDir = normalize(cameraX * kcx4 + cameraY * kcy4 + cameraDir);
 const float4 eyeRayOrig = eyeRayDir * (float4)0.1f + cameraOrig;





 float distSet = IntersectBoundingSphere(_wcl_allocs, eyeRayOrig, eyeRayDir);
 float4 hitPoint;
 if (distSet >= 0.f) {




  uint steps;
  float4 rayOrig = eyeRayOrig + eyeRayDir * (float4)distSet;
  distSet = IntersectJulia(_wcl_allocs, rayOrig, eyeRayDir, mu, maxIterations,
    epsilon, &_wcl_allocs->pa._wcl_hitPoint, &_wcl_allocs->pa._wcl_steps);
  if (distSet > epsilon)
   distSet = -1.f;
 }





 float distFloor = IntersectFloorSphere(_wcl_allocs, eyeRayOrig, eyeRayDir);





 int doShade = 0;
 int useAO = 1;
 float4 diffuse, n, color;
 if ((distSet < 0.f) && (distFloor < 0.f)) {

  _wcl_allocs->pa._wcl_color = (float4)(0.f, .1f, .3f, 0.f);
 } else if ((distSet >= 0.f) && ((distFloor < 0.f) || (distSet <= distFloor))) {

  _wcl_allocs->pa._wcl_diffuse = (float4) (1.f, .35f, .15f, 0.f);
  _wcl_allocs->pa._wcl_n = NormEstimate(_wcl_allocs, _wcl_allocs->pa._wcl_hitPoint, mu, distSet, maxIterations);
  doShade = 1;
 } else if ((distFloor >= 0.f) && ((distSet < 0.f) || (distFloor <= distSet))) {

  _wcl_allocs->pa._wcl_hitPoint = eyeRayOrig + eyeRayDir * (float4)distFloor;
  _wcl_allocs->pa._wcl_n = _wcl_allocs->pa._wcl_hitPoint - ((float4)(0.f, -1000.f - 2.f, 0.f, 0.f));
  _wcl_allocs->pa._wcl_n = normalize(_wcl_allocs->pa._wcl_n);

  const int ix = (_wcl_allocs->pa._wcl_hitPoint.x > 0.f) ? _wcl_allocs->pa._wcl_hitPoint.x : (1.f - _wcl_allocs->pa._wcl_hitPoint.x);
  const int iz = (_wcl_allocs->pa._wcl_hitPoint.z > 0.f) ? _wcl_allocs->pa._wcl_hitPoint.z : (1.f - _wcl_allocs->pa._wcl_hitPoint.z);
  if ((ix + iz) % 2)
   _wcl_allocs->pa._wcl_diffuse = (float4) (.75f, .75f, .75f, 0.f);
  else
   _wcl_allocs->pa._wcl_diffuse = (float4) (.75f, 0.f, 0.f, 0.f);
  doShade = 1;
  useAO = 0;
 }





 if (doShade) {
  float shadowFactor = 1.f;
  if ((*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).enableShadow) {
   float4 L = normalize(light - _wcl_allocs->pa._wcl_hitPoint);
   float4 rO = _wcl_allocs->pa._wcl_hitPoint + _wcl_allocs->pa._wcl_n * 1e-2f;
   float4 shadowHitPoint;


   float shadowDistSet = IntersectBoundingSphere(_wcl_allocs, rO, L);
   if (shadowDistSet >= 0.f) {
    uint steps;

    rO = rO + L * (float4)shadowDistSet;
    shadowDistSet = IntersectJulia(_wcl_allocs, rO, L, mu, maxIterations, epsilon,
      &_wcl_allocs->pa._wcl_shadowHitPoint, &_wcl_allocs->pa._wcl_2_steps);
    if (shadowDistSet < epsilon) {
     if (useAO) {

      shadowFactor = .6f - min(_wcl_allocs->pa._wcl_2_steps / 255.f, .5f);
     } else
      shadowFactor = .6f;
    }
   } else
    shadowDistSet = -1.f;
  }





  _wcl_allocs->pa._wcl_color = Phong(_wcl_allocs, light, eyeRayOrig, _wcl_allocs->pa._wcl_hitPoint, _wcl_allocs->pa._wcl_n, _wcl_allocs->pa._wcl_diffuse) * shadowFactor;
 }





 int offset = 3 * (x + y * width);
 _wcl_allocs->pa._wcl_color = clamp(_wcl_allocs->pa._wcl_color, (float4)(0.f, 0.f ,0.f, 0.f), (float4)(1.f, 1.f ,1.f, 0.f));
 _wcl_allocs->pa._wcl_color /= sampleCount;
 if (enableAccumulation) {
  (*(_wcl_addr_clamp_global_2__u_uglobal__float__Ptr((pixels)+(offset++), 1, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_min, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_max, (__global float *)_wcl_allocs->gl.JuliaGPU__config_min, (__global float *)_wcl_allocs->gl.JuliaGPU__config_max, (__global float *)_wcl_allocs->gn))) += _wcl_allocs->pa._wcl_color.s0;
  (*(_wcl_addr_clamp_global_2__u_uglobal__float__Ptr((pixels)+(offset++), 1, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_min, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_max, (__global float *)_wcl_allocs->gl.JuliaGPU__config_min, (__global float *)_wcl_allocs->gl.JuliaGPU__config_max, (__global float *)_wcl_allocs->gn))) += _wcl_allocs->pa._wcl_color.s1;
  (*(_wcl_addr_clamp_global_2__u_uglobal__float__Ptr((pixels)+(offset), 1, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_min, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_max, (__global float *)_wcl_allocs->gl.JuliaGPU__config_min, (__global float *)_wcl_allocs->gl.JuliaGPU__config_max, (__global float *)_wcl_allocs->gn))) += _wcl_allocs->pa._wcl_color.s2;
 } else {
  (*(_wcl_addr_clamp_global_2__u_uglobal__float__Ptr((pixels)+(offset++), 1, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_min, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_max, (__global float *)_wcl_allocs->gl.JuliaGPU__config_min, (__global float *)_wcl_allocs->gl.JuliaGPU__config_max, (__global float *)_wcl_allocs->gn))) = _wcl_allocs->pa._wcl_color.s0;
  (*(_wcl_addr_clamp_global_2__u_uglobal__float__Ptr((pixels)+(offset++), 1, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_min, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_max, (__global float *)_wcl_allocs->gl.JuliaGPU__config_min, (__global float *)_wcl_allocs->gl.JuliaGPU__config_max, (__global float *)_wcl_allocs->gn))) = _wcl_allocs->pa._wcl_color.s1;
  (*(_wcl_addr_clamp_global_2__u_uglobal__float__Ptr((pixels)+(offset), 1, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_min, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_max, (__global float *)_wcl_allocs->gl.JuliaGPU__config_min, (__global float *)_wcl_allocs->gl.JuliaGPU__config_max, (__global float *)_wcl_allocs->gn))) = _wcl_allocs->pa._wcl_color.s2;
 }
}

/* WebCL Validator JSON header
{
    "version" : "1.0",
    "kernels" :
        {
            "JuliaGPU" :
                {
                    "pixels" :
                        {
                            "index" : 0,
                            "type" : "float *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_pixels_size"
                        },
                    "_wcl_pixels_size" :
                        {
                            "index" : 1,
                            "type" : "ulong"
                        },
                    "config" :
                        {
                            "index" : 2,
                            "type" : "struct _Wcl3Struct *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_config_size"
                        },
                    "_wcl_config_size" :
                        {
                            "index" : 3,
                            "type" : "ulong"
                        },
                    "enableAccumulation" :
                        {
                            "index" : 4,
                            "type" : "int"
                        },
                    "sampleCount" :
                        {
                            "index" : 5,
                            "type" : "int"
                        },
                    "sampleX" :
                        {
                            "index" : 6,
                            "type" : "float"
                        },
                    "sampleY" :
                        {
                            "index" : 7,
                            "type" : "float"
                        }
                }
        }
}
*/

// WebCL Validator: validation stage.
#define _WCL_ADDRESS_SPACE_private_MIN (((128 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_private_ALIGNMENT (128/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_global_MIN (((480 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_global_ALIGNMENT (256/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_local_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_local_ALIGNMENT (8/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_constant_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_constant_ALIGNMENT (8/CHAR_BIT)
typedef struct _WclStruct {
  float x, y, z; // position, also color (r,g,b)
} Vec;

typedef struct _Wcl2Struct {
  /* User defined values */
  Vec orig, target;
  /* Calculated values */
  Vec dir, x, y;
} Camera;

typedef struct _Wcl3Struct {
  unsigned int width, height;
  int superSamplingSize;
  int activateFastRendering;
  int enableShadow;

  unsigned int maxIterations;
  float epsilon;
  float mu[4];
  float light[3];
  Camera camera;
} RenderingConfig;

typedef struct {
    float4 _wcl_r;
    float4 _wcl_2_r;
    float _wcl_dist;
    float4 _wcl_z;
    float4 _wcl_zp;
    float4 _wcl_N;
    float _wcl_gradX;
    float _wcl_gradY;
    float _wcl_gradZ;
    const __global Camera *_wcl_camera;
    float4 _wcl_hitPoint;
    uint _wcl_steps;
    float4 _wcl_diffuse;
    float4 _wcl_n;
    float4 _wcl_color;
    float4 _wcl_shadowHitPoint;
    uint _wcl_2_steps;
} __attribute__ ((aligned (_WCL_ADDRESS_SPACE_private_ALIGNMENT))) _WclPrivates;

typedef struct {
    __global float *JuliaGPU__pixels_min;
    __global float *JuliaGPU__pixels_max;
    const __global RenderingConfig *JuliaGPU__config_min;
    const __global RenderingConfig *JuliaGPU__config_max;
} _WclGlobalLimits;

typedef struct {
    _WclGlobalLimits gl;
    __global uint *gn;
    _WclPrivates pa;
    __private uint *pn;
} _WclProgramAllocations;

__constant uint _wcl_constant_null[_WCL_ADDRESS_SPACE_constant_MIN] = { 0 };

// => General code that doesn't depend on input.

#define _WCL_MEMCPY(dst, src) for(ulong i = 0; i < sizeof((src))/sizeof((src)[0]); i++) { (dst)[i] = (src)[i]; }

#define _WCL_LAST(type, ptr) (((type)(ptr)) - 1)
#define _WCL_FILLCHAR ((uchar)0xCC)

// POCL crashes at run time if the parameters are local character
// pointers.
typedef uint _WclInitType;

// NOTE: this expects that null pointer is type of uint*
#define _WCL_SET_NULL(type, req_bytes, min, max, null) ( ((((type)max)-((type)min))*sizeof(uint) >= req_bytes) ? ((type)min) : (null) )

#ifdef cl_khr_initialize_memory
#pragma OPENCL EXTENSION cl_khr_initialize_memory : enable
#define _WCL_LOCAL_RANGE_INIT(begin, end)
#else

#define _WCL_LOCAL_RANGE_INIT(begin, end) do {               \
    __local uchar *start = (__local uchar *)begin;           \
    __local uchar *stop = (__local uchar *)end;              \
    const size_t z_items = get_local_size(2);                \
    const size_t yz_items = get_local_size(1) * z_items;     \
    const size_t xyz_items = get_local_size(0) * yz_items;   \
    const size_t item_index =                                \
        (get_local_id(0) * yz_items) +                       \
        (get_local_id(1) * z_items) +                        \
        get_local_id(2);                                     \
    size_t item_count = stop - start;                        \
    size_t items_per_kernel = item_count / xyz_items;        \
    size_t items_offset = items_per_kernel * item_index;     \
    size_t reminders = item_count % xyz_items;               \
    if (item_index < reminders) {                            \
        start[xyz_items*items_per_kernel + item_index] = _WCL_FILLCHAR; \
    }                                                                   \
    for (size_t i = 0; i < items_per_kernel; i++) {                     \
        start[items_offset+i] = _WCL_FILLCHAR;                          \
    }                                                                   \
} while (0)                                                             \

#endif // cl_khr_initialize_memory

// <= General code that doesn't depend on input.

bool _wcl_addr_check_private_1_float4__Ptr(float4 *addr, unsigned size, float4 * min0, float4 * max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(float4 *, max0)) );
}
float4 *_wcl_addr_clamp_private_1_float4__Ptr(float4 *addr, unsigned size, float4 * min0, float4 * max0, float4 * asnull)
{
     return _wcl_addr_check_private_1_float4__Ptr(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_private_1_uint__Ptr(uint *addr, unsigned size, uint * min0, uint * max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(uint *, max0)) );
}
uint *_wcl_addr_clamp_private_1_uint__Ptr(uint *addr, unsigned size, uint * min0, uint * max0, uint * asnull)
{
     return _wcl_addr_check_private_1_uint__Ptr(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_global_2__u_uglobal__float__Ptr(__global float *addr, unsigned size, __global float * min0, __global float * max0, __global float * min1, __global float * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(__global float *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(__global float *, max1)) );
}
__global float *_wcl_addr_clamp_global_2__u_uglobal__float__Ptr(__global float *addr, unsigned size, __global float * min0, __global float * max0, __global float * min1, __global float * max1, __global float * asnull)
{
     return _wcl_addr_check_global_2__u_uglobal__float__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_global_2_const___u_uglobal__Camera__Ptr(const __global Camera *addr, unsigned size, const __global Camera * min0, const __global Camera * max0, const __global Camera * min1, const __global Camera * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __global Camera *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(const __global Camera *, max1)) );
}
const __global Camera *_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr(const __global Camera *addr, unsigned size, const __global Camera * min0, const __global Camera * max0, const __global Camera * min1, const __global Camera * max1, const __global Camera * asnull)
{
     return _wcl_addr_check_global_2_const___u_uglobal__Camera__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_global_2_const___u_uglobal__RenderingConfig__Ptr(const __global RenderingConfig *addr, unsigned size, const __global RenderingConfig * min0, const __global RenderingConfig * max0, const __global RenderingConfig * min1, const __global RenderingConfig * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __global RenderingConfig *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(const __global RenderingConfig *, max1)) );
}
const __global RenderingConfig *_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr(const __global RenderingConfig *addr, unsigned size, const __global RenderingConfig * min0, const __global RenderingConfig * max0, const __global RenderingConfig * min1, const __global RenderingConfig * max1, const __global RenderingConfig * asnull)
{
     return _wcl_addr_check_global_2_const___u_uglobal__RenderingConfig__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_global_2_const___u_uglobal__float__Ptr(const __global float *addr, unsigned size, const __global float * min0, const __global float * max0, const __global float * min1, const __global float * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __global float *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(const __global float *, max1)) );
}
const __global float *_wcl_addr_clamp_global_2_const___u_uglobal__float__Ptr(const __global float *addr, unsigned size, const __global float * min0, const __global float * max0, const __global float * min1, const __global float * max1, const __global float * asnull)
{
     return _wcl_addr_check_global_2_const___u_uglobal__float__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}


// WebCL Validator: matching stage 2.
// WebCL Validator: matching stage 1.
/***************************************************************************
 *   Copyright (C) 1998-2013 by authors (see AUTHORS.txt )                 *
 *                                                                         *
 *   This file is part of OCLToys.                                         *
 *                                                                         *
 *   OCLToys is free software; you can redistribute it and/or modify       *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   OCLToys is distributed in the hope that it will be useful,            *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 *                                                                         *
 *   OCLToys website: http://code.google.com/p/ocltoys                     *
 ***************************************************************************/

;

;

;






 float4 QuatMult(_WclProgramAllocations *_wcl_allocs, const float4 q1, const float4 q2) {
 float4 r;

 // a1a2 - b1b2 - c1c2 - d1d2
 _wcl_allocs->pa._wcl_r.x = q1.x * q2.x - q1.y * q2.y - q1.z * q2.z - q1.w * q2.w;
 // a1b2 + b1a2 + c1d2 - d1c2
 _wcl_allocs->pa._wcl_r.y = q1.x * q2.y + q1.y * q2.x + q1.z * q2.w - q1.w * q2.z;
 // a1c2 - b1d2 + c1a2 + d1b2
 _wcl_allocs->pa._wcl_r.z = q1.x * q2.z - q1.y * q2.w + q1.z * q2.x + q1.w * q2.y;
 // a1d2 + b1c2 - c1b2 + d1a2
 _wcl_allocs->pa._wcl_r.w = q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x;

 return _wcl_allocs->pa._wcl_r;
}

 float4 QuatSqr(_WclProgramAllocations *_wcl_allocs, const float4 q) {
 float4 r;

 _wcl_allocs->pa._wcl_2_r.x = q.x * q.x - q.y * q.y - q.z * q.z - q.w * q.w;
 _wcl_allocs->pa._wcl_2_r.y = 2.f * q.x * q.y;
 _wcl_allocs->pa._wcl_2_r.z = 2.f * q.x * q.z;
 _wcl_allocs->pa._wcl_2_r.w = 2.f * q.x * q.w;

 return _wcl_allocs->pa._wcl_2_r;
}

 void IterateIntersect(_WclProgramAllocations *_wcl_allocs, float4 *q, float4 *qp,
  const float4 c, const uint maxIterations) {
 float4 q0 = (*(_wcl_addr_clamp_private_1_float4__Ptr((q), 1, (float4 *)&_wcl_allocs->pa, (float4 *)(&_wcl_allocs->pa + 1), (float4 *)_wcl_allocs->pn)));
 float4 qp0 = (*(_wcl_addr_clamp_private_1_float4__Ptr((qp), 1, (float4 *)&_wcl_allocs->pa, (float4 *)(&_wcl_allocs->pa + 1), (float4 *)_wcl_allocs->pn)));

 for (uint i = 0; i < maxIterations; ++i) {
  qp0 = 2.f * QuatMult(_wcl_allocs, q0, qp0);
  q0 = QuatSqr(_wcl_allocs, q0) + c;

  if (dot(q0, q0) > 1e1f)
   break;
 }

 (*(_wcl_addr_clamp_private_1_float4__Ptr((q), 1, (float4 *)&_wcl_allocs->pa, (float4 *)(&_wcl_allocs->pa + 1), (float4 *)_wcl_allocs->pn))) = q0;
 (*(_wcl_addr_clamp_private_1_float4__Ptr((qp), 1, (float4 *)&_wcl_allocs->pa, (float4 *)(&_wcl_allocs->pa + 1), (float4 *)_wcl_allocs->pn))) = qp0;
}

 float IntersectJulia(_WclProgramAllocations *_wcl_allocs, const float4 eyeRayOrig, const float4 eyeRayDir,
  const float4 c, const uint maxIterations, const float epsilon,
  float4 *hitPoint, uint *steps) {
 float dist;
 float4 r0 = eyeRayOrig;

 uint s = 0;
 do {
  float4 z = r0;;_wcl_allocs->pa._wcl_z = z;
  float4 zp = (float4) (1.f, 0.f, 0.f, 0.f);;_wcl_allocs->pa._wcl_zp = zp;

  IterateIntersect(_wcl_allocs, &_wcl_allocs->pa._wcl_z, &_wcl_allocs->pa._wcl_zp, c, maxIterations);

  const float normZP = length(_wcl_allocs->pa._wcl_zp);

  // We are inside
  if (normZP == 0.f)
   break;

  const float normZ = length(_wcl_allocs->pa._wcl_z);
  _wcl_allocs->pa._wcl_dist = .5f * normZ * log(normZ) / normZP;

  r0 += eyeRayDir * _wcl_allocs->pa._wcl_dist;
  s++;
 } while ((_wcl_allocs->pa._wcl_dist > epsilon) && (dot(r0, r0) < 4.f));

 (*(_wcl_addr_clamp_private_1_float4__Ptr((hitPoint), 1, (float4 *)&_wcl_allocs->pa, (float4 *)(&_wcl_allocs->pa + 1), (float4 *)_wcl_allocs->pn))) = r0;
 (*(_wcl_addr_clamp_private_1_uint__Ptr((steps), 1, (uint *)&_wcl_allocs->pa, (uint *)(&_wcl_allocs->pa + 1), (uint *)_wcl_allocs->pn))) = s;
 return _wcl_allocs->pa._wcl_dist;
}



float IntersectFloorSphere(_WclProgramAllocations *_wcl_allocs, const float4 eyeRayOrig, const float4 eyeRayDir) {
 const float4 op = ((float4)(0.f, -1000.f - 2.f, 0.f, 0.f)) - eyeRayOrig;
 const float b = dot(op, eyeRayDir);
 float det = b * b - dot(op, op) + 1000.f * 1000.f;

 if (det < 0.f)
  return -1.f;
 else
  det = sqrt(det);

 float t = b - det;
 if (t > 0.f)
  return t;
 else {
  // We are inside, avoid the hit
  return -1.f;
 }
}

float IntersectBoundingSphere(_WclProgramAllocations *_wcl_allocs, const float4 eyeRayOrig, const float4 eyeRayDir) {
 const float4 op = -eyeRayOrig;
 const float b = dot(op, eyeRayDir);
 float det = b * b - dot(op, op) + 4.f;

 if (det < 0.f)
  return -1.f;
 else
  det = sqrt(det);

 float t = b - det;
 if (t > 0.f)
  return t;
 else {
  t = b + det;

  if (t > 0.f) {
   // We are inside, start from the ray origin
   return 0.f;
  } else
   return -1.f;
 }
}

 float4 NormEstimate(_WclProgramAllocations *_wcl_allocs, const float4 p, const float4 c,
  const float delta, const uint maxIterations) {
 float4 N;
 float4 qP = p;
 float gradX, gradY, gradZ;

 float4 gx1 = qP - (float4)(1e-4f, 0.f, 0.f, 0.f);
 float4 gx2 = qP + (float4)(1e-4f, 0.f, 0.f, 0.f);
 float4 gy1 = qP - (float4)(0.f, 1e-4f, 0.f, 0.f);
 float4 gy2 = qP + (float4)(0.f, 1e-4f, 0.f, 0.f);
 float4 gz1 = qP - (float4)(0.f, 0.f, 1e-4f, 0.f);
 float4 gz2 = qP + (float4)(0.f, 0.f, 1e-4f, 0.f);

 for (uint i = 0; i < maxIterations; ++i) {
  gx1 = QuatSqr(_wcl_allocs, gx1) + c;
  gx2 = QuatSqr(_wcl_allocs, gx2) + c;
  gy1 = QuatSqr(_wcl_allocs, gy1) + c;
  gy2 = QuatSqr(_wcl_allocs, gy2) + c;
  gz1 = QuatSqr(_wcl_allocs, gz1) + c;
  gz2 = QuatSqr(_wcl_allocs, gz2) + c;
 }

 _wcl_allocs->pa._wcl_gradX = length(gx2) - length(gx1);
 _wcl_allocs->pa._wcl_gradY = length(gy2) - length(gy1);
 _wcl_allocs->pa._wcl_gradZ = length(gz2) - length(gz1);

 _wcl_allocs->pa._wcl_N = normalize((float4)(_wcl_allocs->pa._wcl_gradX, _wcl_allocs->pa._wcl_gradY, _wcl_allocs->pa._wcl_gradZ, 0.f));

 return _wcl_allocs->pa._wcl_N;
}

 float4 Phong(_WclProgramAllocations *_wcl_allocs, const float4 light, const float4 eye, const float4 pt,
  const float4 N, const float4 diffuse) {
 const float4 ambient = (float4) (0.05f, 0.05f, 0.05f, 0.f);
 float4 L = normalize(light - pt);
 float NdotL = dot(N, L);
 if (NdotL < 0.f)
  return diffuse * ambient;

 const float specularExponent = 30.f;
 const float specularity = .65f;

 float4 E = normalize(eye - pt);
 float4 H = (L + E) * .5f;

 return diffuse * NdotL +
   specularity * pow(dot(N, H), specularExponent) +
   diffuse * ambient;
}

__kernel void JuliaGPU(
 __global float *pixels, ulong _wcl_pixels_size,
 const __global RenderingConfig *config, ulong _wcl_config_size,
 const int enableAccumulation,
 const int sampleCount,
 const float sampleX,
 const float sampleY) {
    __local uint _wcl_local_null[_WCL_ADDRESS_SPACE_local_MIN];

    _WclProgramAllocations _wcl_allocations_allocation = {
        { &pixels[0], &pixels[_wcl_pixels_size],&config[0], &config[_wcl_config_size] },
        0,
        { },
        0

    };
    _WclProgramAllocations *_wcl_allocs = &_wcl_allocations_allocation;
    _wcl_allocs->gn = _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.JuliaGPU__pixels_min, _wcl_allocs->gl.JuliaGPU__pixels_max, _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.JuliaGPU__config_min, _wcl_allocs->gl.JuliaGPU__config_max, (__global uint*)0));
    if (_wcl_allocs->gn == (__global uint*)0) return; // not enough space to meet the minimum access. Would be great if we could give info about the problem for the user. 
    _wcl_allocs->pn = _WCL_SET_NULL(__private uint*, _WCL_ADDRESS_SPACE_private_MIN, &_wcl_allocs->pa, (&_wcl_allocs->pa + 1), (__private uint*)0);
    if (_wcl_allocs->pn == (__private uint*)0) return; // not enough space to meet the minimum access. Would be great if we could give info about the problem for the user. 

    const int gid = get_global_id(0);
 const unsigned int width = (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).width;
 const unsigned int height = (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).height;

 const unsigned int x = gid % width;
 const int y = gid / width;

 // Check if we have to do something
 if (y >= height)
  return;

 const float epsilon = (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).activateFastRendering ? ((*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).epsilon * (1.f / 0.75f)) : (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).epsilon;
 const uint maxIterations = max(1u,
   (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).activateFastRendering ? ((*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).maxIterations - 1) : (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).maxIterations);

 const float4 mu = (float4)((*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).mu[0], (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).mu[1], (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).mu[2], (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).mu[3]);
 const float4 light = (float4)((*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).light[0], (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).light[1], (*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).light[2], 0.f);
 const __global Camera *camera = &(*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).camera;;_wcl_allocs->pa._wcl_camera = camera;

 //--------------------------------------------------------------------------
 // Calculate eye ray
 //--------------------------------------------------------------------------

 const float invWidth = 1.f / width;
 const float invHeight = 1.f / height;
 const float kcx = (x + sampleX) * invWidth - .5f;
 const float4 kcx4 = (float4)kcx;
 const float kcy = (y + sampleY) * invHeight - .5f;
 const float4 kcy4 = (float4)kcy;

 const float4 cameraX = (float4)((*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).x.x, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).x.y, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).x.z, 0.f);
 const float4 cameraY = (float4)((*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).y.x, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).y.y, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).y.z, 0.f);
 const float4 cameraDir = (float4)((*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).dir.x, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).dir.y, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).dir.z, 0.f);
 const float4 cameraOrig = (float4)((*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).orig.x, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).orig.y, (*(_wcl_addr_clamp_global_2_const___u_uglobal__Camera__Ptr((_wcl_allocs->pa._wcl_camera), 1, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global Camera *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global Camera *)_wcl_allocs->gn))).orig.z, 0.f);

 const float4 eyeRayDir = normalize(cameraX * kcx4 + cameraY * kcy4 + cameraDir);
 const float4 eyeRayOrig = eyeRayDir * (float4)0.1f + cameraOrig;

 //--------------------------------------------------------------------------
 // Check if we hit the bounding sphere
 //--------------------------------------------------------------------------

 float distSet = IntersectBoundingSphere(_wcl_allocs, eyeRayOrig, eyeRayDir);
 float4 hitPoint;
 if (distSet >= 0.f) {
  //--------------------------------------------------------------------------
  // Find the intersection with the set
  //--------------------------------------------------------------------------

  uint steps;
  float4 rayOrig = eyeRayOrig + eyeRayDir * (float4)distSet;
  distSet = IntersectJulia(_wcl_allocs, rayOrig, eyeRayDir, mu, maxIterations,
    epsilon, &_wcl_allocs->pa._wcl_hitPoint, &_wcl_allocs->pa._wcl_steps);
  if (distSet > epsilon)
   distSet = -1.f;
 }

 //--------------------------------------------------------------------------
 // Check if we hit the floor
 //--------------------------------------------------------------------------

 float distFloor = IntersectFloorSphere(_wcl_allocs, eyeRayOrig, eyeRayDir);

 //--------------------------------------------------------------------------
 // Select the hit point
 //--------------------------------------------------------------------------

 int doShade = 0;
 int useAO = 1;
 float4 diffuse, n, color;
 if ((distSet < 0.f) && (distFloor < 0.f)) {
  // Sky hit
  _wcl_allocs->pa._wcl_color = (float4)(0.f, .1f, .3f, 0.f);
 } else if ((distSet >= 0.f) && ((distFloor < 0.f) || (distSet <= distFloor))) {
  // Set hit
  _wcl_allocs->pa._wcl_diffuse = (float4) (1.f, .35f, .15f, 0.f);
  _wcl_allocs->pa._wcl_n = NormEstimate(_wcl_allocs, _wcl_allocs->pa._wcl_hitPoint, mu, distSet, maxIterations);
  doShade = 1;
 } else if ((distFloor >= 0.f) && ((distSet < 0.f) || (distFloor <= distSet))) {
  // Floor hit
  _wcl_allocs->pa._wcl_hitPoint = eyeRayOrig + eyeRayDir * (float4)distFloor;
  _wcl_allocs->pa._wcl_n = _wcl_allocs->pa._wcl_hitPoint - ((float4)(0.f, -1000.f - 2.f, 0.f, 0.f));
  _wcl_allocs->pa._wcl_n = normalize(_wcl_allocs->pa._wcl_n);
  // The most important feature in a ray tracer: a checker texture !
  const int ix = (_wcl_allocs->pa._wcl_hitPoint.x > 0.f) ? _wcl_allocs->pa._wcl_hitPoint.x : (1.f - _wcl_allocs->pa._wcl_hitPoint.x);
  const int iz = (_wcl_allocs->pa._wcl_hitPoint.z > 0.f) ? _wcl_allocs->pa._wcl_hitPoint.z : (1.f - _wcl_allocs->pa._wcl_hitPoint.z);
  if ((ix + iz) % 2)
   _wcl_allocs->pa._wcl_diffuse = (float4) (.75f, .75f, .75f, 0.f);
  else
   _wcl_allocs->pa._wcl_diffuse = (float4) (.75f, 0.f, 0.f, 0.f);
  doShade = 1;
  useAO = 0;
 }

 //--------------------------------------------------------------------------
 // Select the shadow pass
 //--------------------------------------------------------------------------

 if (doShade) {
  float shadowFactor = 1.f;
  if ((*(_wcl_addr_clamp_global_2_const___u_uglobal__RenderingConfig__Ptr((config), 1, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__pixels_max, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_min, (const __global RenderingConfig *)_wcl_allocs->gl.JuliaGPU__config_max, (const __global RenderingConfig *)_wcl_allocs->gn))).enableShadow) {
   float4 L = normalize(light - _wcl_allocs->pa._wcl_hitPoint);
   float4 rO = _wcl_allocs->pa._wcl_hitPoint + _wcl_allocs->pa._wcl_n * 1e-2f;
   float4 shadowHitPoint;

   // Check bounding sphere
   float shadowDistSet = IntersectBoundingSphere(_wcl_allocs, rO, L);
   if (shadowDistSet >= 0.f) {
    uint steps;

    rO = rO + L * (float4)shadowDistSet;
    shadowDistSet = IntersectJulia(_wcl_allocs, rO, L, mu, maxIterations, epsilon,
      &_wcl_allocs->pa._wcl_shadowHitPoint, &_wcl_allocs->pa._wcl_2_steps);
    if (shadowDistSet < epsilon) {
     if (useAO) {
      // Use steps count to simulate ambient occlusion
      shadowFactor = .6f - min(_wcl_allocs->pa._wcl_2_steps / 255.f, .5f);
     } else
      shadowFactor = .6f;
    }
   } else
    shadowDistSet = -1.f;
  }

  //--------------------------------------------------------------------------
  // Direct lighting of hit point
  //--------------------------------------------------------------------------

  _wcl_allocs->pa._wcl_color = Phong(_wcl_allocs, light, eyeRayOrig, _wcl_allocs->pa._wcl_hitPoint, _wcl_allocs->pa._wcl_n, _wcl_allocs->pa._wcl_diffuse) * shadowFactor;
 }

 //--------------------------------------------------------------------------
 // Write pixel
 //--------------------------------------------------------------------------

 int offset = 3 * (x + y * width);
 _wcl_allocs->pa._wcl_color = clamp(_wcl_allocs->pa._wcl_color, (float4)(0.f, 0.f ,0.f, 0.f), (float4)(1.f, 1.f ,1.f, 0.f));
 _wcl_allocs->pa._wcl_color /= sampleCount;
 if (enableAccumulation) {
  (*(_wcl_addr_clamp_global_2__u_uglobal__float__Ptr((pixels)+(offset++), 1, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_min, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_max, (__global float *)_wcl_allocs->gl.JuliaGPU__config_min, (__global float *)_wcl_allocs->gl.JuliaGPU__config_max, (__global float *)_wcl_allocs->gn))) += _wcl_allocs->pa._wcl_color.s0;
  (*(_wcl_addr_clamp_global_2__u_uglobal__float__Ptr((pixels)+(offset++), 1, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_min, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_max, (__global float *)_wcl_allocs->gl.JuliaGPU__config_min, (__global float *)_wcl_allocs->gl.JuliaGPU__config_max, (__global float *)_wcl_allocs->gn))) += _wcl_allocs->pa._wcl_color.s1;
  (*(_wcl_addr_clamp_global_2__u_uglobal__float__Ptr((pixels)+(offset), 1, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_min, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_max, (__global float *)_wcl_allocs->gl.JuliaGPU__config_min, (__global float *)_wcl_allocs->gl.JuliaGPU__config_max, (__global float *)_wcl_allocs->gn))) += _wcl_allocs->pa._wcl_color.s2;
 } else {
  (*(_wcl_addr_clamp_global_2__u_uglobal__float__Ptr((pixels)+(offset++), 1, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_min, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_max, (__global float *)_wcl_allocs->gl.JuliaGPU__config_min, (__global float *)_wcl_allocs->gl.JuliaGPU__config_max, (__global float *)_wcl_allocs->gn))) = _wcl_allocs->pa._wcl_color.s0;
  (*(_wcl_addr_clamp_global_2__u_uglobal__float__Ptr((pixels)+(offset++), 1, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_min, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_max, (__global float *)_wcl_allocs->gl.JuliaGPU__config_min, (__global float *)_wcl_allocs->gl.JuliaGPU__config_max, (__global float *)_wcl_allocs->gn))) = _wcl_allocs->pa._wcl_color.s1;
  (*(_wcl_addr_clamp_global_2__u_uglobal__float__Ptr((pixels)+(offset), 1, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_min, (__global float *)_wcl_allocs->gl.JuliaGPU__pixels_max, (__global float *)_wcl_allocs->gl.JuliaGPU__config_min, (__global float *)_wcl_allocs->gl.JuliaGPU__config_max, (__global float *)_wcl_allocs->gn))) = _wcl_allocs->pa._wcl_color.s2;
 }
}
