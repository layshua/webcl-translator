
/* WebCL Validator JSON header
{
    "version" : "1.0",
    "kernels" :
        {
            "reduce" :
                {
                    "output" :
                        {
                            "index" : 0,
                            "type" : "float *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_output_size"
                        },
                    "_wcl_output_size" :
                        {
                            "index" : 1,
                            "type" : "ulong"
                        },
                    "input" :
                        {
                            "index" : 2,
                            "type" : "float *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_input_size"
                        },
                    "_wcl_input_size" :
                        {
                            "index" : 3,
                            "type" : "ulong"
                        },
                    "shared" :
                        {
                            "index" : 4,
                            "type" : "float *",
                            "address-space" : "local",
                            "size-parameter" : "_wcl_shared_size"
                        },
                    "_wcl_shared_size" :
                        {
                            "index" : 5,
                            "type" : "ulong"
                        },
                    "n" :
                        {
                            "index" : 6,
                            "type" : "uint"
                        }
                }
        }
}
*/

// WebCL Validator: validation stage.
#define _WCL_ADDRESS_SPACE_private_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_private_ALIGNMENT (8/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_global_MIN (((32 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_global_ALIGNMENT (32/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_local_MIN (((32 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_local_ALIGNMENT (32/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_constant_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_constant_ALIGNMENT (8/CHAR_BIT)
typedef struct {
    __global float *reduce__output_min;
    __global float *reduce__output_max;
    const __global float *reduce__input_min;
    const __global float *reduce__input_max;
} _WclGlobalLimits;

typedef struct {
    __local float *reduce__shared_min;
    __local float *reduce__shared_max;
} _WclLocalLimits;

typedef struct {
    _WclGlobalLimits gl;
    __global uint *gn;
    _WclLocalLimits ll;
    __local uint *ln;
} _WclProgramAllocations;

__constant uint _wcl_constant_null[_WCL_ADDRESS_SPACE_constant_MIN] = { 0 };

// => General code that doesn't depend on input.

#define _WCL_MEMCPY(dst, src) for(ulong i = 0; i < sizeof((src))/sizeof((src)[0]); i++) { (dst)[i] = (src)[i]; }

#define _WCL_LAST(type, ptr) (((type)(ptr)) - 1)
#define _WCL_FILLCHAR ((uchar)0xCC)

// POCL crashes at run time if the parameters are local character
// pointers.
typedef uint _WclInitType;

// NOTE: this expects that null pointer is type of uint*
#define _WCL_SET_NULL(type, req_bytes, min, max, null) ( ((((type)max)-((type)min))*sizeof(uint) >= req_bytes) ? ((type)min) : (null) )

#ifdef cl_khr_initialize_memory
#pragma OPENCL EXTENSION cl_khr_initialize_memory : enable
#define _WCL_LOCAL_RANGE_INIT(begin, end)
#else

// be careful to edit this, this has been carefully tuned to work on every OpenCL driver
// e.g. % item_count was added to start[(items_offset+i)] = _WCL_FILLCHAR;
// to prevent compiler crash on Apple GeForce 640M
#define _WCL_LOCAL_RANGE_INIT(begin, end) do {               \
    __local uchar *start = (__local uchar *)begin;           \
    __local uchar *stop = (__local uchar *)end;              \
    const size_t z_items = get_local_size(2);                \
    const size_t yz_items = get_local_size(1) * z_items;     \
    const size_t xyz_items = get_local_size(0) * yz_items;   \
    const size_t item_index =                                \
        (get_local_id(0) * yz_items) +                       \
        (get_local_id(1) * z_items) +                        \
        get_local_id(2);                                     \
    size_t item_count = stop - start;                        \
    size_t items_per_kernel = item_count / xyz_items;        \
    size_t items_offset = items_per_kernel * item_index;     \
    size_t reminders = item_count % xyz_items;               \
    if (item_index < reminders) {                            \
        start[xyz_items*items_per_kernel + item_index] = _WCL_FILLCHAR; \
    }                                                                   \
    for (size_t i = 0; i < items_per_kernel; i++) {                     \
        start[(items_offset+i) % item_count] = _WCL_FILLCHAR;           \
    }                                                                   \
} while (0)                                                             \

#endif // cl_khr_initialize_memory

constant int hd4k_workaround_constant = 0;

// <= General code that doesn't depend on input.

bool _wcl_addr_check_global_2__u_uglobal__float__Ptr(__global float *addr, unsigned size, __global float * min0, __global float * max0, __global float * min1, __global float * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(__global float *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(__global float *, max1)) );
}
__global float *_wcl_addr_clamp_global_2__u_uglobal__float__Ptr(__global float *addr, unsigned size, __global float * min0, __global float * max0, __global float * min1, __global float * max1, __global float * asnull)
{
     return _wcl_addr_check_global_2__u_uglobal__float__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_global_2_const___u_uglobal__float__Ptr(const __global float *addr, unsigned size, const __global float * min0, const __global float * max0, const __global float * min1, const __global float * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __global float *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(const __global float *, max1)) );
}
const __global float *_wcl_addr_clamp_global_2_const___u_uglobal__float__Ptr(const __global float *addr, unsigned size, const __global float * min0, const __global float * max0, const __global float * min1, const __global float * max1, const __global float * asnull)
{
     return _wcl_addr_check_global_2_const___u_uglobal__float__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_local_1__u_ulocal__float__Ptr(__local float *addr, unsigned size, __local float * min0, __local float * max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(__local float *, max0)) );
}
__local float *_wcl_addr_clamp_local_1__u_ulocal__float__Ptr(__local float *addr, unsigned size, __local float * min0, __local float * max0, __local float * asnull)
{
     return _wcl_addr_check_local_1__u_ulocal__float__Ptr(addr, size, min0, max0) ? addr : asnull;
}


// WebCL Validator: matching stage 2.
// WebCL Validator: matching stage 1.
//
// File:       reduce_float_kernel.cl
//
// Abstract:   This example shows how to perform an efficient parallel reduction using OpenCL.
//             Reduce is a common data parallel primitive which can be used for variety
//             of different operations -- this example computes the global sum for a large
//             number of values, and includes kernels for integer and floating point vector
//             types.
//
// Version:    <1.0>
//
// Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Inc. ("Apple")
//             in consideration of your agreement to the following terms, and your use,
//             installation, modification or redistribution of this Apple software
//             constitutes acceptance of these terms.  If you do not agree with these
//             terms, please do not use, install, modify or redistribute this Apple
//             software.
//
//             In consideration of your agreement to abide by the following terms, and
//             subject to these terms, Apple grants you a personal, non - exclusive
//             license, under Apple's copyrights in this original Apple software ( the
//             "Apple Software" ), to use, reproduce, modify and redistribute the Apple
//             Software, with or without modifications, in source and / or binary forms;
//             provided that if you redistribute the Apple Software in its entirety and
//             without modifications, you must retain this notice and the following text
//             and disclaimers in all such redistributions of the Apple Software. Neither
//             the name, trademarks, service marks or logos of Apple Inc. may be used to
//             endorse or promote products derived from the Apple Software without specific
//             prior written permission from Apple.  Except as expressly stated in this
//             notice, no other rights or licenses, express or implied, are granted by
//             Apple herein, including but not limited to any patent rights that may be
//             infringed by your derivative works or by other works in which the Apple
//             Software may be incorporated.
//
//             The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO
//             WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
//             WARRANTIES OF NON - INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A
//             PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION
//             ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//
//             IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
//             CONSEQUENTIAL DAMAGES ( INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//             SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//             INTERRUPTION ) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION
//             AND / OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER
//             UNDER THEORY OF CONTRACT, TORT ( INCLUDING NEGLIGENCE ), STRICT LIABILITY OR
//             OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Copyright ( C ) 2008 Apple Inc. All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////







////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

__kernel void
reduce(
    __global float *output, ulong _wcl_output_size,
    __global const float *input, ulong _wcl_input_size,
    __local float *shared, ulong _wcl_shared_size,
    const unsigned int n)
{
local int hd4k_workaround_local;
hd4k_workaround_local = hd4k_workaround_constant;
    __local uint _wcl_local_null[_WCL_ADDRESS_SPACE_local_MIN];

    _WclProgramAllocations _wcl_allocations_allocation = {
        { &output[0], &output[_wcl_output_size],&input[0], &input[_wcl_input_size] },
        0,
        { &shared[0], &shared[_wcl_shared_size] },
        _wcl_local_null
    };
    _WclProgramAllocations *_wcl_allocs = &_wcl_allocations_allocation;
    _wcl_allocs->gn = _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.reduce__output_min, _wcl_allocs->gl.reduce__output_max, _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.reduce__input_min, _wcl_allocs->gl.reduce__input_max, (__global uint*)0));
    if (_wcl_allocs->gn == (__global uint*)0) return; // not enough space to meet the minimum access. Would be great if we could give info about the problem for the user. 

    // => Local memory zeroing.
    _WCL_LOCAL_RANGE_INIT(_wcl_allocs->ll.reduce__shared_min, _wcl_allocs->ll.reduce__shared_max);
    _WCL_LOCAL_RANGE_INIT(_wcl_local_null, _wcl_local_null + _WCL_ADDRESS_SPACE_local_MIN);
    barrier(CLK_LOCAL_MEM_FENCE);
    // <= Local memory zeroing.

    const float zero = 0.0f;
    const unsigned int group_id = get_global_id(0) / get_local_size(0);
    const unsigned int group_size = (64);
    const unsigned int group_stride = 2 * group_size;
    const size_t local_stride = group_stride * group_size;

    unsigned int op = 0;
    unsigned int last = (1) - 1;
    for(op = 0; op < (1); op++)
    {
        const unsigned int offset = (last - op);
        const size_t local_id = get_local_id(0) + offset;

        (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = (zero);

        size_t i = group_id * group_stride + local_id;
        while (i < n)
        {
            float a = (*(_wcl_addr_clamp_global_2_const___u_uglobal__float__Ptr((((__global const float*)(input)))+((size_t)(i)), 1, (const __global float *)_wcl_allocs->gl.reduce__output_min, (const __global float *)_wcl_allocs->gl.reduce__output_max, (const __global float *)_wcl_allocs->gl.reduce__input_min, (const __global float *)_wcl_allocs->gl.reduce__input_max, (const __global float *)_wcl_allocs->gn)));
            float b = (*(_wcl_addr_clamp_global_2_const___u_uglobal__float__Ptr((((__global const float*)(input)))+((size_t)(i + group_size)), 1, (const __global float *)_wcl_allocs->gl.reduce__output_min, (const __global float *)_wcl_allocs->gl.reduce__output_max, (const __global float *)_wcl_allocs->gl.reduce__input_min, (const __global float *)_wcl_allocs->gl.reduce__input_max, (const __global float *)_wcl_allocs->gn)));
            float s = (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln)));
            (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((a + b + s));
            i += local_stride;
        }

 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 32) { { float x = (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))); float y = (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + 32)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = (x + y); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 16) { { float x = (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))); float y = (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + 16)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = (x + y); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 8) { { float x = (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))); float y = (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + 8)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = (x + y); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 4) { { float x = (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))); float y = (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + 4)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = (x + y); }; }


    barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 2) { { float x = (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))); float y = (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + 2)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = (x + y); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 1) { { float x = (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))); float y = (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + 1)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = (x + y); }; }


    }

 barrier(CLK_LOCAL_MEM_FENCE);
    if (get_local_id(0) == 0)
    {
        float v = (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(0)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln)));
        (*(_wcl_addr_clamp_global_2__u_uglobal__float__Ptr((((__global float*)(output)))+((size_t)(group_id)), 1, (__global float *)_wcl_allocs->gl.reduce__output_min, (__global float *)_wcl_allocs->gl.reduce__output_max, (__global float *)_wcl_allocs->gl.reduce__input_min, (__global float *)_wcl_allocs->gl.reduce__input_max, (__global float *)_wcl_allocs->gn))) = (v);
    }
}

/* WebCL Validator JSON header
{
    "version" : "1.0",
    "kernels" :
        {
            "reduce" :
                {
                    "output" :
                        {
                            "index" : 0,
                            "type" : "float2 *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_output_size"
                        },
                    "_wcl_output_size" :
                        {
                            "index" : 1,
                            "type" : "ulong"
                        },
                    "input" :
                        {
                            "index" : 2,
                            "type" : "float2 *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_input_size"
                        },
                    "_wcl_input_size" :
                        {
                            "index" : 3,
                            "type" : "ulong"
                        },
                    "shared" :
                        {
                            "index" : 4,
                            "type" : "float2 *",
                            "address-space" : "local",
                            "size-parameter" : "_wcl_shared_size"
                        },
                    "_wcl_shared_size" :
                        {
                            "index" : 5,
                            "type" : "ulong"
                        },
                    "n" :
                        {
                            "index" : 6,
                            "type" : "uint"
                        }
                }
        }
}
*/

// WebCL Validator: validation stage.
#define _WCL_ADDRESS_SPACE_private_MIN (((32 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_private_ALIGNMENT (32/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_global_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_global_ALIGNMENT (8/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_local_MIN (((32 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_local_ALIGNMENT (32/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_constant_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_constant_ALIGNMENT (8/CHAR_BIT)
typedef struct {
    __global float2 *reduce__output_min;
    __global float2 *reduce__output_max;
    const __global float2 *reduce__input_min;
    const __global float2 *reduce__input_max;
} _WclGlobalLimits;

typedef struct {
    __local float2 *reduce__shared_min;
    __local float2 *reduce__shared_max;
} _WclLocalLimits;

typedef struct {
    _WclGlobalLimits gl;
    __global uint *gn;
    _WclLocalLimits ll;
    __local uint *ln;
} _WclProgramAllocations;

__constant uint _wcl_constant_null[_WCL_ADDRESS_SPACE_constant_MIN] = { 0 };

// => General code that doesn't depend on input.

#define _WCL_MEMCPY(dst, src) for(ulong i = 0; i < sizeof((src))/sizeof((src)[0]); i++) { (dst)[i] = (src)[i]; }

#define _WCL_LAST(type, ptr) (((type)(ptr)) - 1)
#define _WCL_FILLCHAR ((uchar)0xCC)

// POCL crashes at run time if the parameters are local character
// pointers.
typedef uint _WclInitType;

// NOTE: this expects that null pointer is type of uint*
#define _WCL_SET_NULL(type, req_bytes, min, max, null) ( ((((type)max)-((type)min))*sizeof(uint) >= req_bytes) ? ((type)min) : (null) )

#ifdef cl_khr_initialize_memory
#pragma OPENCL EXTENSION cl_khr_initialize_memory : enable
#define _WCL_LOCAL_RANGE_INIT(begin, end)
#else

// be careful to edit this, this has been carefully tuned to work on every OpenCL driver
// e.g. % item_count was added to start[(items_offset+i)] = _WCL_FILLCHAR;
// to prevent compiler crash on Apple GeForce 640M
#define _WCL_LOCAL_RANGE_INIT(begin, end) do {               \
    __local uchar *start = (__local uchar *)begin;           \
    __local uchar *stop = (__local uchar *)end;              \
    const size_t z_items = get_local_size(2);                \
    const size_t yz_items = get_local_size(1) * z_items;     \
    const size_t xyz_items = get_local_size(0) * yz_items;   \
    const size_t item_index =                                \
        (get_local_id(0) * yz_items) +                       \
        (get_local_id(1) * z_items) +                        \
        get_local_id(2);                                     \
    size_t item_count = stop - start;                        \
    size_t items_per_kernel = item_count / xyz_items;        \
    size_t items_offset = items_per_kernel * item_index;     \
    size_t reminders = item_count % xyz_items;               \
    if (item_index < reminders) {                            \
        start[xyz_items*items_per_kernel + item_index] = _WCL_FILLCHAR; \
    }                                                                   \
    for (size_t i = 0; i < items_per_kernel; i++) {                     \
        start[(items_offset+i) % item_count] = _WCL_FILLCHAR;           \
    }                                                                   \
} while (0)                                                             \

#endif // cl_khr_initialize_memory

constant int hd4k_workaround_constant = 0;

// <= General code that doesn't depend on input.

bool _wcl_addr_check_private_1_const__float2(const float2addr, unsigned size, const float2 min0, const float2 max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const float2, max0)) );
}
const float2_wcl_addr_clamp_private_1_const__float2(const float2addr, unsigned size, const float2 min0, const float2 max0, const float2 asnull)
{
     return _wcl_addr_check_private_1_const__float2(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_private_1_float___u_uattribute_u_u((ext_uvector_utype(2)))(float __attribute__((ext_vector_type(2)))addr, unsigned size, float __attribute__((ext_vector_type(2))) min0, float __attribute__((ext_vector_type(2))) max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(float __attribute__((ext_vector_type(2))), max0)) );
}
float __attribute__((ext_vector_type(2)))_wcl_addr_clamp_private_1_float___u_uattribute_u_u((ext_uvector_utype(2)))(float __attribute__((ext_vector_type(2)))addr, unsigned size, float __attribute__((ext_vector_type(2))) min0, float __attribute__((ext_vector_type(2))) max0, float __attribute__((ext_vector_type(2))) asnull)
{
     return _wcl_addr_check_private_1_float___u_uattribute_u_u((ext_uvector_utype(2)))(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_private_1_float2(float2addr, unsigned size, float2 min0, float2 max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(float2, max0)) );
}
float2_wcl_addr_clamp_private_1_float2(float2addr, unsigned size, float2 min0, float2 max0, float2 asnull)
{
     return _wcl_addr_check_private_1_float2(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_global_2__u_uglobal__float__Ptr(__global float *addr, unsigned size, __global float * min0, __global float * max0, __global float * min1, __global float * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(__global float *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(__global float *, max1)) );
}
__global float *_wcl_addr_clamp_global_2__u_uglobal__float__Ptr(__global float *addr, unsigned size, __global float * min0, __global float * max0, __global float * min1, __global float * max1, __global float * asnull)
{
     return _wcl_addr_check_global_2__u_uglobal__float__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_global_2_const___u_uglobal__float__Ptr(const __global float *addr, unsigned size, const __global float * min0, const __global float * max0, const __global float * min1, const __global float * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __global float *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(const __global float *, max1)) );
}
const __global float *_wcl_addr_clamp_global_2_const___u_uglobal__float__Ptr(const __global float *addr, unsigned size, const __global float * min0, const __global float * max0, const __global float * min1, const __global float * max1, const __global float * asnull)
{
     return _wcl_addr_check_global_2_const___u_uglobal__float__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_local_1__u_ulocal__float__Ptr(__local float *addr, unsigned size, __local float * min0, __local float * max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(__local float *, max0)) );
}
__local float *_wcl_addr_clamp_local_1__u_ulocal__float__Ptr(__local float *addr, unsigned size, __local float * min0, __local float * max0, __local float * asnull)
{
     return _wcl_addr_check_local_1__u_ulocal__float__Ptr(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_local_1_const___u_ulocal__float__Ptr(const __local float *addr, unsigned size, const __local float * min0, const __local float * max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __local float *, max0)) );
}
const __local float *_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr(const __local float *addr, unsigned size, const __local float * min0, const __local float * max0, const __local float * asnull)
{
     return _wcl_addr_check_local_1_const___u_ulocal__float__Ptr(addr, size, min0, max0) ? addr : asnull;
}


float2 _wcl_vload2_0(_WclProgramAllocations* _wcl_allocs, size_t arg0, const __global float * arg1)
{
    const __global float * ptr = arg1 + 2 * (size_t) arg0;
    if (_wcl_addr_check_global_2_const___u_uglobal__float__Ptr(ptr, 2, (const __global float *)_wcl_allocs->gl.reduce__output_min, (const __global float *)_wcl_allocs->gl.reduce__output_max, (const __global float *)_wcl_allocs->gl.reduce__input_min, (const __global float *)_wcl_allocs->gl.reduce__input_max))
        return vload2(0, ptr);
    else
        return (float) 0;
}
float2 _wcl_vload2_1(_WclProgramAllocations* _wcl_allocs, size_t arg0, const __global float * arg1)
{
    const __global float * ptr = arg1 + 2 * (size_t) arg0;
    if (_wcl_addr_check_global_2_const___u_uglobal__float__Ptr(ptr, 2, (const __global float *)_wcl_allocs->gl.reduce__output_min, (const __global float *)_wcl_allocs->gl.reduce__output_max, (const __global float *)_wcl_allocs->gl.reduce__input_min, (const __global float *)_wcl_allocs->gl.reduce__input_max))
        return vload2(0, ptr);
    else
        return (float) 0;
}
void _wcl_vstore2_2(_WclProgramAllocations* _wcl_allocs, float2 arg0, size_t arg1, __global float * arg2)
{
    __global float * ptr = arg2 + 2 * (size_t) arg1;
    if (_wcl_addr_check_global_2__u_uglobal__float__Ptr(ptr, 2, (__global float *)_wcl_allocs->gl.reduce__output_min, (__global float *)_wcl_allocs->gl.reduce__output_max, (__global float *)_wcl_allocs->gl.reduce__input_min, (__global float *)_wcl_allocs->gl.reduce__input_max))
        vstore2(arg0, 0, ptr);
}
// WebCL Validator: matching stage 2.
// WebCL Validator: matching stage 1.
//
// File:       reduce_float2_kernel.cl
//
// Abstract:   This example shows how to perform an efficient parallel reduction using OpenCL.
//             Reduce is a common data parallel primitive which can be used for variety
//             of different operations -- this example computes the global sum for a large
//             number of values, and includes kernels for integer and floating point vector
//             types.
//
// Version:    <1.0>
//
// Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Inc. ("Apple")
//             in consideration of your agreement to the following terms, and your use,
//             installation, modification or redistribution of this Apple software
//             constitutes acceptance of these terms.  If you do not agree with these
//             terms, please do not use, install, modify or redistribute this Apple
//             software.
//
//             In consideration of your agreement to abide by the following terms, and
//             subject to these terms, Apple grants you a personal, non - exclusive
//             license, under Apple's copyrights in this original Apple software ( the
//             "Apple Software" ), to use, reproduce, modify and redistribute the Apple
//             Software, with or without modifications, in source and / or binary forms;
//             provided that if you redistribute the Apple Software in its entirety and
//             without modifications, you must retain this notice and the following text
//             and disclaimers in all such redistributions of the Apple Software. Neither
//             the name, trademarks, service marks or logos of Apple Inc. may be used to
//             endorse or promote products derived from the Apple Software without specific
//             prior written permission from Apple.  Except as expressly stated in this
//             notice, no other rights or licenses, express or implied, are granted by
//             Apple herein, including but not limited to any patent rights that may be
//             infringed by your derivative works or by other works in which the Apple
//             Software may be incorporated.
//
//             The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO
//             WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
//             WARRANTIES OF NON - INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A
//             PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION
//             ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//
//             IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
//             CONSEQUENTIAL DAMAGES ( INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//             SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//             INTERRUPTION ) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION
//             AND / OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER
//             UNDER THEORY OF CONTRACT, TORT ( INCLUDING NEGLIGENCE ), STRICT LIABILITY OR
//             OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Copyright ( C ) 2008 Apple Inc. All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////







////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

__kernel void
reduce(
    __global float2 *output, ulong _wcl_output_size,
    __global const float2 *input, ulong _wcl_input_size,
    __local float2 *shared, ulong _wcl_shared_size,
    const unsigned int n)
{
local int hd4k_workaround_local;
hd4k_workaround_local = hd4k_workaround_constant;
    __local uint _wcl_local_null[_WCL_ADDRESS_SPACE_local_MIN];

    _WclProgramAllocations _wcl_allocations_allocation = {
        { &output[0], &output[_wcl_output_size],&input[0], &input[_wcl_input_size] },
        0,
        { &shared[0], &shared[_wcl_shared_size] },
        _wcl_local_null
    };
    _WclProgramAllocations *_wcl_allocs = &_wcl_allocations_allocation;
    _wcl_allocs->gn = _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.reduce__output_min, _wcl_allocs->gl.reduce__output_max, _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.reduce__input_min, _wcl_allocs->gl.reduce__input_max, (__global uint*)0));
    if (_wcl_allocs->gn == (__global uint*)0) return; // not enough space to meet the minimum access. Would be great if we could give info about the problem for the user. 

    // => Local memory zeroing.
    _WCL_LOCAL_RANGE_INIT(_wcl_allocs->ll.reduce__shared_min, _wcl_allocs->ll.reduce__shared_max);
    _WCL_LOCAL_RANGE_INIT(_wcl_local_null, _wcl_local_null + _WCL_ADDRESS_SPACE_local_MIN);
    barrier(CLK_LOCAL_MEM_FENCE);
    // <= Local memory zeroing.

    const float2 zero = (float2)(0.0f, 0.0f);
    const unsigned int group_id = get_global_id(0) / get_local_size(0);
    const unsigned int group_size = (64);
    const unsigned int group_stride = 2 * group_size;
    const size_t local_stride = group_stride * group_size;

    unsigned int op = 0;
    unsigned int last = (1) - 1;
    for(op = 0; op < (1); op++)
    {
        const unsigned int offset = (last - op);
        const size_t local_id = get_local_id(0) + offset;

        (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_const__float2(((zero))+(0), 1, (const float2)&_wcl_allocs->pa, (const float2)(&_wcl_allocs->pa + 1), (const float2)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_const__float2(((zero))+(1), 1, (const float2)&_wcl_allocs->pa, (const float2)(&_wcl_allocs->pa + 1), (const float2)_wcl_allocs->pn))));

        size_t i = group_id * group_stride + local_id;
        while (i < n)
        {
            float2 a = _wcl_vload2_0(_wcl_allocs, (size_t)(i), (__global const float*)(input));
            float2 b = _wcl_vload2_1(_wcl_allocs, (size_t)(i + group_size), (__global const float*)(input));
            float2 s = (float2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))));
            (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float___u_uattribute_u_u((ext_uvector_utype(2)))((((a + b + s)))+(0), 1, (float __attribute__((ext_vector_type(2))))&_wcl_allocs->pa, (float __attribute__((ext_vector_type(2))))(&_wcl_allocs->pa + 1), (float __attribute__((ext_vector_type(2))))_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float___u_uattribute_u_u((ext_uvector_utype(2)))((((a + b + s)))+(1), 1, (float __attribute__((ext_vector_type(2))))&_wcl_allocs->pa, (float __attribute__((ext_vector_type(2))))(&_wcl_allocs->pa + 1), (float __attribute__((ext_vector_type(2))))_wcl_allocs->pn))));
            i += local_stride;
        }

 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 32) { { float2 x = (float2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float2 y = (float2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 32)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 32 + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float2 xy = (x + y); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float2(((xy))+(0), 1, (float2)&_wcl_allocs->pa, (float2)(&_wcl_allocs->pa + 1), (float2)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float2(((xy))+(1), 1, (float2)&_wcl_allocs->pa, (float2)(&_wcl_allocs->pa + 1), (float2)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 16) { { float2 x = (float2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float2 y = (float2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 16)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 16 + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float2 xy = (x + y); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float2(((xy))+(0), 1, (float2)&_wcl_allocs->pa, (float2)(&_wcl_allocs->pa + 1), (float2)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float2(((xy))+(1), 1, (float2)&_wcl_allocs->pa, (float2)(&_wcl_allocs->pa + 1), (float2)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 8) { { float2 x = (float2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float2 y = (float2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 8)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 8 + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float2 xy = (x + y); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float2(((xy))+(0), 1, (float2)&_wcl_allocs->pa, (float2)(&_wcl_allocs->pa + 1), (float2)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float2(((xy))+(1), 1, (float2)&_wcl_allocs->pa, (float2)(&_wcl_allocs->pa + 1), (float2)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 4) { { float2 x = (float2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float2 y = (float2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 4)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 4 + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float2 xy = (x + y); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float2(((xy))+(0), 1, (float2)&_wcl_allocs->pa, (float2)(&_wcl_allocs->pa + 1), (float2)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float2(((xy))+(1), 1, (float2)&_wcl_allocs->pa, (float2)(&_wcl_allocs->pa + 1), (float2)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 2) { { float2 x = (float2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float2 y = (float2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 2)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 2 + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float2 xy = (x + y); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float2(((xy))+(0), 1, (float2)&_wcl_allocs->pa, (float2)(&_wcl_allocs->pa + 1), (float2)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float2(((xy))+(1), 1, (float2)&_wcl_allocs->pa, (float2)(&_wcl_allocs->pa + 1), (float2)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 1) { { float2 x = (float2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float2 y = (float2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 1)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 1 + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float2 xy = (x + y); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float2(((xy))+(0), 1, (float2)&_wcl_allocs->pa, (float2)(&_wcl_allocs->pa + 1), (float2)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float2(((xy))+(1), 1, (float2)&_wcl_allocs->pa, (float2)(&_wcl_allocs->pa + 1), (float2)_wcl_allocs->pn)))); }; }


    }

 barrier(CLK_LOCAL_MEM_FENCE);
    if (get_local_id(0) == 0)
    {
        float2 v = (float2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(0)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(0 + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))));
        _wcl_vstore2_2(_wcl_allocs, (v), (size_t)(group_id), (__global float*)(output));
    }
}

/* WebCL Validator JSON header
{
    "version" : "1.0",
    "kernels" :
        {
            "reduce" :
                {
                    "output" :
                        {
                            "index" : 0,
                            "type" : "float4 *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_output_size"
                        },
                    "_wcl_output_size" :
                        {
                            "index" : 1,
                            "type" : "ulong"
                        },
                    "input" :
                        {
                            "index" : 2,
                            "type" : "float4 *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_input_size"
                        },
                    "_wcl_input_size" :
                        {
                            "index" : 3,
                            "type" : "ulong"
                        },
                    "shared" :
                        {
                            "index" : 4,
                            "type" : "float4 *",
                            "address-space" : "local",
                            "size-parameter" : "_wcl_shared_size"
                        },
                    "_wcl_shared_size" :
                        {
                            "index" : 5,
                            "type" : "ulong"
                        },
                    "n" :
                        {
                            "index" : 6,
                            "type" : "uint"
                        }
                }
        }
}
*/

// WebCL Validator: validation stage.
#define _WCL_ADDRESS_SPACE_private_MIN (((32 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_private_ALIGNMENT (32/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_global_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_global_ALIGNMENT (8/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_local_MIN (((32 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_local_ALIGNMENT (32/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_constant_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_constant_ALIGNMENT (8/CHAR_BIT)
typedef struct {
    __global float4 *reduce__output_min;
    __global float4 *reduce__output_max;
    const __global float4 *reduce__input_min;
    const __global float4 *reduce__input_max;
} _WclGlobalLimits;

typedef struct {
    __local float4 *reduce__shared_min;
    __local float4 *reduce__shared_max;
} _WclLocalLimits;

typedef struct {
    _WclGlobalLimits gl;
    __global uint *gn;
    _WclLocalLimits ll;
    __local uint *ln;
} _WclProgramAllocations;

__constant uint _wcl_constant_null[_WCL_ADDRESS_SPACE_constant_MIN] = { 0 };

// => General code that doesn't depend on input.

#define _WCL_MEMCPY(dst, src) for(ulong i = 0; i < sizeof((src))/sizeof((src)[0]); i++) { (dst)[i] = (src)[i]; }

#define _WCL_LAST(type, ptr) (((type)(ptr)) - 1)
#define _WCL_FILLCHAR ((uchar)0xCC)

// POCL crashes at run time if the parameters are local character
// pointers.
typedef uint _WclInitType;

// NOTE: this expects that null pointer is type of uint*
#define _WCL_SET_NULL(type, req_bytes, min, max, null) ( ((((type)max)-((type)min))*sizeof(uint) >= req_bytes) ? ((type)min) : (null) )

#ifdef cl_khr_initialize_memory
#pragma OPENCL EXTENSION cl_khr_initialize_memory : enable
#define _WCL_LOCAL_RANGE_INIT(begin, end)
#else

// be careful to edit this, this has been carefully tuned to work on every OpenCL driver
// e.g. % item_count was added to start[(items_offset+i)] = _WCL_FILLCHAR;
// to prevent compiler crash on Apple GeForce 640M
#define _WCL_LOCAL_RANGE_INIT(begin, end) do {               \
    __local uchar *start = (__local uchar *)begin;           \
    __local uchar *stop = (__local uchar *)end;              \
    const size_t z_items = get_local_size(2);                \
    const size_t yz_items = get_local_size(1) * z_items;     \
    const size_t xyz_items = get_local_size(0) * yz_items;   \
    const size_t item_index =                                \
        (get_local_id(0) * yz_items) +                       \
        (get_local_id(1) * z_items) +                        \
        get_local_id(2);                                     \
    size_t item_count = stop - start;                        \
    size_t items_per_kernel = item_count / xyz_items;        \
    size_t items_offset = items_per_kernel * item_index;     \
    size_t reminders = item_count % xyz_items;               \
    if (item_index < reminders) {                            \
        start[xyz_items*items_per_kernel + item_index] = _WCL_FILLCHAR; \
    }                                                                   \
    for (size_t i = 0; i < items_per_kernel; i++) {                     \
        start[(items_offset+i) % item_count] = _WCL_FILLCHAR;           \
    }                                                                   \
} while (0)                                                             \

#endif // cl_khr_initialize_memory

constant int hd4k_workaround_constant = 0;

// <= General code that doesn't depend on input.

bool _wcl_addr_check_private_1_const__float4(const float4addr, unsigned size, const float4 min0, const float4 max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const float4, max0)) );
}
const float4_wcl_addr_clamp_private_1_const__float4(const float4addr, unsigned size, const float4 min0, const float4 max0, const float4 asnull)
{
     return _wcl_addr_check_private_1_const__float4(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_private_1_float___u_uattribute_u_u((ext_uvector_utype(4)))(float __attribute__((ext_vector_type(4)))addr, unsigned size, float __attribute__((ext_vector_type(4))) min0, float __attribute__((ext_vector_type(4))) max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(float __attribute__((ext_vector_type(4))), max0)) );
}
float __attribute__((ext_vector_type(4)))_wcl_addr_clamp_private_1_float___u_uattribute_u_u((ext_uvector_utype(4)))(float __attribute__((ext_vector_type(4)))addr, unsigned size, float __attribute__((ext_vector_type(4))) min0, float __attribute__((ext_vector_type(4))) max0, float __attribute__((ext_vector_type(4))) asnull)
{
     return _wcl_addr_check_private_1_float___u_uattribute_u_u((ext_uvector_utype(4)))(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_private_1_float4(float4addr, unsigned size, float4 min0, float4 max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(float4, max0)) );
}
float4_wcl_addr_clamp_private_1_float4(float4addr, unsigned size, float4 min0, float4 max0, float4 asnull)
{
     return _wcl_addr_check_private_1_float4(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_global_2__u_uglobal__float__Ptr(__global float *addr, unsigned size, __global float * min0, __global float * max0, __global float * min1, __global float * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(__global float *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(__global float *, max1)) );
}
__global float *_wcl_addr_clamp_global_2__u_uglobal__float__Ptr(__global float *addr, unsigned size, __global float * min0, __global float * max0, __global float * min1, __global float * max1, __global float * asnull)
{
     return _wcl_addr_check_global_2__u_uglobal__float__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_global_2_const___u_uglobal__float__Ptr(const __global float *addr, unsigned size, const __global float * min0, const __global float * max0, const __global float * min1, const __global float * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __global float *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(const __global float *, max1)) );
}
const __global float *_wcl_addr_clamp_global_2_const___u_uglobal__float__Ptr(const __global float *addr, unsigned size, const __global float * min0, const __global float * max0, const __global float * min1, const __global float * max1, const __global float * asnull)
{
     return _wcl_addr_check_global_2_const___u_uglobal__float__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_local_1__u_ulocal__float__Ptr(__local float *addr, unsigned size, __local float * min0, __local float * max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(__local float *, max0)) );
}
__local float *_wcl_addr_clamp_local_1__u_ulocal__float__Ptr(__local float *addr, unsigned size, __local float * min0, __local float * max0, __local float * asnull)
{
     return _wcl_addr_check_local_1__u_ulocal__float__Ptr(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_local_1_const___u_ulocal__float__Ptr(const __local float *addr, unsigned size, const __local float * min0, const __local float * max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __local float *, max0)) );
}
const __local float *_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr(const __local float *addr, unsigned size, const __local float * min0, const __local float * max0, const __local float * asnull)
{
     return _wcl_addr_check_local_1_const___u_ulocal__float__Ptr(addr, size, min0, max0) ? addr : asnull;
}


void _wcl_vstore4_0(_WclProgramAllocations* _wcl_allocs, float4 arg0, size_t arg1, __global float * arg2)
{
    __global float * ptr = arg2 + 4 * (size_t) arg1;
    if (_wcl_addr_check_global_2__u_uglobal__float__Ptr(ptr, 4, (__global float *)_wcl_allocs->gl.reduce__output_min, (__global float *)_wcl_allocs->gl.reduce__output_max, (__global float *)_wcl_allocs->gl.reduce__input_min, (__global float *)_wcl_allocs->gl.reduce__input_max))
        vstore4(arg0, 0, ptr);
}
float4 _wcl_vload4_1(_WclProgramAllocations* _wcl_allocs, size_t arg0, const __global float * arg1)
{
    const __global float * ptr = arg1 + 4 * (size_t) arg0;
    if (_wcl_addr_check_global_2_const___u_uglobal__float__Ptr(ptr, 4, (const __global float *)_wcl_allocs->gl.reduce__output_min, (const __global float *)_wcl_allocs->gl.reduce__output_max, (const __global float *)_wcl_allocs->gl.reduce__input_min, (const __global float *)_wcl_allocs->gl.reduce__input_max))
        return vload4(0, ptr);
    else
        return (float) 0;
}
float4 _wcl_vload4_2(_WclProgramAllocations* _wcl_allocs, size_t arg0, const __global float * arg1)
{
    const __global float * ptr = arg1 + 4 * (size_t) arg0;
    if (_wcl_addr_check_global_2_const___u_uglobal__float__Ptr(ptr, 4, (const __global float *)_wcl_allocs->gl.reduce__output_min, (const __global float *)_wcl_allocs->gl.reduce__output_max, (const __global float *)_wcl_allocs->gl.reduce__input_min, (const __global float *)_wcl_allocs->gl.reduce__input_max))
        return vload4(0, ptr);
    else
        return (float) 0;
}
// WebCL Validator: matching stage 2.
// WebCL Validator: matching stage 1.
//
// File:       reduce_float4_kernel.cl
//
// Abstract:   This example shows how to perform an efficient parallel reduction using OpenCL.
//             Reduce is a common data parallel primitive which can be used for variety
//             of different operations -- this example computes the global sum for a large
//             number of values, and includes kernels for integer and floating point vector
//             types.
//
// Version:    <1.0>
//
// Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Inc. ("Apple")
//             in consideration of your agreement to the following terms, and your use,
//             installation, modification or redistribution of this Apple software
//             constitutes acceptance of these terms.  If you do not agree with these
//             terms, please do not use, install, modify or redistribute this Apple
//             software.
//
//             In consideration of your agreement to abide by the following terms, and
//             subject to these terms, Apple grants you a personal, non - exclusive
//             license, under Apple's copyrights in this original Apple software ( the
//             "Apple Software" ), to use, reproduce, modify and redistribute the Apple
//             Software, with or without modifications, in source and / or binary forms;
//             provided that if you redistribute the Apple Software in its entirety and
//             without modifications, you must retain this notice and the following text
//             and disclaimers in all such redistributions of the Apple Software. Neither
//             the name, trademarks, service marks or logos of Apple Inc. may be used to
//             endorse or promote products derived from the Apple Software without specific
//             prior written permission from Apple.  Except as expressly stated in this
//             notice, no other rights or licenses, express or implied, are granted by
//             Apple herein, including but not limited to any patent rights that may be
//             infringed by your derivative works or by other works in which the Apple
//             Software may be incorporated.
//
//             The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO
//             WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
//             WARRANTIES OF NON - INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A
//             PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION
//             ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//
//             IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
//             CONSEQUENTIAL DAMAGES ( INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//             SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//             INTERRUPTION ) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION
//             AND / OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER
//             UNDER THEORY OF CONTRACT, TORT ( INCLUDING NEGLIGENCE ), STRICT LIABILITY OR
//             OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Copyright ( C ) 2008 Apple Inc. All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////////////////////////////







////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

__kernel void
reduce(
    __global float4 *output, ulong _wcl_output_size,
    __global const float4 *input, ulong _wcl_input_size,
    __local float4 *shared, ulong _wcl_shared_size,
    const unsigned int n)
{
local int hd4k_workaround_local;
hd4k_workaround_local = hd4k_workaround_constant;
    __local uint _wcl_local_null[_WCL_ADDRESS_SPACE_local_MIN];

    _WclProgramAllocations _wcl_allocations_allocation = {
        { &output[0], &output[_wcl_output_size],&input[0], &input[_wcl_input_size] },
        0,
        { &shared[0], &shared[_wcl_shared_size] },
        _wcl_local_null
    };
    _WclProgramAllocations *_wcl_allocs = &_wcl_allocations_allocation;
    _wcl_allocs->gn = _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.reduce__output_min, _wcl_allocs->gl.reduce__output_max, _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.reduce__input_min, _wcl_allocs->gl.reduce__input_max, (__global uint*)0));
    if (_wcl_allocs->gn == (__global uint*)0) return; // not enough space to meet the minimum access. Would be great if we could give info about the problem for the user. 

    // => Local memory zeroing.
    _WCL_LOCAL_RANGE_INIT(_wcl_allocs->ll.reduce__shared_min, _wcl_allocs->ll.reduce__shared_max);
    _WCL_LOCAL_RANGE_INIT(_wcl_local_null, _wcl_local_null + _WCL_ADDRESS_SPACE_local_MIN);
    barrier(CLK_LOCAL_MEM_FENCE);
    // <= Local memory zeroing.

    const float4 zero = (float4)(0.0f, 0.0f, 0.0f, 0.0f);
    const unsigned int group_id = get_global_id(0) / get_local_size(0);
    const unsigned int group_size = (64);
    const unsigned int group_stride = 2 * group_size;
    const size_t local_stride = group_stride * group_size;

    unsigned int op = 0;
    unsigned int last = (1) - 1;
    for(op = 0; op < (1); op++)
    {
        const unsigned int offset = (last - op);
        const size_t local_id = get_local_id(0) + offset;

        (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_const__float4(((zero))+(0), 1, (const float4)&_wcl_allocs->pa, (const float4)(&_wcl_allocs->pa + 1), (const float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_const__float4(((zero))+(1), 1, (const float4)&_wcl_allocs->pa, (const float4)(&_wcl_allocs->pa + 1), (const float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_const__float4(((zero))+(2), 1, (const float4)&_wcl_allocs->pa, (const float4)(&_wcl_allocs->pa + 1), (const float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_const__float4(((zero))+(3), 1, (const float4)&_wcl_allocs->pa, (const float4)(&_wcl_allocs->pa + 1), (const float4)_wcl_allocs->pn))));

        size_t i = group_id * group_stride + local_id;
        while (i < n)
        {
            float4 a = _wcl_vload4_1(_wcl_allocs, (size_t)(i), (__global const float*)(input));
            float4 b = _wcl_vload4_2(_wcl_allocs, (size_t)(i + group_size), (__global const float*)(input));
            float4 s = (float4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))));
            (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float___u_uattribute_u_u((ext_uvector_utype(4)))((((a + b + s)))+(0), 1, (float __attribute__((ext_vector_type(4))))&_wcl_allocs->pa, (float __attribute__((ext_vector_type(4))))(&_wcl_allocs->pa + 1), (float __attribute__((ext_vector_type(4))))_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float___u_uattribute_u_u((ext_uvector_utype(4)))((((a + b + s)))+(1), 1, (float __attribute__((ext_vector_type(4))))&_wcl_allocs->pa, (float __attribute__((ext_vector_type(4))))(&_wcl_allocs->pa + 1), (float __attribute__((ext_vector_type(4))))_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float___u_uattribute_u_u((ext_uvector_utype(4)))((((a + b + s)))+(2), 1, (float __attribute__((ext_vector_type(4))))&_wcl_allocs->pa, (float __attribute__((ext_vector_type(4))))(&_wcl_allocs->pa + 1), (float __attribute__((ext_vector_type(4))))_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float___u_uattribute_u_u((ext_uvector_utype(4)))((((a + b + s)))+(3), 1, (float __attribute__((ext_vector_type(4))))&_wcl_allocs->pa, (float __attribute__((ext_vector_type(4))))(&_wcl_allocs->pa + 1), (float __attribute__((ext_vector_type(4))))_wcl_allocs->pn))));
            i += local_stride;
        }

 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 32) { { float4 x = (float4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float4 y = (float4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 32)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 32 + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 32 + ((64) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 32 + (((64) + (64)) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float4 xy = x + y; (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(0), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(1), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(2), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(3), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 16) { { float4 x = (float4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float4 y = (float4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 16)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 16 + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 16 + ((64) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 16 + (((64) + (64)) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float4 xy = x + y; (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(0), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(1), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(2), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(3), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 8) { { float4 x = (float4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float4 y = (float4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 8)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 8 + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 8 + ((64) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 8 + (((64) + (64)) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float4 xy = x + y; (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(0), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(1), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(2), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(3), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 4) { { float4 x = (float4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float4 y = (float4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 4)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 4 + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 4 + ((64) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 4 + (((64) + (64)) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float4 xy = x + y; (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(0), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(1), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(2), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(3), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 2) { { float4 x = (float4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float4 y = (float4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 2)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 2 + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 2 + ((64) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 2 + (((64) + (64)) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float4 xy = x + y; (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(0), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(1), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(2), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(3), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 1) { { float4 x = (float4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float4 y = (float4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 1)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 1 + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 1 + ((64) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(local_id + 1 + (((64) + (64)) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln))))); float4 xy = x + y; (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id)), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(0), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (64))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(1), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(2), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__float__Ptr((((__local float*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local float *)_wcl_allocs->ll.reduce__shared_min, (__local float *)_wcl_allocs->ll.reduce__shared_max, (__local float *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_float4(((xy))+(3), 1, (float4)&_wcl_allocs->pa, (float4)(&_wcl_allocs->pa + 1), (float4)_wcl_allocs->pn)))); }; }


    }

 barrier(CLK_LOCAL_MEM_FENCE);
    if (get_local_id(0) == 0)
    {
        float4 v = (float4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(0)), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(0 + (64))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(0 + ((64) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__float__Ptr((((__local const float*)(shared)))+((size_t)(0 + (((64) + (64)) + (64)))), 1, (const __local float *)_wcl_allocs->ll.reduce__shared_min, (const __local float *)_wcl_allocs->ll.reduce__shared_max, (const __local float *)_wcl_allocs->ln)))));
        _wcl_vstore4_0(_wcl_allocs, (v), (size_t)(group_id), (__global float*)(output));
    }
}

/* WebCL Validator JSON header
{
    "version" : "1.0",
    "kernels" :
        {
            "reduce" :
                {
                    "output" :
                        {
                            "index" : 0,
                            "type" : "int *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_output_size"
                        },
                    "_wcl_output_size" :
                        {
                            "index" : 1,
                            "type" : "ulong"
                        },
                    "input" :
                        {
                            "index" : 2,
                            "type" : "int *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_input_size"
                        },
                    "_wcl_input_size" :
                        {
                            "index" : 3,
                            "type" : "ulong"
                        },
                    "shared" :
                        {
                            "index" : 4,
                            "type" : "int *",
                            "address-space" : "local",
                            "size-parameter" : "_wcl_shared_size"
                        },
                    "_wcl_shared_size" :
                        {
                            "index" : 5,
                            "type" : "ulong"
                        },
                    "n" :
                        {
                            "index" : 6,
                            "type" : "uint"
                        }
                }
        }
}
*/

// WebCL Validator: validation stage.
#define _WCL_ADDRESS_SPACE_private_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_private_ALIGNMENT (8/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_global_MIN (((32 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_global_ALIGNMENT (32/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_local_MIN (((32 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_local_ALIGNMENT (32/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_constant_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_constant_ALIGNMENT (8/CHAR_BIT)
typedef struct {
    __global int *reduce__output_min;
    __global int *reduce__output_max;
    const __global int *reduce__input_min;
    const __global int *reduce__input_max;
} _WclGlobalLimits;

typedef struct {
    __local int *reduce__shared_min;
    __local int *reduce__shared_max;
} _WclLocalLimits;

typedef struct {
    _WclGlobalLimits gl;
    __global uint *gn;
    _WclLocalLimits ll;
    __local uint *ln;
} _WclProgramAllocations;

__constant uint _wcl_constant_null[_WCL_ADDRESS_SPACE_constant_MIN] = { 0 };

// => General code that doesn't depend on input.

#define _WCL_MEMCPY(dst, src) for(ulong i = 0; i < sizeof((src))/sizeof((src)[0]); i++) { (dst)[i] = (src)[i]; }

#define _WCL_LAST(type, ptr) (((type)(ptr)) - 1)
#define _WCL_FILLCHAR ((uchar)0xCC)

// POCL crashes at run time if the parameters are local character
// pointers.
typedef uint _WclInitType;

// NOTE: this expects that null pointer is type of uint*
#define _WCL_SET_NULL(type, req_bytes, min, max, null) ( ((((type)max)-((type)min))*sizeof(uint) >= req_bytes) ? ((type)min) : (null) )

#ifdef cl_khr_initialize_memory
#pragma OPENCL EXTENSION cl_khr_initialize_memory : enable
#define _WCL_LOCAL_RANGE_INIT(begin, end)
#else

// be careful to edit this, this has been carefully tuned to work on every OpenCL driver
// e.g. % item_count was added to start[(items_offset+i)] = _WCL_FILLCHAR;
// to prevent compiler crash on Apple GeForce 640M
#define _WCL_LOCAL_RANGE_INIT(begin, end) do {               \
    __local uchar *start = (__local uchar *)begin;           \
    __local uchar *stop = (__local uchar *)end;              \
    const size_t z_items = get_local_size(2);                \
    const size_t yz_items = get_local_size(1) * z_items;     \
    const size_t xyz_items = get_local_size(0) * yz_items;   \
    const size_t item_index =                                \
        (get_local_id(0) * yz_items) +                       \
        (get_local_id(1) * z_items) +                        \
        get_local_id(2);                                     \
    size_t item_count = stop - start;                        \
    size_t items_per_kernel = item_count / xyz_items;        \
    size_t items_offset = items_per_kernel * item_index;     \
    size_t reminders = item_count % xyz_items;               \
    if (item_index < reminders) {                            \
        start[xyz_items*items_per_kernel + item_index] = _WCL_FILLCHAR; \
    }                                                                   \
    for (size_t i = 0; i < items_per_kernel; i++) {                     \
        start[(items_offset+i) % item_count] = _WCL_FILLCHAR;           \
    }                                                                   \
} while (0)                                                             \

#endif // cl_khr_initialize_memory

constant int hd4k_workaround_constant = 0;

// <= General code that doesn't depend on input.

bool _wcl_addr_check_global_2__u_uglobal__int__Ptr(__global int *addr, unsigned size, __global int * min0, __global int * max0, __global int * min1, __global int * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(__global int *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(__global int *, max1)) );
}
__global int *_wcl_addr_clamp_global_2__u_uglobal__int__Ptr(__global int *addr, unsigned size, __global int * min0, __global int * max0, __global int * min1, __global int * max1, __global int * asnull)
{
     return _wcl_addr_check_global_2__u_uglobal__int__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_global_2_const___u_uglobal__int__Ptr(const __global int *addr, unsigned size, const __global int * min0, const __global int * max0, const __global int * min1, const __global int * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __global int *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(const __global int *, max1)) );
}
const __global int *_wcl_addr_clamp_global_2_const___u_uglobal__int__Ptr(const __global int *addr, unsigned size, const __global int * min0, const __global int * max0, const __global int * min1, const __global int * max1, const __global int * asnull)
{
     return _wcl_addr_check_global_2_const___u_uglobal__int__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_local_1__u_ulocal__int__Ptr(__local int *addr, unsigned size, __local int * min0, __local int * max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(__local int *, max0)) );
}
__local int *_wcl_addr_clamp_local_1__u_ulocal__int__Ptr(__local int *addr, unsigned size, __local int * min0, __local int * max0, __local int * asnull)
{
     return _wcl_addr_check_local_1__u_ulocal__int__Ptr(addr, size, min0, max0) ? addr : asnull;
}


// WebCL Validator: matching stage 2.
// WebCL Validator: matching stage 1.
//
// File:       reduce_int_kernel.cl
//
// Abstract:   This example shows how to perform an efficient parallel reduction using OpenCL.
//             Reduce is a common data parallel primitive which can be used for variety
//             of different operations -- this example computes the global sum for a large
//             number of values, and includes kernels for integer and floating point vector
//             types.
//
// Version:    <1.0>
//
// Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Inc. ("Apple")
//             in consideration of your agreement to the following terms, and your use,
//             installation, modification or redistribution of this Apple software
//             constitutes acceptance of these terms.  If you do not agree with these
//             terms, please do not use, install, modify or redistribute this Apple
//             software.
//
//             In consideration of your agreement to abide by the following terms, and
//             subject to these terms, Apple grants you a personal, non - exclusive
//             license, under Apple's copyrights in this original Apple software ( the
//             "Apple Software" ), to use, reproduce, modify and redistribute the Apple
//             Software, with or without modifications, in source and / or binary forms;
//             provided that if you redistribute the Apple Software in its entirety and
//             without modifications, you must retain this notice and the following text
//             and disclaimers in all such redistributions of the Apple Software. Neither
//             the name, trademarks, service marks or logos of Apple Inc. may be used to
//             endorse or promote products derived from the Apple Software without specific
//             prior written permission from Apple.  Except as expressly stated in this
//             notice, no other rights or licenses, express or implied, are granted by
//             Apple herein, including but not limited to any patent rights that may be
//             infringed by your derivative works or by other works in which the Apple
//             Software may be incorporated.
//
//             The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO
//             WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
//             WARRANTIES OF NON - INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A
//             PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION
//             ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//
//             IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
//             CONSEQUENTIAL DAMAGES ( INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//             SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//             INTERRUPTION ) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION
//             AND / OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER
//             UNDER THEORY OF CONTRACT, TORT ( INCLUDING NEGLIGENCE ), STRICT LIABILITY OR
//             OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Copyright ( C ) 2008 Apple Inc. All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////







////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

__kernel void
reduce(
    __global int *output, ulong _wcl_output_size,
    __global const int *input, ulong _wcl_input_size,
    __local int *shared, ulong _wcl_shared_size,
    const unsigned int n)
{
local int hd4k_workaround_local;
hd4k_workaround_local = hd4k_workaround_constant;
    __local uint _wcl_local_null[_WCL_ADDRESS_SPACE_local_MIN];

    _WclProgramAllocations _wcl_allocations_allocation = {
        { &output[0], &output[_wcl_output_size],&input[0], &input[_wcl_input_size] },
        0,
        { &shared[0], &shared[_wcl_shared_size] },
        _wcl_local_null
    };
    _WclProgramAllocations *_wcl_allocs = &_wcl_allocations_allocation;
    _wcl_allocs->gn = _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.reduce__output_min, _wcl_allocs->gl.reduce__output_max, _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.reduce__input_min, _wcl_allocs->gl.reduce__input_max, (__global uint*)0));
    if (_wcl_allocs->gn == (__global uint*)0) return; // not enough space to meet the minimum access. Would be great if we could give info about the problem for the user. 

    // => Local memory zeroing.
    _WCL_LOCAL_RANGE_INIT(_wcl_allocs->ll.reduce__shared_min, _wcl_allocs->ll.reduce__shared_max);
    _WCL_LOCAL_RANGE_INIT(_wcl_local_null, _wcl_local_null + _WCL_ADDRESS_SPACE_local_MIN);
    barrier(CLK_LOCAL_MEM_FENCE);
    // <= Local memory zeroing.

    const int zero = 0.0f;
    const unsigned int group_id = get_global_id(0) / get_local_size(0);
    const unsigned int group_size = (64);
    const unsigned int group_stride = 2 * group_size;
    const size_t local_stride = group_stride * group_size;

    unsigned int op = 0;
    unsigned int last = (1) - 1;
    for(op = 0; op < (1); op++)
    {
        const unsigned int offset = (last - op);
        const size_t local_id = get_local_id(0) + offset;

        (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = (zero);

        size_t i = group_id * group_stride + local_id;
        while (i < n)
        {
            int a = (*(_wcl_addr_clamp_global_2_const___u_uglobal__int__Ptr((((__global const int*)(input)))+((size_t)(i)), 1, (const __global int *)_wcl_allocs->gl.reduce__output_min, (const __global int *)_wcl_allocs->gl.reduce__output_max, (const __global int *)_wcl_allocs->gl.reduce__input_min, (const __global int *)_wcl_allocs->gl.reduce__input_max, (const __global int *)_wcl_allocs->gn)));
            int b = (*(_wcl_addr_clamp_global_2_const___u_uglobal__int__Ptr((((__global const int*)(input)))+((size_t)(i + group_size)), 1, (const __global int *)_wcl_allocs->gl.reduce__output_min, (const __global int *)_wcl_allocs->gl.reduce__output_max, (const __global int *)_wcl_allocs->gl.reduce__input_min, (const __global int *)_wcl_allocs->gl.reduce__input_max, (const __global int *)_wcl_allocs->gn)));
            int s = (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln)));
            (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((a + b + s));
            i += local_stride;
        }

 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 32) { { int x = (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))); int y = (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + 32)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = (x + y); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 16) { { int x = (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))); int y = (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + 16)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = (x + y); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 8) { { int x = (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))); int y = (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + 8)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = (x + y); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 4) { { int x = (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))); int y = (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + 4)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = (x + y); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 2) { { int x = (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))); int y = (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + 2)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = (x + y); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 1) { { int x = (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))); int y = (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + 1)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = (x + y); }; }


    }

 barrier(CLK_LOCAL_MEM_FENCE);
    if (get_local_id(0) == 0)
    {
        int v = (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(0)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln)));
        (*(_wcl_addr_clamp_global_2__u_uglobal__int__Ptr((((__global int*)(output)))+((size_t)(group_id)), 1, (__global int *)_wcl_allocs->gl.reduce__output_min, (__global int *)_wcl_allocs->gl.reduce__output_max, (__global int *)_wcl_allocs->gl.reduce__input_min, (__global int *)_wcl_allocs->gl.reduce__input_max, (__global int *)_wcl_allocs->gn))) = (v);
    }
}

/* WebCL Validator JSON header
{
    "version" : "1.0",
    "kernels" :
        {
            "reduce" :
                {
                    "output" :
                        {
                            "index" : 0,
                            "type" : "int2 *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_output_size"
                        },
                    "_wcl_output_size" :
                        {
                            "index" : 1,
                            "type" : "ulong"
                        },
                    "input" :
                        {
                            "index" : 2,
                            "type" : "int2 *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_input_size"
                        },
                    "_wcl_input_size" :
                        {
                            "index" : 3,
                            "type" : "ulong"
                        },
                    "shared" :
                        {
                            "index" : 4,
                            "type" : "int2 *",
                            "address-space" : "local",
                            "size-parameter" : "_wcl_shared_size"
                        },
                    "_wcl_shared_size" :
                        {
                            "index" : 5,
                            "type" : "ulong"
                        },
                    "n" :
                        {
                            "index" : 6,
                            "type" : "uint"
                        }
                }
        }
}
*/

// WebCL Validator: validation stage.
#define _WCL_ADDRESS_SPACE_private_MIN (((32 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_private_ALIGNMENT (32/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_global_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_global_ALIGNMENT (8/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_local_MIN (((32 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_local_ALIGNMENT (32/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_constant_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_constant_ALIGNMENT (8/CHAR_BIT)
typedef struct {
    __global int2 *reduce__output_min;
    __global int2 *reduce__output_max;
    const __global int2 *reduce__input_min;
    const __global int2 *reduce__input_max;
} _WclGlobalLimits;

typedef struct {
    __local int2 *reduce__shared_min;
    __local int2 *reduce__shared_max;
} _WclLocalLimits;

typedef struct {
    _WclGlobalLimits gl;
    __global uint *gn;
    _WclLocalLimits ll;
    __local uint *ln;
} _WclProgramAllocations;

__constant uint _wcl_constant_null[_WCL_ADDRESS_SPACE_constant_MIN] = { 0 };

// => General code that doesn't depend on input.

#define _WCL_MEMCPY(dst, src) for(ulong i = 0; i < sizeof((src))/sizeof((src)[0]); i++) { (dst)[i] = (src)[i]; }

#define _WCL_LAST(type, ptr) (((type)(ptr)) - 1)
#define _WCL_FILLCHAR ((uchar)0xCC)

// POCL crashes at run time if the parameters are local character
// pointers.
typedef uint _WclInitType;

// NOTE: this expects that null pointer is type of uint*
#define _WCL_SET_NULL(type, req_bytes, min, max, null) ( ((((type)max)-((type)min))*sizeof(uint) >= req_bytes) ? ((type)min) : (null) )

#ifdef cl_khr_initialize_memory
#pragma OPENCL EXTENSION cl_khr_initialize_memory : enable
#define _WCL_LOCAL_RANGE_INIT(begin, end)
#else

// be careful to edit this, this has been carefully tuned to work on every OpenCL driver
// e.g. % item_count was added to start[(items_offset+i)] = _WCL_FILLCHAR;
// to prevent compiler crash on Apple GeForce 640M
#define _WCL_LOCAL_RANGE_INIT(begin, end) do {               \
    __local uchar *start = (__local uchar *)begin;           \
    __local uchar *stop = (__local uchar *)end;              \
    const size_t z_items = get_local_size(2);                \
    const size_t yz_items = get_local_size(1) * z_items;     \
    const size_t xyz_items = get_local_size(0) * yz_items;   \
    const size_t item_index =                                \
        (get_local_id(0) * yz_items) +                       \
        (get_local_id(1) * z_items) +                        \
        get_local_id(2);                                     \
    size_t item_count = stop - start;                        \
    size_t items_per_kernel = item_count / xyz_items;        \
    size_t items_offset = items_per_kernel * item_index;     \
    size_t reminders = item_count % xyz_items;               \
    if (item_index < reminders) {                            \
        start[xyz_items*items_per_kernel + item_index] = _WCL_FILLCHAR; \
    }                                                                   \
    for (size_t i = 0; i < items_per_kernel; i++) {                     \
        start[(items_offset+i) % item_count] = _WCL_FILLCHAR;           \
    }                                                                   \
} while (0)                                                             \

#endif // cl_khr_initialize_memory

constant int hd4k_workaround_constant = 0;

// <= General code that doesn't depend on input.

bool _wcl_addr_check_private_1_const__int2(const int2addr, unsigned size, const int2 min0, const int2 max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const int2, max0)) );
}
const int2_wcl_addr_clamp_private_1_const__int2(const int2addr, unsigned size, const int2 min0, const int2 max0, const int2 asnull)
{
     return _wcl_addr_check_private_1_const__int2(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_private_1_int___u_uattribute_u_u((ext_uvector_utype(2)))(int __attribute__((ext_vector_type(2)))addr, unsigned size, int __attribute__((ext_vector_type(2))) min0, int __attribute__((ext_vector_type(2))) max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(int __attribute__((ext_vector_type(2))), max0)) );
}
int __attribute__((ext_vector_type(2)))_wcl_addr_clamp_private_1_int___u_uattribute_u_u((ext_uvector_utype(2)))(int __attribute__((ext_vector_type(2)))addr, unsigned size, int __attribute__((ext_vector_type(2))) min0, int __attribute__((ext_vector_type(2))) max0, int __attribute__((ext_vector_type(2))) asnull)
{
     return _wcl_addr_check_private_1_int___u_uattribute_u_u((ext_uvector_utype(2)))(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_private_1_int2(int2addr, unsigned size, int2 min0, int2 max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(int2, max0)) );
}
int2_wcl_addr_clamp_private_1_int2(int2addr, unsigned size, int2 min0, int2 max0, int2 asnull)
{
     return _wcl_addr_check_private_1_int2(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_global_2__u_uglobal__int__Ptr(__global int *addr, unsigned size, __global int * min0, __global int * max0, __global int * min1, __global int * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(__global int *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(__global int *, max1)) );
}
__global int *_wcl_addr_clamp_global_2__u_uglobal__int__Ptr(__global int *addr, unsigned size, __global int * min0, __global int * max0, __global int * min1, __global int * max1, __global int * asnull)
{
     return _wcl_addr_check_global_2__u_uglobal__int__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_global_2_const___u_uglobal__int__Ptr(const __global int *addr, unsigned size, const __global int * min0, const __global int * max0, const __global int * min1, const __global int * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __global int *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(const __global int *, max1)) );
}
const __global int *_wcl_addr_clamp_global_2_const___u_uglobal__int__Ptr(const __global int *addr, unsigned size, const __global int * min0, const __global int * max0, const __global int * min1, const __global int * max1, const __global int * asnull)
{
     return _wcl_addr_check_global_2_const___u_uglobal__int__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_local_1__u_ulocal__int__Ptr(__local int *addr, unsigned size, __local int * min0, __local int * max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(__local int *, max0)) );
}
__local int *_wcl_addr_clamp_local_1__u_ulocal__int__Ptr(__local int *addr, unsigned size, __local int * min0, __local int * max0, __local int * asnull)
{
     return _wcl_addr_check_local_1__u_ulocal__int__Ptr(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_local_1_const___u_ulocal__int__Ptr(const __local int *addr, unsigned size, const __local int * min0, const __local int * max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __local int *, max0)) );
}
const __local int *_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr(const __local int *addr, unsigned size, const __local int * min0, const __local int * max0, const __local int * asnull)
{
     return _wcl_addr_check_local_1_const___u_ulocal__int__Ptr(addr, size, min0, max0) ? addr : asnull;
}


int2 _wcl_vload2_0(_WclProgramAllocations* _wcl_allocs, size_t arg0, const __global int * arg1)
{
    const __global int * ptr = arg1 + 2 * (size_t) arg0;
    if (_wcl_addr_check_global_2_const___u_uglobal__int__Ptr(ptr, 2, (const __global int *)_wcl_allocs->gl.reduce__output_min, (const __global int *)_wcl_allocs->gl.reduce__output_max, (const __global int *)_wcl_allocs->gl.reduce__input_min, (const __global int *)_wcl_allocs->gl.reduce__input_max))
        return vload2(0, ptr);
    else
        return (int) 0;
}
int2 _wcl_vload2_1(_WclProgramAllocations* _wcl_allocs, size_t arg0, const __global int * arg1)
{
    const __global int * ptr = arg1 + 2 * (size_t) arg0;
    if (_wcl_addr_check_global_2_const___u_uglobal__int__Ptr(ptr, 2, (const __global int *)_wcl_allocs->gl.reduce__output_min, (const __global int *)_wcl_allocs->gl.reduce__output_max, (const __global int *)_wcl_allocs->gl.reduce__input_min, (const __global int *)_wcl_allocs->gl.reduce__input_max))
        return vload2(0, ptr);
    else
        return (int) 0;
}
void _wcl_vstore2_2(_WclProgramAllocations* _wcl_allocs, int2 arg0, size_t arg1, __global int * arg2)
{
    __global int * ptr = arg2 + 2 * (size_t) arg1;
    if (_wcl_addr_check_global_2__u_uglobal__int__Ptr(ptr, 2, (__global int *)_wcl_allocs->gl.reduce__output_min, (__global int *)_wcl_allocs->gl.reduce__output_max, (__global int *)_wcl_allocs->gl.reduce__input_min, (__global int *)_wcl_allocs->gl.reduce__input_max))
        vstore2(arg0, 0, ptr);
}
// WebCL Validator: matching stage 2.
// WebCL Validator: matching stage 1.
//
// File:       reduce_int2_kernel.cl
//
// Abstract:   This example shows how to perform an efficient parallel reduction using OpenCL.
//             Reduce is a common data parallel primitive which can be used for variety
//             of different operations -- this example computes the global sum for a large
//             number of values, and includes kernels for integer and floating point vector
//             types.
//
// Version:    <1.0>
//
// Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Inc. ("Apple")
//             in consideration of your agreement to the following terms, and your use,
//             installation, modification or redistribution of this Apple software
//             constitutes acceptance of these terms.  If you do not agree with these
//             terms, please do not use, install, modify or redistribute this Apple
//             software.
//
//             In consideration of your agreement to abide by the following terms, and
//             subject to these terms, Apple grants you a personal, non - exclusive
//             license, under Apple's copyrights in this original Apple software ( the
//             "Apple Software" ), to use, reproduce, modify and redistribute the Apple
//             Software, with or without modifications, in source and / or binary forms;
//             provided that if you redistribute the Apple Software in its entirety and
//             without modifications, you must retain this notice and the following text
//             and disclaimers in all such redistributions of the Apple Software. Neither
//             the name, trademarks, service marks or logos of Apple Inc. may be used to
//             endorse or promote products derived from the Apple Software without specific
//             prior written permission from Apple.  Except as expressly stated in this
//             notice, no other rights or licenses, express or implied, are granted by
//             Apple herein, including but not limited to any patent rights that may be
//             infringed by your derivative works or by other works in which the Apple
//             Software may be incorporated.
//
//             The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO
//             WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
//             WARRANTIES OF NON - INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A
//             PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION
//             ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//
//             IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
//             CONSEQUENTIAL DAMAGES ( INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//             SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//             INTERRUPTION ) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION
//             AND / OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER
//             UNDER THEORY OF CONTRACT, TORT ( INCLUDING NEGLIGENCE ), STRICT LIABILITY OR
//             OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Copyright ( C ) 2008 Apple Inc. All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////







////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

__kernel void
reduce(
    __global int2 *output, ulong _wcl_output_size,
    __global const int2 *input, ulong _wcl_input_size,
    __local int2 *shared, ulong _wcl_shared_size,
    const unsigned int n)
{
local int hd4k_workaround_local;
hd4k_workaround_local = hd4k_workaround_constant;
    __local uint _wcl_local_null[_WCL_ADDRESS_SPACE_local_MIN];

    _WclProgramAllocations _wcl_allocations_allocation = {
        { &output[0], &output[_wcl_output_size],&input[0], &input[_wcl_input_size] },
        0,
        { &shared[0], &shared[_wcl_shared_size] },
        _wcl_local_null
    };
    _WclProgramAllocations *_wcl_allocs = &_wcl_allocations_allocation;
    _wcl_allocs->gn = _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.reduce__output_min, _wcl_allocs->gl.reduce__output_max, _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.reduce__input_min, _wcl_allocs->gl.reduce__input_max, (__global uint*)0));
    if (_wcl_allocs->gn == (__global uint*)0) return; // not enough space to meet the minimum access. Would be great if we could give info about the problem for the user. 

    // => Local memory zeroing.
    _WCL_LOCAL_RANGE_INIT(_wcl_allocs->ll.reduce__shared_min, _wcl_allocs->ll.reduce__shared_max);
    _WCL_LOCAL_RANGE_INIT(_wcl_local_null, _wcl_local_null + _WCL_ADDRESS_SPACE_local_MIN);
    barrier(CLK_LOCAL_MEM_FENCE);
    // <= Local memory zeroing.

    const int2 zero = (int2)(0.0f, 0.0f);
    const unsigned int group_id = get_global_id(0) / get_local_size(0);
    const unsigned int group_size = (64);
    const unsigned int group_stride = 2 * group_size;
    const size_t local_stride = group_stride * group_size;

    unsigned int op = 0;
    unsigned int last = (1) - 1;
    for(op = 0; op < (1); op++)
    {
        const unsigned int offset = (last - op);
        const size_t local_id = get_local_id(0) + offset;

        (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_const__int2(((zero))+(0), 1, (const int2)&_wcl_allocs->pa, (const int2)(&_wcl_allocs->pa + 1), (const int2)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_const__int2(((zero))+(1), 1, (const int2)&_wcl_allocs->pa, (const int2)(&_wcl_allocs->pa + 1), (const int2)_wcl_allocs->pn))));

        size_t i = group_id * group_stride + local_id;
        while (i < n)
        {
            int2 a = _wcl_vload2_0(_wcl_allocs, (size_t)(i), (__global const int*)(input));
            int2 b = _wcl_vload2_1(_wcl_allocs, (size_t)(i + group_size), (__global const int*)(input));
            int2 s = (int2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))));
            (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int___u_uattribute_u_u((ext_uvector_utype(2)))((((a + b + s)))+(0), 1, (int __attribute__((ext_vector_type(2))))&_wcl_allocs->pa, (int __attribute__((ext_vector_type(2))))(&_wcl_allocs->pa + 1), (int __attribute__((ext_vector_type(2))))_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int___u_uattribute_u_u((ext_uvector_utype(2)))((((a + b + s)))+(1), 1, (int __attribute__((ext_vector_type(2))))&_wcl_allocs->pa, (int __attribute__((ext_vector_type(2))))(&_wcl_allocs->pa + 1), (int __attribute__((ext_vector_type(2))))_wcl_allocs->pn))));
            i += local_stride;
        }

 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 32) { { int2 x = (int2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int2 y = (int2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 32)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 32 + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int2 xy = (x + y); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int2(((xy))+(0), 1, (int2)&_wcl_allocs->pa, (int2)(&_wcl_allocs->pa + 1), (int2)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int2(((xy))+(1), 1, (int2)&_wcl_allocs->pa, (int2)(&_wcl_allocs->pa + 1), (int2)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 16) { { int2 x = (int2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int2 y = (int2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 16)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 16 + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int2 xy = (x + y); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int2(((xy))+(0), 1, (int2)&_wcl_allocs->pa, (int2)(&_wcl_allocs->pa + 1), (int2)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int2(((xy))+(1), 1, (int2)&_wcl_allocs->pa, (int2)(&_wcl_allocs->pa + 1), (int2)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 8) { { int2 x = (int2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int2 y = (int2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 8)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 8 + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int2 xy = (x + y); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int2(((xy))+(0), 1, (int2)&_wcl_allocs->pa, (int2)(&_wcl_allocs->pa + 1), (int2)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int2(((xy))+(1), 1, (int2)&_wcl_allocs->pa, (int2)(&_wcl_allocs->pa + 1), (int2)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 4) { { int2 x = (int2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int2 y = (int2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 4)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 4 + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int2 xy = (x + y); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int2(((xy))+(0), 1, (int2)&_wcl_allocs->pa, (int2)(&_wcl_allocs->pa + 1), (int2)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int2(((xy))+(1), 1, (int2)&_wcl_allocs->pa, (int2)(&_wcl_allocs->pa + 1), (int2)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 2) { { int2 x = (int2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int2 y = (int2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 2)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 2 + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int2 xy = (x + y); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int2(((xy))+(0), 1, (int2)&_wcl_allocs->pa, (int2)(&_wcl_allocs->pa + 1), (int2)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int2(((xy))+(1), 1, (int2)&_wcl_allocs->pa, (int2)(&_wcl_allocs->pa + 1), (int2)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 1) { { int2 x = (int2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int2 y = (int2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 1)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 1 + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int2 xy = (x + y); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int2(((xy))+(0), 1, (int2)&_wcl_allocs->pa, (int2)(&_wcl_allocs->pa + 1), (int2)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int2(((xy))+(1), 1, (int2)&_wcl_allocs->pa, (int2)(&_wcl_allocs->pa + 1), (int2)_wcl_allocs->pn)))); }; }


    }

 barrier(CLK_LOCAL_MEM_FENCE);
    if (get_local_id(0) == 0)
    {
        int2 v = (int2)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(0)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(0 + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))));
        _wcl_vstore2_2(_wcl_allocs, (v), (size_t)(group_id), (__global int*)(output));
    }
}

/* WebCL Validator JSON header
{
    "version" : "1.0",
    "kernels" :
        {
            "reduce" :
                {
                    "output" :
                        {
                            "index" : 0,
                            "type" : "int4 *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_output_size"
                        },
                    "_wcl_output_size" :
                        {
                            "index" : 1,
                            "type" : "ulong"
                        },
                    "input" :
                        {
                            "index" : 2,
                            "type" : "int4 *",
                            "address-space" : "global",
                            "size-parameter" : "_wcl_input_size"
                        },
                    "_wcl_input_size" :
                        {
                            "index" : 3,
                            "type" : "ulong"
                        },
                    "shared" :
                        {
                            "index" : 4,
                            "type" : "int4 *",
                            "address-space" : "local",
                            "size-parameter" : "_wcl_shared_size"
                        },
                    "_wcl_shared_size" :
                        {
                            "index" : 5,
                            "type" : "ulong"
                        },
                    "n" :
                        {
                            "index" : 6,
                            "type" : "uint"
                        }
                }
        }
}
*/

// WebCL Validator: validation stage.
#define _WCL_ADDRESS_SPACE_private_MIN (((32 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_private_ALIGNMENT (32/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_global_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_global_ALIGNMENT (8/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_local_MIN (((32 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_local_ALIGNMENT (32/CHAR_BIT)
#define _WCL_ADDRESS_SPACE_constant_MIN (((8 + (CHAR_BIT - 1)) / CHAR_BIT))
#define _WCL_ADDRESS_SPACE_constant_ALIGNMENT (8/CHAR_BIT)
typedef struct {
    __global int4 *reduce__output_min;
    __global int4 *reduce__output_max;
    const __global int4 *reduce__input_min;
    const __global int4 *reduce__input_max;
} _WclGlobalLimits;

typedef struct {
    __local int4 *reduce__shared_min;
    __local int4 *reduce__shared_max;
} _WclLocalLimits;

typedef struct {
    _WclGlobalLimits gl;
    __global uint *gn;
    _WclLocalLimits ll;
    __local uint *ln;
} _WclProgramAllocations;

__constant uint _wcl_constant_null[_WCL_ADDRESS_SPACE_constant_MIN] = { 0 };

// => General code that doesn't depend on input.

#define _WCL_MEMCPY(dst, src) for(ulong i = 0; i < sizeof((src))/sizeof((src)[0]); i++) { (dst)[i] = (src)[i]; }

#define _WCL_LAST(type, ptr) (((type)(ptr)) - 1)
#define _WCL_FILLCHAR ((uchar)0xCC)

// POCL crashes at run time if the parameters are local character
// pointers.
typedef uint _WclInitType;

// NOTE: this expects that null pointer is type of uint*
#define _WCL_SET_NULL(type, req_bytes, min, max, null) ( ((((type)max)-((type)min))*sizeof(uint) >= req_bytes) ? ((type)min) : (null) )

#ifdef cl_khr_initialize_memory
#pragma OPENCL EXTENSION cl_khr_initialize_memory : enable
#define _WCL_LOCAL_RANGE_INIT(begin, end)
#else

// be careful to edit this, this has been carefully tuned to work on every OpenCL driver
// e.g. % item_count was added to start[(items_offset+i)] = _WCL_FILLCHAR;
// to prevent compiler crash on Apple GeForce 640M
#define _WCL_LOCAL_RANGE_INIT(begin, end) do {               \
    __local uchar *start = (__local uchar *)begin;           \
    __local uchar *stop = (__local uchar *)end;              \
    const size_t z_items = get_local_size(2);                \
    const size_t yz_items = get_local_size(1) * z_items;     \
    const size_t xyz_items = get_local_size(0) * yz_items;   \
    const size_t item_index =                                \
        (get_local_id(0) * yz_items) +                       \
        (get_local_id(1) * z_items) +                        \
        get_local_id(2);                                     \
    size_t item_count = stop - start;                        \
    size_t items_per_kernel = item_count / xyz_items;        \
    size_t items_offset = items_per_kernel * item_index;     \
    size_t reminders = item_count % xyz_items;               \
    if (item_index < reminders) {                            \
        start[xyz_items*items_per_kernel + item_index] = _WCL_FILLCHAR; \
    }                                                                   \
    for (size_t i = 0; i < items_per_kernel; i++) {                     \
        start[(items_offset+i) % item_count] = _WCL_FILLCHAR;           \
    }                                                                   \
} while (0)                                                             \

#endif // cl_khr_initialize_memory

constant int hd4k_workaround_constant = 0;

// <= General code that doesn't depend on input.

bool _wcl_addr_check_private_1_const__int4(const int4addr, unsigned size, const int4 min0, const int4 max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const int4, max0)) );
}
const int4_wcl_addr_clamp_private_1_const__int4(const int4addr, unsigned size, const int4 min0, const int4 max0, const int4 asnull)
{
     return _wcl_addr_check_private_1_const__int4(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_private_1_int___u_uattribute_u_u((ext_uvector_utype(4)))(int __attribute__((ext_vector_type(4)))addr, unsigned size, int __attribute__((ext_vector_type(4))) min0, int __attribute__((ext_vector_type(4))) max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(int __attribute__((ext_vector_type(4))), max0)) );
}
int __attribute__((ext_vector_type(4)))_wcl_addr_clamp_private_1_int___u_uattribute_u_u((ext_uvector_utype(4)))(int __attribute__((ext_vector_type(4)))addr, unsigned size, int __attribute__((ext_vector_type(4))) min0, int __attribute__((ext_vector_type(4))) max0, int __attribute__((ext_vector_type(4))) asnull)
{
     return _wcl_addr_check_private_1_int___u_uattribute_u_u((ext_uvector_utype(4)))(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_private_1_int4(int4addr, unsigned size, int4 min0, int4 max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(int4, max0)) );
}
int4_wcl_addr_clamp_private_1_int4(int4addr, unsigned size, int4 min0, int4 max0, int4 asnull)
{
     return _wcl_addr_check_private_1_int4(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_global_2__u_uglobal__int__Ptr(__global int *addr, unsigned size, __global int * min0, __global int * max0, __global int * min1, __global int * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(__global int *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(__global int *, max1)) );
}
__global int *_wcl_addr_clamp_global_2__u_uglobal__int__Ptr(__global int *addr, unsigned size, __global int * min0, __global int * max0, __global int * min1, __global int * max1, __global int * asnull)
{
     return _wcl_addr_check_global_2__u_uglobal__int__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_global_2_const___u_uglobal__int__Ptr(const __global int *addr, unsigned size, const __global int * min0, const __global int * max0, const __global int * min1, const __global int * max1)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __global int *, max0)) )
        || ( ((addr) >= (min1)) && ((addr + size - 1) <= _WCL_LAST(const __global int *, max1)) );
}
const __global int *_wcl_addr_clamp_global_2_const___u_uglobal__int__Ptr(const __global int *addr, unsigned size, const __global int * min0, const __global int * max0, const __global int * min1, const __global int * max1, const __global int * asnull)
{
     return _wcl_addr_check_global_2_const___u_uglobal__int__Ptr(addr, size, min0, max0, min1, max1) ? addr : asnull;
}

bool _wcl_addr_check_local_1__u_ulocal__int__Ptr(__local int *addr, unsigned size, __local int * min0, __local int * max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(__local int *, max0)) );
}
__local int *_wcl_addr_clamp_local_1__u_ulocal__int__Ptr(__local int *addr, unsigned size, __local int * min0, __local int * max0, __local int * asnull)
{
     return _wcl_addr_check_local_1__u_ulocal__int__Ptr(addr, size, min0, max0) ? addr : asnull;
}

bool _wcl_addr_check_local_1_const___u_ulocal__int__Ptr(const __local int *addr, unsigned size, const __local int * min0, const __local int * max0)
{
      return 0
        || ( ((addr) >= (min0)) && ((addr + size - 1) <= _WCL_LAST(const __local int *, max0)) );
}
const __local int *_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr(const __local int *addr, unsigned size, const __local int * min0, const __local int * max0, const __local int * asnull)
{
     return _wcl_addr_check_local_1_const___u_ulocal__int__Ptr(addr, size, min0, max0) ? addr : asnull;
}


int4 _wcl_vload4_0(_WclProgramAllocations* _wcl_allocs, size_t arg0, const __global int * arg1)
{
    const __global int * ptr = arg1 + 4 * (size_t) arg0;
    if (_wcl_addr_check_global_2_const___u_uglobal__int__Ptr(ptr, 4, (const __global int *)_wcl_allocs->gl.reduce__output_min, (const __global int *)_wcl_allocs->gl.reduce__output_max, (const __global int *)_wcl_allocs->gl.reduce__input_min, (const __global int *)_wcl_allocs->gl.reduce__input_max))
        return vload4(0, ptr);
    else
        return (int) 0;
}
int4 _wcl_vload4_1(_WclProgramAllocations* _wcl_allocs, size_t arg0, const __global int * arg1)
{
    const __global int * ptr = arg1 + 4 * (size_t) arg0;
    if (_wcl_addr_check_global_2_const___u_uglobal__int__Ptr(ptr, 4, (const __global int *)_wcl_allocs->gl.reduce__output_min, (const __global int *)_wcl_allocs->gl.reduce__output_max, (const __global int *)_wcl_allocs->gl.reduce__input_min, (const __global int *)_wcl_allocs->gl.reduce__input_max))
        return vload4(0, ptr);
    else
        return (int) 0;
}
void _wcl_vstore4_2(_WclProgramAllocations* _wcl_allocs, int4 arg0, size_t arg1, __global int * arg2)
{
    __global int * ptr = arg2 + 4 * (size_t) arg1;
    if (_wcl_addr_check_global_2__u_uglobal__int__Ptr(ptr, 4, (__global int *)_wcl_allocs->gl.reduce__output_min, (__global int *)_wcl_allocs->gl.reduce__output_max, (__global int *)_wcl_allocs->gl.reduce__input_min, (__global int *)_wcl_allocs->gl.reduce__input_max))
        vstore4(arg0, 0, ptr);
}
// WebCL Validator: matching stage 2.
// WebCL Validator: matching stage 1.
//
// File:       reduce_int4_kernel.cl
//
// Abstract:   This example shows how to perform an efficient parallel reduction using OpenCL.
//             Reduce is a common data parallel primitive which can be used for variety
//             of different operations -- this example computes the global sum for a large
//             number of values, and includes kernels for integer and floating point vector
//             types.
//
// Version:    <1.0>
//
// Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Inc. ("Apple")
//             in consideration of your agreement to the following terms, and your use,
//             installation, modification or redistribution of this Apple software
//             constitutes acceptance of these terms.  If you do not agree with these
//             terms, please do not use, install, modify or redistribute this Apple
//             software.
//
//             In consideration of your agreement to abide by the following terms, and
//             subject to these terms, Apple grants you a personal, non - exclusive
//             license, under Apple's copyrights in this original Apple software ( the
//             "Apple Software" ), to use, reproduce, modify and redistribute the Apple
//             Software, with or without modifications, in source and / or binary forms;
//             provided that if you redistribute the Apple Software in its entirety and
//             without modifications, you must retain this notice and the following text
//             and disclaimers in all such redistributions of the Apple Software. Neither
//             the name, trademarks, service marks or logos of Apple Inc. may be used to
//             endorse or promote products derived from the Apple Software without specific
//             prior written permission from Apple.  Except as expressly stated in this
//             notice, no other rights or licenses, express or implied, are granted by
//             Apple herein, including but not limited to any patent rights that may be
//             infringed by your derivative works or by other works in which the Apple
//             Software may be incorporated.
//
//             The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO
//             WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
//             WARRANTIES OF NON - INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A
//             PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION
//             ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//
//             IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
//             CONSEQUENTIAL DAMAGES ( INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//             SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//             INTERRUPTION ) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION
//             AND / OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER
//             UNDER THEORY OF CONTRACT, TORT ( INCLUDING NEGLIGENCE ), STRICT LIABILITY OR
//             OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Copyright ( C ) 2008 Apple Inc. All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////////////////////////////







////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

__kernel void
reduce(
    __global int4 *output, ulong _wcl_output_size,
    __global const int4 *input, ulong _wcl_input_size,
    __local int4 *shared, ulong _wcl_shared_size,
    const unsigned int n)
{
local int hd4k_workaround_local;
hd4k_workaround_local = hd4k_workaround_constant;
    __local uint _wcl_local_null[_WCL_ADDRESS_SPACE_local_MIN];

    _WclProgramAllocations _wcl_allocations_allocation = {
        { &output[0], &output[_wcl_output_size],&input[0], &input[_wcl_input_size] },
        0,
        { &shared[0], &shared[_wcl_shared_size] },
        _wcl_local_null
    };
    _WclProgramAllocations *_wcl_allocs = &_wcl_allocations_allocation;
    _wcl_allocs->gn = _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.reduce__output_min, _wcl_allocs->gl.reduce__output_max, _WCL_SET_NULL(__global uint*, _WCL_ADDRESS_SPACE_global_MIN,_wcl_allocs->gl.reduce__input_min, _wcl_allocs->gl.reduce__input_max, (__global uint*)0));
    if (_wcl_allocs->gn == (__global uint*)0) return; // not enough space to meet the minimum access. Would be great if we could give info about the problem for the user. 

    // => Local memory zeroing.
    _WCL_LOCAL_RANGE_INIT(_wcl_allocs->ll.reduce__shared_min, _wcl_allocs->ll.reduce__shared_max);
    _WCL_LOCAL_RANGE_INIT(_wcl_local_null, _wcl_local_null + _WCL_ADDRESS_SPACE_local_MIN);
    barrier(CLK_LOCAL_MEM_FENCE);
    // <= Local memory zeroing.

    const int4 zero = (int4)(0.0f, 0.0f, 0.0f, 0.0f);
    const unsigned int group_id = get_global_id(0) / get_local_size(0);
    const unsigned int group_size = (64);
    const unsigned int group_stride = 2 * group_size;
    const size_t local_stride = group_stride * group_size;

    unsigned int op = 0;
    unsigned int last = (1) - 1;
    for(op = 0; op < (1); op++)
    {
        const unsigned int offset = (last - op);
        const size_t local_id = get_local_id(0) + offset;

        (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_const__int4(((zero))+(0), 1, (const int4)&_wcl_allocs->pa, (const int4)(&_wcl_allocs->pa + 1), (const int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_const__int4(((zero))+(1), 1, (const int4)&_wcl_allocs->pa, (const int4)(&_wcl_allocs->pa + 1), (const int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_const__int4(((zero))+(2), 1, (const int4)&_wcl_allocs->pa, (const int4)(&_wcl_allocs->pa + 1), (const int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_const__int4(((zero))+(3), 1, (const int4)&_wcl_allocs->pa, (const int4)(&_wcl_allocs->pa + 1), (const int4)_wcl_allocs->pn))));

        size_t i = group_id * group_stride + local_id;
        while (i < n)
        {
            int4 a = _wcl_vload4_0(_wcl_allocs, (size_t)(i), (__global const int*)(input));
            int4 b = _wcl_vload4_1(_wcl_allocs, (size_t)(i + group_size), (__global const int*)(input));
            int4 s = (int4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))));
            (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int___u_uattribute_u_u((ext_uvector_utype(4)))((((a + b + s)))+(0), 1, (int __attribute__((ext_vector_type(4))))&_wcl_allocs->pa, (int __attribute__((ext_vector_type(4))))(&_wcl_allocs->pa + 1), (int __attribute__((ext_vector_type(4))))_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int___u_uattribute_u_u((ext_uvector_utype(4)))((((a + b + s)))+(1), 1, (int __attribute__((ext_vector_type(4))))&_wcl_allocs->pa, (int __attribute__((ext_vector_type(4))))(&_wcl_allocs->pa + 1), (int __attribute__((ext_vector_type(4))))_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int___u_uattribute_u_u((ext_uvector_utype(4)))((((a + b + s)))+(2), 1, (int __attribute__((ext_vector_type(4))))&_wcl_allocs->pa, (int __attribute__((ext_vector_type(4))))(&_wcl_allocs->pa + 1), (int __attribute__((ext_vector_type(4))))_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int___u_uattribute_u_u((ext_uvector_utype(4)))((((a + b + s)))+(3), 1, (int __attribute__((ext_vector_type(4))))&_wcl_allocs->pa, (int __attribute__((ext_vector_type(4))))(&_wcl_allocs->pa + 1), (int __attribute__((ext_vector_type(4))))_wcl_allocs->pn))));
            i += local_stride;
        }

 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);




 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 32) { { int4 x = (int4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int4 y = (int4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 32)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 32 + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 32 + ((64) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 32 + (((64) + (64)) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int4 xy = x + y; (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(0), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(1), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(2), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(3), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 16) { { int4 x = (int4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int4 y = (int4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 16)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 16 + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 16 + ((64) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 16 + (((64) + (64)) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int4 xy = x + y; (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(0), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(1), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(2), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(3), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 8) { { int4 x = (int4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int4 y = (int4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 8)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 8 + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 8 + ((64) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 8 + (((64) + (64)) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int4 xy = x + y; (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(0), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(1), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(2), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(3), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 4) { { int4 x = (int4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int4 y = (int4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 4)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 4 + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 4 + ((64) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 4 + (((64) + (64)) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int4 xy = x + y; (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(0), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(1), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(2), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(3), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 2) { { int4 x = (int4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int4 y = (int4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 2)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 2 + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 2 + ((64) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 2 + (((64) + (64)) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int4 xy = x + y; (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(0), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(1), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(2), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(3), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); }; }


 barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < 1) { { int4 x = (int4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int4 y = (int4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 1)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 1 + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 1 + ((64) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(local_id + 1 + (((64) + (64)) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln))))); int4 xy = x + y; (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id)), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(0), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (64))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(1), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + ((64) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(2), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); (*(_wcl_addr_clamp_local_1__u_ulocal__int__Ptr((((__local int*)(shared)))+((size_t)(local_id + (((64) + (64)) + (64)))), 1, (__local int *)_wcl_allocs->ll.reduce__shared_min, (__local int *)_wcl_allocs->ll.reduce__shared_max, (__local int *)_wcl_allocs->ln))) = ((*(_wcl_addr_clamp_private_1_int4(((xy))+(3), 1, (int4)&_wcl_allocs->pa, (int4)(&_wcl_allocs->pa + 1), (int4)_wcl_allocs->pn)))); }; }


    }

 barrier(CLK_LOCAL_MEM_FENCE);
    if (get_local_id(0) == 0)
    {
        int4 v = (int4)( ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(0)), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(0 + (64))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(0 + ((64) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))), ((*(_wcl_addr_clamp_local_1_const___u_ulocal__int__Ptr((((__local const int*)(shared)))+((size_t)(0 + (((64) + (64)) + (64)))), 1, (const __local int *)_wcl_allocs->ll.reduce__shared_min, (const __local int *)_wcl_allocs->ll.reduce__shared_max, (const __local int *)_wcl_allocs->ln)))));
        _wcl_vstore4_2(_wcl_allocs, (v), (size_t)(group_id), (__global int*)(output));
    }
}
