// Copyright (c) 2009-2011 Intel Corporation
// All rights reserved.
// 
// WARRANTY DISCLAIMER
// 
// THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
// MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// Intel Corporation is the author of the Materials, and requests that all
// problem reports or change requests be submitted to it directly

__kernel void __attribute__((vec_type_hint(uint4))) BitonicSort(
						 __global uint4 * keyArray,
						 __global uint4 * valueArray,
						 const uint stage,
						 const uint passOfStage,
						 const uint dir,
						 const uint numWorkItems)
{
	uint i = get_global_id(0);

	if (i>=numWorkItems) 
		return;

	uint4 srcLeft, srcRight;
	uint4 mask;
	uint4 srcValueLeft, srcValueRight;
	//int4 imask10 = (int4)(0,  0, -1, -1);
	//int4 imask11 = (int4)(0, -1,  0, -1);
	uint4 imask10 = (uint4)(0,  0, 0xFFFFFFFF, 0xFFFFFFFF);
	uint4 imask11 = (uint4)(0, 0xFFFFFFFF,  0, 0xFFFFFFFF);

	if(stage > 0)
	{
		if(passOfStage > 0)	//upper level pass, exchange between two fours
		{
			uint r = 1 << (passOfStage - 1);
			uint lmask = r - 1;
			uint left = ((i>>(passOfStage-1)) << passOfStage) + (i & lmask);
			uint right = left + r;
			
			srcLeft = keyArray[left];
			srcRight = keyArray[right];
			srcValueLeft = valueArray[left];
			srcValueRight = valueArray[right];
			mask = as_uint4(srcLeft < srcRight);
			
			uint4 imin = (srcLeft & mask) | (srcRight & ~mask);
			uint4 imax = (srcLeft & ~mask) | (srcRight & mask);
			uint4 vmin = (srcValueLeft & mask) | (srcValueRight & ~mask);
			uint4 vmax = (srcValueLeft & ~mask) | (srcValueRight & mask);
			
			if( ((i>>(stage-1)) & 1) ^ dir )
			{
				keyArray[left]  = imin;
				keyArray[right] = imax;
				valueArray[left]  = vmin;
				valueArray[right] = vmax;
			}
			else
			{
				keyArray[right] = imin;
				keyArray[left]  = imax;
				valueArray[right]  = vmin;
				valueArray[left] = vmax;
			}
		}
		else	//last pass, sort inside one four
		{
			srcLeft = keyArray[i];
			srcRight = srcLeft.zwxy;
			srcValueLeft = valueArray[i];
			srcValueRight = srcValueLeft.zwxy;
			//mask = as_uint4(srcLeft < srcRight) ^ imask10;
			mask = as_uint4(srcLeft < srcRight);
			mask = mask.xyxy;

			if(((i >> stage) & 1) ^ dir)
			{
				srcLeft = (srcLeft & mask) | (srcRight & ~mask);
				srcRight = srcLeft.yxwz;
				srcValueLeft = (srcValueLeft & mask) | (srcValueRight & ~mask);
				srcValueRight = srcValueLeft.yxwz;

				//mask = as_uint4(srcLeft < srcRight) ^ imask11;
				mask = as_uint4(srcLeft < srcRight);
				mask = mask.xxzz;

				keyArray[i] = (srcLeft & mask) | (srcRight & ~mask);
				valueArray[i] = (srcValueLeft & mask) | (srcValueRight & ~mask);
			}
			else
			{
				srcLeft = (srcLeft & ~mask) | (srcRight & mask);
				srcRight = srcLeft.yxwz;
				srcValueLeft = (srcValueLeft & ~mask) | (srcValueRight & mask);
				srcValueRight = srcValueLeft.yxwz;

				//mask = as_uint4(srcLeft < srcRight) ^ imask11;
				mask = as_uint4(srcLeft < srcRight);
				mask = mask.xxzz;

				keyArray[i] = (srcLeft & ~mask) | (srcRight & mask);
				valueArray[i] = (srcValueLeft & ~mask) | (srcValueRight & mask);
			}
		}
	}
	else	//first stage, sort inside one four
	{
		//int4 imask0 = (int4)(0, -1, -1,  0);
		uint4 imask0 = (uint4)(0, 0xFFFFFFFF, 0xFFFFFFFF,  0);
		srcLeft = keyArray[i];
		srcRight = srcLeft.yxwz;
		srcValueLeft = valueArray[i];
		srcValueRight = srcValueLeft.yxwz;
		//mask = as_uint4(srcLeft < srcRight) ^ imask0;
		mask = as_uint4(srcLeft < srcRight);
		mask = mask.xxww;
		if( dir )
		{
			srcLeft = (srcLeft & mask) | (srcRight & ~mask);
			srcValueLeft = (srcValueLeft & mask) | (srcValueRight & ~mask);
		}
		else
		{
			srcLeft = (srcLeft & ~mask) | (srcRight & mask);
			srcValueLeft = (srcValueLeft & ~mask) | (srcValueRight & mask);
		}

		srcRight = srcLeft.zwxy;
		srcValueRight = srcValueLeft.zwxy;
		//mask = as_uint4(srcLeft < srcRight) ^ imask10;
		mask = as_uint4(srcLeft < srcRight);
		mask = mask.xyxy;

		if((i & 1) ^ dir)
		{
			srcLeft = (srcLeft & mask) | (srcRight & ~mask);
			srcRight = srcLeft.yxwz;
			srcValueLeft = (srcValueLeft & mask) | (srcValueRight & ~mask);
			srcValueRight = srcValueLeft.yxwz;

			//mask = as_uint4(srcLeft < srcRight) ^ imask11;
			mask = as_uint4(srcLeft < srcRight);
			mask = mask.xxzz;

			keyArray[i] = (srcLeft & mask) | (srcRight & ~mask);
			valueArray[i] = (srcValueLeft & mask) | (srcValueRight & ~mask);
		}
		else
		{
			srcLeft = (srcLeft & ~mask) | (srcRight & mask);
			srcRight = srcLeft.yxwz;
			srcValueLeft = (srcValueLeft & ~mask) | (srcValueRight & mask);
			srcValueRight = srcValueLeft.yxwz;

			//mask = as_uint4(srcLeft < srcRight) ^ imask11;
			mask = as_uint4(srcLeft < srcRight);
			mask = mask.xxzz;

			keyArray[i] = (srcLeft & ~mask) | (srcRight & mask);
			valueArray[i] = (srcValueLeft & ~mask) | (srcValueRight & mask);
		}
	}
}/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * Please refer to the NVIDIA end user license agreement (EULA) associated
 * with this source code for terms and conditions that govern your use of
 * this software. Any use, reproduction, disclosure, or distribution of
 * this software and related documentation outside the terms of the EULA
 * is strictly prohibited.
 *
 */



//Passed down by clBuildProgram
#define LOCAL_SIZE_LIMIT 512U



inline void ComparatorPrivate(
    uint *keyA,
    uint *valA,
    uint *keyB,
    uint *valB,
    uint arrowDir
){
    if( (*keyA > *keyB) == arrowDir ){
        uint t;
        t = *keyA; *keyA = *keyB; *keyB = t;
        t = *valA; *valA = *valB; *valB = t;
    }
}

inline void ComparatorLocal(
    __local uint *keyA,
    __local uint *valA,
    __local uint *keyB,
    __local uint *valB,
    uint arrowDir
){
    if( (*keyA > *keyB) == arrowDir ){
        uint t;
        t = *keyA; *keyA = *keyB; *keyB = t;
        t = *valA; *valA = *valB; *valB = t;
    }
}

////////////////////////////////////////////////////////////////////////////////
// Monolithic bitonic sort kernel for short arrays fitting into local memory
////////////////////////////////////////////////////////////////////////////////
__kernel __attribute__((reqd_work_group_size(LOCAL_SIZE_LIMIT / 2, 1, 1)))
void bitonicSortLocal(
    __global uint *d_DstKey,
    __global uint *d_DstVal,
    __global uint *d_SrcKey,
    __global uint *d_SrcVal,
    uint arrayLength,
    uint sortDir
){
    __local  uint l_key[LOCAL_SIZE_LIMIT];
    __local  uint l_val[LOCAL_SIZE_LIMIT];

    //Offset to the beginning of subbatch and load data
    d_SrcKey += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_SrcVal += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_DstKey += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_DstVal += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    l_key[get_local_id(0) +                      0] = d_SrcKey[                     0];
    l_val[get_local_id(0) +                      0] = d_SrcVal[                     0];
    l_key[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)] = d_SrcKey[(LOCAL_SIZE_LIMIT / 2)];
    l_val[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)] = d_SrcVal[(LOCAL_SIZE_LIMIT / 2)];

    for(uint size = 2; size < arrayLength; size <<= 1){
        //Bitonic merge
        uint dir = ( (get_local_id(0) & (size / 2)) != 0 );
        for(uint stride = size / 2; stride > 0; stride >>= 1){
            barrier(CLK_LOCAL_MEM_FENCE);
            uint pos = 2 * get_local_id(0) - (get_local_id(0) & (stride - 1));
            ComparatorLocal(
                &l_key[pos +      0], &l_val[pos +      0],
                &l_key[pos + stride], &l_val[pos + stride],
                dir
            );
        }
    }

    //dir == sortDir for the last bitonic merge step
    {
        for(uint stride = arrayLength / 2; stride > 0; stride >>= 1){
            barrier(CLK_LOCAL_MEM_FENCE);
            uint pos = 2 * get_local_id(0) - (get_local_id(0) & (stride - 1));
            ComparatorLocal(
                &l_key[pos +      0], &l_val[pos +      0],
                &l_key[pos + stride], &l_val[pos + stride],
                sortDir
            );
        }
    }

    barrier(CLK_LOCAL_MEM_FENCE);
    d_DstKey[                     0] = l_key[get_local_id(0) +                      0];
    d_DstVal[                     0] = l_val[get_local_id(0) +                      0];
    d_DstKey[(LOCAL_SIZE_LIMIT / 2)] = l_key[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)];
    d_DstVal[(LOCAL_SIZE_LIMIT / 2)] = l_val[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)];
}

////////////////////////////////////////////////////////////////////////////////
// Bitonic sort kernel for large arrays (not fitting into local memory)
////////////////////////////////////////////////////////////////////////////////
//Bottom-level bitonic sort
//Almost the same as bitonicSortLocal with the only exception
//of even / odd subarrays (of LOCAL_SIZE_LIMIT points) being
//sorted in opposite directions
__kernel __attribute__((reqd_work_group_size(LOCAL_SIZE_LIMIT / 2, 1, 1)))
void bitonicSortLocal1(
    __global uint *d_DstKey,
    __global uint *d_DstVal,
    __global uint *d_SrcKey,
    __global uint *d_SrcVal
){
    __local uint l_key[LOCAL_SIZE_LIMIT];
    __local uint l_val[LOCAL_SIZE_LIMIT];

    //Offset to the beginning of subarray and load data
    d_SrcKey += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_SrcVal += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_DstKey += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_DstVal += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    l_key[get_local_id(0) +                      0] = d_SrcKey[                     0];
    l_val[get_local_id(0) +                      0] = d_SrcVal[                     0];
    l_key[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)] = d_SrcKey[(LOCAL_SIZE_LIMIT / 2)];
    l_val[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)] = d_SrcVal[(LOCAL_SIZE_LIMIT / 2)];

    uint comparatorI = get_global_id(0) & ((LOCAL_SIZE_LIMIT / 2) - 1);

    for(uint size = 2; size < LOCAL_SIZE_LIMIT; size <<= 1){
        //Bitonic merge
        uint dir = (comparatorI & (size / 2)) != 0;
        for(uint stride = size / 2; stride > 0; stride >>= 1){
            barrier(CLK_LOCAL_MEM_FENCE);
            uint pos = 2 * get_local_id(0) - (get_local_id(0) & (stride - 1));
            ComparatorLocal(
                &l_key[pos +      0], &l_val[pos +      0],
                &l_key[pos + stride], &l_val[pos + stride],
                dir
            );
        }
    }

    //Odd / even arrays of LOCAL_SIZE_LIMIT elements
    //sorted in opposite directions
    {
        uint dir = (get_group_id(0) & 1);
        for(uint stride = LOCAL_SIZE_LIMIT / 2; stride > 0; stride >>= 1){
            barrier(CLK_LOCAL_MEM_FENCE);
            uint pos = 2 * get_local_id(0) - (get_local_id(0) & (stride - 1));
            ComparatorLocal(
                &l_key[pos +      0], &l_val[pos +      0],
                &l_key[pos + stride], &l_val[pos + stride],
               dir
            );
        }
    }

    barrier(CLK_LOCAL_MEM_FENCE);
    d_DstKey[                     0] = l_key[get_local_id(0) +                      0];
    d_DstVal[                     0] = l_val[get_local_id(0) +                      0];
    d_DstKey[(LOCAL_SIZE_LIMIT / 2)] = l_key[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)];
    d_DstVal[(LOCAL_SIZE_LIMIT / 2)] = l_val[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)];
}

//Bitonic merge iteration for 'stride' >= LOCAL_SIZE_LIMIT
__kernel void bitonicMergeGlobal(
    __global uint *d_DstKey,
    __global uint *d_DstVal,
    __global uint *d_SrcKey,
    __global uint *d_SrcVal,
    uint arrayLength,
    uint size,
    uint stride,
    uint sortDir
){
    uint global_comparatorI = get_global_id(0);
    uint        comparatorI = global_comparatorI & (arrayLength / 2 - 1);

    //Bitonic merge
    uint dir = sortDir ^ ( (comparatorI & (size / 2)) != 0 );
    uint pos = 2 * global_comparatorI - (global_comparatorI & (stride - 1));

    uint keyA = d_SrcKey[pos +      0];
    uint valA = d_SrcVal[pos +      0];
    uint keyB = d_SrcKey[pos + stride];
    uint valB = d_SrcVal[pos + stride];

    ComparatorPrivate(
        &keyA, &valA,
        &keyB, &valB,
        dir
    );

    d_DstKey[pos +      0] = keyA;
    d_DstVal[pos +      0] = valA;
    d_DstKey[pos + stride] = keyB;
    d_DstVal[pos + stride] = valB;
}

//Combined bitonic merge steps for
//'size' > LOCAL_SIZE_LIMIT and 'stride' = [1 .. LOCAL_SIZE_LIMIT / 2]
__kernel __attribute__((reqd_work_group_size(LOCAL_SIZE_LIMIT / 2, 1, 1)))
void bitonicMergeLocal(
    __global uint *d_DstKey,
    __global uint *d_DstVal,
    __global uint *d_SrcKey,
    __global uint *d_SrcVal,
    uint arrayLength,
    uint stride,
    uint size,
    uint sortDir
){
    __local uint l_key[LOCAL_SIZE_LIMIT];
    __local uint l_val[LOCAL_SIZE_LIMIT];

    d_SrcKey += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_SrcVal += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_DstKey += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_DstVal += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    l_key[get_local_id(0) +                      0] = d_SrcKey[                     0];
    l_val[get_local_id(0) +                      0] = d_SrcVal[                     0];
    l_key[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)] = d_SrcKey[(LOCAL_SIZE_LIMIT / 2)];
    l_val[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)] = d_SrcVal[(LOCAL_SIZE_LIMIT / 2)];

    //Bitonic merge
    uint comparatorI = get_global_id(0) & ((arrayLength / 2) - 1);
    uint         dir = sortDir ^ ( (comparatorI & (size / 2)) != 0 );
    for(; stride > 0; stride >>= 1){
        barrier(CLK_LOCAL_MEM_FENCE);
        uint pos = 2 * get_local_id(0) - (get_local_id(0) & (stride - 1));
        ComparatorLocal(
            &l_key[pos +      0], &l_val[pos +      0],
            &l_key[pos + stride], &l_val[pos + stride],
            dir
        );
    }

    barrier(CLK_LOCAL_MEM_FENCE);
    d_DstKey[                     0] = l_key[get_local_id(0) +                      0];
    d_DstVal[                     0] = l_val[get_local_id(0) +                      0];
    d_DstKey[(LOCAL_SIZE_LIMIT / 2)] = l_key[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)];
    d_DstVal[(LOCAL_SIZE_LIMIT / 2)] = l_val[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)];
}

/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/


/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/


#pragma OPENCL EXTENSION cl_amd_printf : enable

/// The maximum number of contact points between two convex shapes. Do
/// not change this value.
#define b2cl_maxManifoldPoints	2

/// The maximum number of vertices on a convex polygon. You cannot increase
/// this too much because b2BlockAllocator has a maximum object size.
#define b2cl_maxPolygonVertices	8

/// A velocity threshold for elastic collisions. Any collision with a relative linear
/// velocity below this threshold will be treated as inelastic.
//#define b2cl_velocityThreshold		0.01f
#define b2cl_velocityThreshold		1.0f

/// This is used to fatten AABBs in the dynamic tree. This is used to predict
/// the future position based on the current displacement.
/// This is a dimensionless multiplier.
#define b2cl_aabbMultiplier		2.0f

#define	b2_maxFloat	FLT_MAX
#define	b2_epsilon FLT_EPSILON
#define b2_pi 3.14159265359f
#define b2_maxTranslation 2.0f
#define b2_maxRotation 0.5f*b2_pi
#define b2_baumgarte 0.2f
#define b2_linearSlop 0.005f
#define b2_angularSlop			(2.0f / 180.0f * b2_pi)
#define b2_polygonRadius		(2.0f * b2_linearSlop)
#define b2_maxLinearCorrection 0.2f
#define b2_maxAngularCorrection		(8.0f / 180.0f * b2_pi)

#ifndef MAXFLOAT
#define MAXFLOAT      3.402823466e+38F
#endif


/// The features that intersect to form the contact point
/// This must be 4 bytes or less.
typedef struct b2clContactFeature
{
	uchar indexA;		///< Feature index on shapeA
	uchar indexB;		///< Feature index on shapeB
	uchar typeA;		///< The feature type on shapeA
	uchar typeB;		///< The feature type on shapeB
} b2clContactFeature;

/// Contact ids to facilitate warm starting.
typedef union b2clContactID
{
	b2clContactFeature cf;
	uint key;					///< Used to quickly compare contact ids.
} b2clContactID;

/// A manifold point is a contact point belonging to a contact
/// manifold. It holds details related to the geometry and dynamics
/// of the contact points.
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleB
/// -e_faceA: the local center of cirlceB or the clip point of polygonB
/// -e_faceB: the clip point of polygonA
/// This structure is stored across time steps, so we keep it small.
/// Note: the impulses are used for internal caching and may not
/// provide reliable contact forces, especially for high speed collisions.
typedef struct b2clManifoldPoint
{
	float2 localPoint;		///< usage depends on manifold type
	float normalImpulse;	///< the non-penetration impulse
	float tangentImpulse;	///< the friction impulse
	b2clContactID id;			///< uniquely identifies a contact point between two shapes
	float dummy; // for alignment
} b2clManifoldPoint;

/// A manifold for two touching convex shapes.
/// Box2D supports multiple types of contact:
/// - clip point versus plane with radius
/// - point versus point with radius (circles)
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleA
/// -e_faceA: the center of faceA
/// -e_faceB: the center of faceB
/// Similarly the local normal usage:
/// -e_circles: not used
/// -e_faceA: the normal on polygonA
/// -e_faceB: the normal on polygonB
/// We store contacts in this way so that position correction can
/// account for movement, which is critical for continuous physics.
/// All contact scenarios must be expressed in one of these types.
/// This structure is stored across time steps, so we keep it small.
typedef struct b2clManifold
{
	float2 localNormal;								///< not use for Type::e_points
	float2 localPoint;								///< usage depends on manifold type
	b2clManifoldPoint points[b2cl_maxManifoldPoints];	///< the points of contact
	int type;
	int pointCount;								///< the number of manifold points
	//float2 test;
} b2clManifold;

typedef struct b2clFilter
{
	unsigned short categoryBits;
	unsigned short maskBits;
	short groupIndex;
	short dummy;
} b2clFilter;

/// A convex polygon. It is assumed that the interior of the polygon is to
/// the left of each edge.
/// Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.
/// In most cases you should not need many vertices for a convex polygon.
//////////////
/// We reuse b2clPolygonShape for b2clCircleShape
/// We may have to change this later
typedef struct b2clPolygonShape
{
	float2 m_centroid;
	float2 m_vertices[b2cl_maxPolygonVertices];
	float2 m_normals[b2cl_maxPolygonVertices];
	int m_type;
	float m_radius;
	int m_vertexCount;
	int m_bIsSensor;
	b2clFilter m_filter;
} b2clPolygonShape;

/// A transform contains translation and rotation. It is used to represent
/// the position and orientation of rigid frames.
typedef struct b2clTransform
{
	float2 p;
	float2 q;
} b2clTransform;

/// This describes the motion of a body/shape for TOI computation.
/// Shapes are defined with respect to the body origin, which may
/// no coincide with the center of mass. However, to support dynamics
/// we must interpolate the center of mass position.
typedef struct b2clSweep
{
	float2 localCenter;	///< local center of mass position
	float2 c0, c;		///< center world positions
	float a0, a;		///< world angles

	/// Fraction of the current time step in the range [0,1]
	/// c0 and a0 are the positions at alpha0.
	float alpha0;
	float dummy;
}  b2clSweep;

/// Used for computing contact manifolds.
typedef struct b2clClipVertex
{
	float2 v;
	b2clContactID id;
} b2clClipVertex;

typedef struct clb2Velocity
{
    float vx;
    float vy;
    float w;
}clb2Velocity;

typedef struct clb2Position
{
    float cx;
    float cy;
    float a;
}clb2Position;

typedef struct clb2Contact
{
    int color;
    int indexA;
    int indexB;
    float friction;
    float2 normal;
    float invMassA;
    float invIA;
    float invMassB;
    float invIB;
}clb2Contact;

typedef struct clb2Impulse
{
    float normalImpulse1;
    float tangentImpulse1;
    
    float normalImpulse2;
    float tangentImpulse2;
}clb2Impulse;

typedef struct clb2Points
{
    float2 rA1;
    float2 rB1;
    float normalMass1;
    float tangentMass1;
    
    float2 rA2;
    float2 rB2;
    float normalMass2;
    float tangentMass2;
    
    float velocityBias1;
    float velocityBias2;
}clb2Points;

typedef struct b2clFixtureStatic
{
	float m_friction;
	float m_restitution;
	int m_last_uid;
	int dummy; 
} b2clFixtureStatic;

#define MAX_CONNECTED_BODY_INDICES 8
typedef struct b2clBodyStatic
{
	float2 m_localCenter;	///< local center of mass position
	float /*m_mass,*/ m_invMass;
	// Rotational inertia about the center of mass.
	float /*m_I,*/ m_invI;
	float m_linearDamping;
	float m_angularDamping;
	float m_gravityScale;
	float m_type;
	int m_connectedBodyIndices[MAX_CONNECTED_BODY_INDICES];
	int m_bIsBullet;
	int dummy;
} b2clBodyStatic;

typedef struct b2clBodyDynamic
{
	b2clSweep m_sweep;		// the swept motion for CCD

	float2 m_linearVelocity;
	float2 m_force;
	float m_angularVelocity;
	float m_torque;
	int m_last_uid ;
	int dummy ; 
} b2clBodyDynamic;

// Extract useful information of manifolds for position constraint solver
typedef struct clb2Manifold
{
    float2 localNormal;
    float2 localPoint;
    float2 localPoints1;
    float2 localPoints2;
    int pointCount;
    int type;
    float radiusA;
    float radiusB;
    float2 localCenterA;
    float2 localCenterB;
}clb2Manifold;

typedef struct{
    int type;
	int pointCount;
	float localPointX;
	float localPointY;
	float localNormalX;
	float localNormalY; 
	float point0X;
	float point0Y;
	float point1X;
	float point1Y; 
}clb2SDManifold;

typedef struct{
	int fixtureAIndex;
	int fixtureBIndex;
	int bodyAIndex ; 
	int bodyBIndex ; 
}clb2SDContact;

typedef struct{
	int bodyIndex ;
	float posX;
	float posY ; 
	float posAngle;
	float xfX;
	float xfY;
	float xfS;
	float xfC;
	float alpha;
	float velocityX;
	float velocityY;
	float velocityAngular; 
}clb2SDBody;

typedef struct clb2PositionSolverManifold
{
    float2 normal;
    float2 point;
    float separation;
}clb2PositionSolverManifold;

typedef struct clb2Rotation
{
    float s;
    float c;
}clb2Rotation;

typedef struct clb2Transform
{
    clb2Rotation rotation;
    float2 translation;
}clb2Transform;

typedef struct b2clMat22
{
	float ex[2];
	float ey[2];
}b2clMat22;

typedef struct b2clMat33
{
	float ex[3];
	float ey[3];
	float ez[3];
}b2clMat33;

enum b2clLimitState
{
	e_inactiveLimit,
	e_atLowerLimit,
	e_atUpperLimit,
	e_equalLimits
};

enum b2JointType
{
	e_unknownJoint,
	e_revoluteJoint,
	e_prismaticJoint,
	e_distanceJoint,
	e_pulleyJoint,
	e_mouseJoint,
	e_gearJoint,
	e_wheelJoint,
    e_weldJoint,
	e_frictionJoint,
	e_ropeJoint
};

typedef struct b2clDistanceJointDatastruct
{
	float frequencyHz;
	float dampingRatio;
	float bias;

	float localAnchorA[2];
	float localAnchorB[2];
	float gamma;
	float nlength;

	float u[2];
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	float mass;
} b2clDistanceJointData;

typedef struct b2clRevoluteJointData
{
	float localAnchorA[2];
	float localAnchorB[2];

	int enableMotor;
	float maxMotorTorque;
	float motorSpeed;

	int enableLimit;
	float referenceAngle;
	float lowerAngle;
	float upperAngle;

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat33 mass;			// effective mass for point-to-point constraint.
	float motorMass;	// effective mass for motor/limit angular constraint.
	int limitState;
} b2clRevoluteJointData;

typedef struct b2clPrismaticJointData
{
	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float localXAxisA[2];
	float localYAxisA[2];
	float referenceAngle;
	float lowerTranslation;
	float upperTranslation;
	float maxMotorForce;
	float motorSpeed;
	int enableLimit;
	int enableMotor;
	int limitState;

	// Solver temp
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	float axis[2], perp[2];
	float s1, s2;
	float a1, a2;
	b2clMat33 K;
	float motorMass;
} b2clPrismaticJointData;

typedef struct b2clGearJointData
{
	int joint1;
	int joint2;
	int typeA;
	int typeB;

	float localAnchorA[2];
	float localAnchorB[2];
	float localAnchorC[2];
	float localAnchorD[2];

	float localAxisC[2];
	float localAxisD[2];

	float referenceAngleA;
	float referenceAngleB;

	float gearConstant;
	float ratio;

	// Solver temp
	float lcA[2], lcB[2], lcC[2], lcD[2];
	float mA, mB, mC, mD;
	float iA, iB, iC, iD;
	float JvAC[2], JvBD[2];
	float JwA, JwB, JwC, JwD;
	float mass;
} b2clGearJointData;

typedef struct b2clPulleyJointData
{
	float groundAnchorA[2];
	float groundAnchorB[2];
	float lengthA;
	float lengthB;
	float localAnchorA[2];
	float localAnchorB[2]; 
	float pulleyConstant; 
	float ratio; 
	float uA[2]; 
	float uB[2]; 
	float rA[2]; 
	float rB[2]; 
	float localCenterA[2];
	float localCenterB[2]; 
	float invMassA; 
	float invMassB; 
	float invIA; 
	float invIB;
	float mass; 
}b2clPulleyJointData; 

typedef struct b2clRopeJointData
{	
	float localAnchorA[2];
	float localAnchorB[2]; 
	float maxLength; 
	float nlength;
	float u[2]; 
	float rA[2]; 
	float rB[2]; 
	float localCenterA[2];
	float localCenterB[2]; 
	float invMassA; 
	float invMassB; 
	float invIA; 
	float invIB;
	float mass; 
	int limitState; 
} b2clRopeJointData; 

typedef struct b2clWheelJointData
{
	float frequencyHz;
	float dampingRatio;

	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float localXAxisA[2];
	float localYAxisA[2];

	float maxMotorTorque;
	float motorSpeed;
	int enableMotor;

	// Solver temp
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;

	float ax[2], ay[2];
	float sAx, sBx;
	float sAy, sBy;

	float mass;
	float motorMass;
	float springMass;

	float bias;
	float gamma;
} b2clWheelJointData;

typedef struct b2clWeldJointData
{
	float frequencyHz;
	float dampingRatio;
	float bias;

	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float referenceAngle;
	float gamma;

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat33 mass;
} b2clWeldJointData;

typedef struct b2clMouseJointData
{
	float localAnchorB[2];
	float targetA[2];
	float frequencyHz;
	float dampingRatio;
	float beta;
	
	// Solver shared
	float maxForce;
	float gamma;

	// Solver temp
	float rB[2];
	float localCenterB[2];
	float invMassB;
	float invIB;
	b2clMat22 mass;
	float C[2];
} b2clMouseJointData;

typedef struct b2clFrictionJointData
{
	float localAnchorA[2];
	float localAnchorB[2];

	float maxForce; 
	float maxTorque; 

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat22 linearMass;
	float angularMass; 
} b2clFrictionJointData;

typedef struct clJoint
{
	int index;

	// impulse : 4 floats
	union a1{
		struct x1{
			float impulse[3];
		}x;
		struct y1{
			float scalarImpulse;
			float springImpulse;
		}y;
		struct z1{
			float linearImpulse[2];
			float angularImpulse;
		}z;
	}a;
	float motorImpulse;

	int color;
	int type;
	int collideConnected;

	int indexA, indexB, indexC, indexD;

	union b1{
		b2clDistanceJointData distanceJointData;
		b2clRevoluteJointData revoluteJointData;
		b2clPrismaticJointData prismaticJointData;
		b2clGearJointData gearJointData;
		b2clPulleyJointData pulleyJointData;
		b2clRopeJointData ropeJointData;
		b2clWheelJointData wheelJointData;
		b2clWeldJointData weldJointData;
		b2clMouseJointData mouseJointData;
		b2clFrictionJointData frictionJointData;
	}b;
} b2clJoint;

typedef struct
{
	int index;
    float nimpulse[4];
} b2clJointImpulseNode;

typedef struct
{
	int isCollide;
	float normal[2];
	float fraction;
	unsigned int shapeIndex;
} b2clRayCastOutput;

typedef struct
{
	float2 m_buffer[2];
	float2 m_vertices[b2cl_maxPolygonVertices];
	int m_count;
	float m_radius;
} b2clDistanceProxy;

typedef struct 
{
	float metric;		///< length or area
	short count;
	unsigned char indexA[3];	///< vertices on shape A
	unsigned char indexB[3];	///< vertices on shape B
} b2clSimplexCache;

/// Input for b2Distance.
/// You have to option to use the shape radii
/// in the computation. Even 
typedef struct 
{
	b2clDistanceProxy proxyA;
	b2clDistanceProxy proxyB;
	b2clTransform transformA;
	b2clTransform transformB;
	bool useRadii;
} b2clDistanceInput;

/// Output for b2Distance.
typedef struct
{
	float2 pointA;		///< closest point on shapeA
	float2 pointB;		///< closest point on shapeB
	float ndistance;
	int iterations;	///< number of GJK iterations used
} b2clDistanceOutput;

typedef struct
{
	b2clDistanceProxy proxyA;
	b2clDistanceProxy proxyB;
	b2clSweep sweepA;
	b2clSweep sweepB;
	float tMax;		// defines sweep interval [0, tMax]
	float dummy;
} b2clTOIInput;

enum b2clTOIOutputState
{
	e_unknown,
	e_failed,
	e_overlapped,
	e_touching,
	e_separated
};

typedef struct
{
	int state;
	float t;
} b2clTOIOutput;

typedef struct
{
	float2 wA;		// support point in proxyA
	float2 wB;		// support point in proxyB
	float2 w;		// wB - wA
	float a;		// barycentric coordinate for closest point
	int indexA;	// wA index
	int indexB;	// wB index
} b2clSimplexVertex;

typedef struct 
{
	b2clSimplexVertex m_v1, m_v2, m_v3;
	int m_count;
} b2clSimplex;

//typedef struct{
//float v[30];
//} testData; 

//==============================================================================================
// Math functions
//==============================================================================================

/// Multiply two rotations: q * r
inline float2 b2clMul_TwoRotation(const float2 q, const float2 r)
{
	// [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
	// [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]
	// s = qs * rc + qc * rs
	// c = qc * rc - qs * rs
	float2 qr;
	qr.x = q.x * r.y + q.y * r.x;
	qr.y = q.y * r.y - q.x * r.x;
	return qr;
}

/// Transpose multiply two rotations: qT * r
inline float2 b2clMulT_TwoRotation(const float2 q, const float2 r)
{
	// [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
	// [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]
	// s = qc * rs - qs * rc
	// c = qc * rc + qs * rs
	float2 qr;
	qr.x = q.y * r.x - q.x * r.y;
	qr.y = q.y * r.y + q.x * r.x;
	return qr;
}

/// Rotate a vector
inline float2 b2clMul_Rotate(const float2 q, const float2 v)
{
	float2 result;
	result.x = q.y * v.x - q.x * v.y;
	result.y = q.x * v.x + q.y * v.y;

	return result;
}

/// Inverse rotate a vector
inline float2 b2clMulT_Rotate(const float2 q, const float2 v)
{
	float2 result;
	result.x = q.y * v.x + q.x * v.y;
	result.y = -q.x * v.x + q.y * v.y;

	return result;
}

/// Transform a vector
inline float2 b2clMul_Transform(const b2clTransform *T, const float2 v)
{
	float2 result;
	result.x = (T->q.y * v.x - T->q.x * v.y) + T->p.x;
	result.y = (T->q.x * v.x + T->q.y * v.y) + T->p.y;

	return result;
}

/// Invert transform a vector
inline float2 b2clMulT_Transform(const b2clTransform *T, const float2 v)
{
	float px = v.x - T->p.x;
	float py = v.y - T->p.y;
	float2 result;
	result.x = (T->q.y * px + T->q.x * py);
	result.y = (-T->q.x * px + T->q.y * py);

	return result;
}

// v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
//    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
inline b2clTransform b2clMul_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
	b2clTransform C;
	C.q = b2clMul_TwoRotation(A->q, B->q);
	C.p = b2clMul_TwoRotation(A->q, B->p) + A->p;
	return C;
}

// v2 = A.q' * (B.q * v1 + B.p - A.p)
//    = A.q' * B.q * v1 + A.q' * (B.p - A.p)
inline b2clTransform b2clMulT_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
	b2clTransform C;
	C.q = b2clMulT_TwoRotation(A->q, B->q);
	C.p = b2clMulT_TwoRotation(A->q, B->p - A->p);
	return C;
}

/// Perform the dot product on two vectors.
inline float b2clDot(const float2 a, const float2 b)
{
	return a.x * b.x + a.y * b.y;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float b2clCross_VV(const float2 a, const float2 b)
{
	return a.x * b.y - a.y * b.x;
}

/// Perform the cross product on a vector and a scalar. In 2D this produces
/// a vector.
inline float2 b2clCross_VS(const float2 a, float s)
{
	return (float2)(s * a.y, -s *a.x);
}

/// Perform the cross product on a scalar and a vector. In 2D this produces
/// a vector.
inline float2 b2clCross_SV(float s, const float2 a)
{
	return (float2)(-s * a.y, s * a.x);
}

inline float b2clClamp(float a, float low, float high)
{
	return max(low, min(a, high));
}

inline float2 b2clMin(const float2 a, const float2 b)
{
	return (float2)(min(a.x, b.x), min(a.y, b.y));
}

inline float2 b2clMax(const float2 a, const float2 b)
{
	return (float2)(max(a.x, b.x), max(a.y, b.y));
}

inline float b2clDistanceSquared(const float2 a, const float2 b)
{
	float2 c = a - b;
	return b2clDot(c, c);
}

inline float b2clDistance(const float2 a, const float2 b)
{
	float2 c = a - b;
	return sqrt(b2clDot(c, c));
}

inline float b2clLengthSquared(const float2 v)
{
	return b2clDot(v, v);
}

inline float b2clAbs(float a)
{
	return a > 0.0f ? a : -a;
}

/// Perform the dot product on two vectors.
inline float b2clDot3(const float3 a, const float3 b)
{
	return a.x * b.x + a.y * b.y + a.z * b.z;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float3 b2clCross3_VV(const float3 a, const float3 b)
{
	return (float3)(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float3 b2clMat33Solve(const b2clMat33 mat, const float3 b)
{
	float3 ex = (float3)(mat.ex[0], mat.ex[1], mat.ex[2]);
	float3 ey = (float3)(mat.ey[0], mat.ey[1], mat.ey[2]);
	float3 ez = (float3)(mat.ez[0], mat.ez[1], mat.ez[2]);

	float det = b2clDot3(ex, b2clCross3_VV(ey, ez));

	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float3 x;
	x.x = det * b2clDot3(b, b2clCross3_VV(ey, ez));
	x.y = det * b2clDot3(ex, b2clCross3_VV(b, ez));
	x.z = det * b2clDot3(ex, b2clCross3_VV(ey, b));
	return x;
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float2 b2clMat33Solve22(const b2clMat33 mat, const float2 b)
{
	float2 ex = (float2)(mat.ex[0], mat.ex[1]);
	float2 ey = (float2)(mat.ey[0], mat.ey[1]);

	float det = ex.x * ey.y - ey.x * ex.y;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float2 x;
	x.x = det * (ey.y * b.x - ey.x * b.y);
	x.y = det * (ex.x * b.y - ex.y * b.x);
	return x;
}

inline float2 b2clMat22Solve(const b2clMat22 mat, const float2 b)
{
	float2 ex = (float2)(mat.ex[0], mat.ex[1]);
	float2 ey = (float2)(mat.ey[0], mat.ey[1]);

	float det = ex.x * ey.y - ey.x * ex.y;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float2 x;
	x.x = det * (ey.y * b.x - ey.x * b.y);
	x.y = det * (ex.x * b.y - ex.y * b.x);
	return x;
}

inline float2 b2clMat33Mul22(const b2clMat33 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float2 b2clMat22Mul(const b2clMat22 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline void b2clGetInverse22(const b2clMat33 in, b2clMat33* out)
{
	float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
	float det = a * d - b * c;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}

	out->ex[0] =  det * d;	out->ey[0] = -det * b; out->ex[2] = 0.0f;
	out->ex[1] = -det * c;	out->ey[1] =  det * a; out->ey[2] = 0.0f;
	out->ez[0] = 0.0f; out->ez[1] = 0.0f; out->ez[2] = 0.0f;
}

inline void b2clGetSymInverse33(const b2clMat33 in, b2clMat33* out)
{
	//float det = b2clDot(ex, b2clCross(ey, ez));
	float det = in.ex[0] * (in.ey[1] * in.ez[2] - in.ey[2] * in.ez[1]) 
		+ in.ex[1] * (in.ey[2] * in.ez[0] - in.ey[0] * in.ez[2]) 
		+ in.ex[2] * (in.ey[0] * in.ez[1] - in.ey[1] * in.ez[0]);

	if (det != 0.0f)
	{
		det = 1.0f / det;
	}

	float a11 = in.ex[0], a12 = in.ey[0], a13 = in.ez[0];
	float a22 = in.ey[1], a23 = in.ez[1];
	float a33 = in.ez[2];

	out->ex[0] = det * (a22 * a33 - a23 * a23);
	out->ex[1] = det * (a13 * a23 - a12 * a33);
	out->ex[2] = det * (a12 * a23 - a13 * a22);

	out->ey[0] = out->ex[1];
	out->ey[1] = det * (a11 * a33 - a13 * a13);
	out->ey[2] = det * (a13 * a12 - a11 * a23);

	out->ez[0] = out->ex[2];
	out->ez[1] = out->ey[2];
	out->ez[2] = det * (a11 * a22 - a12 * a12);
}

inline float2 b2clMat33MulV2(const b2clMat33 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float3 b2clMat33MulV3(const b2clMat33 A, const float3 v)
{
	//return v.x * A.ex + v.y * A.ey + v.z * A.ez;
	return (float3)(A.ex[0] * v.x + A.ey[0] * v.y + A.ez[0] * v.z,
		A.ex[1] * v.x + A.ey[1] * v.y + A.ez[1] * v.z,
		A.ex[2] * v.x + A.ey[2] * v.y + A.ez[2] * v.z);
}

inline void b2clMat22GetInverse(const b2clMat22 in, b2clMat22* out)
{
	float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
	float det = a * d - b * c;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	out->ex[0] =  det * d;	out->ey[0] = -det * b;
	out->ex[1] = -det * c;	out->ey[1] =  det * a;
}

inline void b2clSweepNormalize(b2clSweep* sweep)
{
	float twoPi = 2.0f * b2_pi;
	float d =  twoPi * floor(sweep->a0 / twoPi);
	sweep->a0 -= d;
	sweep->a -= d;
}

inline void b2clSweepGetTransform(b2clSweep* sweep, b2clTransform* xf, float beta)
{
	xf->p = (1.0f - beta) * sweep->c0 + beta * sweep->c;
	float angle = (1.0f - beta) * sweep->a0 + beta * sweep->a;
	xf->q.x = sin(angle);
	xf->q.y = cos(angle);

	// Shift to origin
	xf->p -= b2clMul_Rotate(xf->q, sweep->localCenter);
}

inline void b2clSweepAdvance(b2clSweep* sweep, float alpha)
{
	float beta = (alpha - sweep->alpha0) / (1.0f - sweep->alpha0);
	sweep->c0 = (1.0f - beta) * sweep->c0 + beta * sweep->c;
	sweep->a0 = (1.0f - beta) * sweep->a0 + beta * sweep->a;
	sweep->alpha0 = alpha;
}
inline void b2clBodySweepAdvance (b2clBodyDynamic* body, b2clTransform* xf, float alpha) {
	b2clSweepAdvance(&(body->m_sweep), alpha); 
	body->m_sweep.c = body->m_sweep.c0;
	body->m_sweep.a = body->m_sweep.a0;
    xf->q.x = sin (body->m_sweep.a);
	xf->q.y = cos (body->m_sweep.a); 
	xf->p = body->m_sweep.c - b2clMul_Rotate(xf->q, body->m_sweep.localCenter);
}

inline void b2clDistanceProxySet(b2clDistanceProxy* proxy, const b2clPolygonShape* shape)
{
	proxy->m_count = shape->m_vertexCount;
	proxy->m_radius = shape->m_radius;
	for (int i = 0; i < shape->m_vertexCount; ++i)
	{
		proxy->m_vertices[i] = shape->m_vertices[i];
	}
}

inline int b2clDistanceProxyGetSupport(const b2clDistanceProxy* proxy, float2 d)
{
	int bestIndex = 0;
	float bestValue = b2clDot(proxy->m_vertices[0], d);
	for (int i = 1; i < proxy->m_count; ++i)
	{
		float value = b2clDot(proxy->m_vertices[i], d);
		if (value > bestValue)
		{
			bestIndex = i;
			bestValue = value;
		}
	}
	return bestIndex;
}

inline float2 b2clDistanceProxyGetVertex(const b2clDistanceProxy* proxy, int index)
{
	return proxy->m_vertices[index];
}

// Convert a vector into a unit vector. Returns the length.
inline float b2clNormalize(float2* v)
{
	float length = sqrt(b2clDot(*v, *v));
	if (length < b2_epsilon)
	{
		return 0.0f;
	}
	float invLength = 1.0f / length;
	(*v).x *= invLength;
	(*v).y *= invLength;

	return length;
}

/*
inline float cos_wrapper(float a)
{
	//float sina = sin(a);
	//return sqrt(1-sina*sina);

	//return sin(1.5707963268-a);

	return cos(a);
}
*/

//#include <Box2D/Common/OpenCL/b2CLTypeDefOCL.h>

typedef struct 
{
	float m_min[2];
	float m_max[2];
	uchar m_sType;
	uchar m_bType;
	//uchar mask[2];
} b2clAABB;

//http://stereopsis.com/radix.html

uint FloatFlip(float fl)
{
	uint f = as_uint(fl);
	uint mask = -(int)(f >> 31) | 0x80000000;
	return f ^ mask;
}

float IFloatFlip(uint f)
{
	uint mask = ((f >> 31) - 1) | 0x80000000;
	uint fl = f ^ mask;
	return as_float(fl);
}

bool TestAabbAgainstAabb2(const b2clAABB* aabb1, __local const b2clAABB* aabb2)
{
	bool overlap = true;
	overlap = (aabb1->m_min[0] > aabb2->m_max[0] || aabb1->m_max[0] < aabb2->m_min[0]) ? false : overlap;
	overlap = (aabb1->m_min[1] > aabb2->m_max[1] || aabb1->m_max[1] < aabb2->m_min[1]) ? false : overlap;
	return overlap;
}

//bool TestAabbAgainstAabb2GlobalGlobal(__global const b2clAABB* aabb1, __global const b2clAABB* aabb2)
bool TestAabbAgainstAabb2GlobalGlobal(const b2clAABB* aabb1, __global const b2clAABB* aabb2)
{
	bool overlap = true;
	//if ((aabb1->mask[0] ^ aabb2->mask[0]) && (aabb1->mask[0] ^ aabb2->mask[1]) &&
	//	(aabb1->mask[1] ^ aabb2->mask[0]) && (aabb1->mask[1] ^ aabb2->mask[1]))
	//	return false;
	overlap = (aabb1->m_min[0] > aabb2->m_max[0] || aabb1->m_max[0] < aabb2->m_min[0]) ? false : overlap;
	overlap = (aabb1->m_min[1] > aabb2->m_max[1] || aabb1->m_max[1] < aabb2->m_min[1]) ? false : overlap;
	return overlap;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// ShouldCollideJoints
//
// Determines whether bodies A and B should collide or not.
// If A and B are connected by a joint which does not allow collisions between connected bodies,
// this function returns false.
////////////////////////////////////////////////////////////////////////////////////////////////////
bool ShouldCollideJoints(int bodyA, int bodyB, const __global int* connectedBodyIndicesA, const __global int* connectedBodyIndicesB)
{
	int bodyIndex;
	const __global int* connectedBodyIndices;
	if (bodyA < bodyB)
	{
		bodyIndex = bodyB;
		connectedBodyIndices = connectedBodyIndicesA;
	}
	else
	{
		bodyIndex = bodyA;
		connectedBodyIndices = connectedBodyIndicesB;
	}

	for (int i = 0; i < MAX_CONNECTED_BODY_INDICES; ++i)
	{
		if (connectedBodyIndices[i] == bodyIndex)
			return false;
		if (connectedBodyIndices[i] == -1)
			return true;
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// ShouldCollide
//
// Determines whether bodies A and B should collide or not from their category bits, mask bits, and group indices.
// It follows the collision filtering rule in the Box2D manual 6.2.
////////////////////////////////////////////////////////////////////////////////////////////////////
bool ShouldCollide(ushort categoryBitsA, ushort maskBitsA, short groupIndexA, 
				   ushort categoryBitsB, ushort maskBitsB, short groupIndexB)
{
	if (groupIndexA == groupIndexB && groupIndexA != 0)
	{
		return groupIndexA > 0;
	}

	bool collide = (maskBitsA & categoryBitsB) != 0 && (categoryBitsA & maskBitsB) != 0;
	return collide;
}

__kernel void ComputeAABBs(
		const __global b2clPolygonShape* polyGlobal,
		const __global b2clBodyStatic* bodyStaticListBuffer,
		const __global b2clTransform* xfGlobal,
		__global b2clAABB* AABBs, // output
		const __global int* shapeToBodyMap,
		int numShapes)
{
	int i = get_global_id(0);

	if (i>=numShapes)
		return;

	b2clPolygonShape poly = polyGlobal[i];
	int j = shapeToBodyMap[i];
	b2clTransform xf = xfGlobal[j];
	b2clBodyStatic bs = bodyStaticListBuffer[j];

	const float2* vertices = poly.m_vertices;

	float2 lower = b2clMul_Transform(&xf, vertices[0]);
	float2 upper = lower;

	if (poly.m_type>0) // edge (m_type==1) or polygon (m_type==2)
	{
		float2 v = b2clMul_Transform(&xf, vertices[1]);
		lower = b2clMin(lower, v);
		upper = b2clMax(upper, v);
	}

	// In Box2D 2.1.2, polygon is m_type==1
	if (poly.m_type==2) // polygon (m_type==2)
	{
		for (int k = 2; k < poly.m_vertexCount; ++k)
		{
			float2 v = b2clMul_Transform(&xf, vertices[k]);
			lower = b2clMin(lower, v);
			upper = b2clMax(upper, v);
		}
	}

	float r = poly.m_radius;

	AABBs[i].m_min[0] = lower.x - r;
	AABBs[i].m_min[1] = lower.y - r;
	AABBs[i].m_max[0] = upper.x + r;
	AABBs[i].m_max[1] = upper.y + r;
	
	AABBs[i].m_sType = poly.m_type;
	AABBs[i].m_bType = bs.m_type;
}

__kernel void ComputeAABBsTOI(
		const __global b2clPolygonShape* polyGlobal,
		const __global b2clBodyStatic* bodyStaticListBuffer,
	    const __global b2clBodyDynamic* bodyDynamicListBuffer,
		const __global b2clTransform* xfGlobal,
		__global b2clAABB* AABBs, // output
		const __global int* shapeToBodyMap,
		int numShapes)
{
	int i = get_global_id(0);

	if (i>=numShapes)
		return;

	b2clPolygonShape poly = polyGlobal[i];
	int j = shapeToBodyMap[i];
	b2clTransform xf = xfGlobal[j];
	b2clBodyStatic bs = bodyStaticListBuffer[j];
	b2clBodyDynamic bd = bodyDynamicListBuffer[j];

	const float2* vertices = poly.m_vertices;

	float2 lower = b2clMul_Transform(&xf, vertices[0]);
	float2 upper = lower;

	if (poly.m_type>0) // edge (m_type==1) or polygon (m_type==2)
	{
		float2 v = b2clMul_Transform(&xf, vertices[1]);
		lower = b2clMin(lower, v);
		upper = b2clMax(upper, v);
	}

	// In Box2D 2.1.2, polygon is m_type==1
	if (poly.m_type==2) // polygon (m_type==2)
	{
		for (int k = 2; k < poly.m_vertexCount; ++k)
		{
			float2 v = b2clMul_Transform(&xf, vertices[k]);
			lower = b2clMin(lower, v);
			upper = b2clMax(upper, v);
		}
	}

	float r = poly.m_radius;

	// synchronize xf for each body
	float a0, a;
	float2 c0, c;
	float2 p0, q0, p, q, d;

	a0 = bd.m_sweep.a0;
	a = bd.m_sweep.a;
	c0 = bd.m_sweep.c0;
	c = bd.m_sweep.c;

	float sina, cosa;
	
	sina = sincos(a0, &cosa);
	q0.x = sina;
	q0.y = cosa;
	//q0.x = /*native_*/sin(a0);
	//q0.y = /*native_*/cos(a0);
	//q0.y = cos_wrapper(a0);
	p0 = c0 - b2clMul_Rotate(q0, bs.m_localCenter);

	sina = sincos(a, &cosa);
	q.x = sina;
	q.y = cosa;
	//q.x = /*native_*/sin(a);
	//q.y = /*native_*/cos(a);
	//q.y = cos_wrapper(a);
	p = c - b2clMul_Rotate(q, bs.m_localCenter);

	d = (p - p0) * b2cl_aabbMultiplier;

	//if (!(d.x<0.0f) && !(d.x>=0.0f))
	//{
	//	printf("%d, %f\n", i, d.x);
	//	printf("a0: %f, c0: (%f, %f), a: %f, c: (%f, %f)\n", a0, c0.x, c0.y, a, c.x, c.y);
	//}
	
	// Extend AABB with d
	if (d.x < 0.0f)
	{
		lower.x += d.x;
	}
	else
	{
		upper.x += d.x;
	}

	if (d.y < 0.0f)
	{
		lower.y += d.y;
	}
	else
	{
		upper.y += d.y;
	}

	AABBs[i].m_min[0] = lower.x - r;
	AABBs[i].m_min[1] = lower.y - r;
	AABBs[i].m_max[0] = upper.x + r;
	AABBs[i].m_max[1] = upper.y + r;

	//if (i==0)
	//{
	//	printf("AABB %d: (%f, %f)-(%f, %f)\n", i, lower.x, lower.y, upper.x, upper.y);
	//	printf("d %d: (%f, %f)\n", i, d.x, d.y);
	//}

	AABBs[i].m_sType = poly.m_type;
	AABBs[i].m_bType = bs.m_type;
}

__kernel void PrepareSumVariance( __global const b2clAABB* AABBs, 
			__global float4* sum, 
			//__global float4* sum2, 
			int numAabbs)
{
	int i = get_global_id(0);
	if (i>numAabbs)
		return;
	float2 s, s2;
	s.x = (AABBs[i].m_max[0]+AABBs[i].m_min[0])*0.5f;
	s.y = (AABBs[i].m_max[1]+AABBs[i].m_min[1])*0.5f;
	s2 = s*s;
	sum[i] = (float4)(s, s2);
	//sum2[i] = s*s;	
}

__kernel void PrepareSumVarianceNoFloat4( __global const b2clAABB* AABBs, 
			__global float* sumX, 
			__global float* sumY, 
			__global float* sumX2, 
			__global float* sumY2, 
			int numAabbs)
{
	int i = get_global_id(0);
	if (i>numAabbs)
		return;
	float2 s, s2;
	s.x = (AABBs[i].m_max[0]+AABBs[i].m_min[0])*0.5f;
	s.y = (AABBs[i].m_max[1]+AABBs[i].m_min[1])*0.5f;
	s2 = s*s;
	sumX[i] = s.x;
	sumY[i] = s.y;
	sumX2[i] = s2.x;
	sumY2[i] = s2.y;
}

__kernel void InitSortingKeys(__global const b2clAABB* AABBs, 
		__global uint* keysAABB, // output
		__global uint* indicesAABB, // output
		int numAabbs,
		int axis, 
		int sortCount)
{
	int i = get_global_id(0);
	if (i>=numAabbs)
	{
		if (i<sortCount)
			keysAABB[i] = 0;
		return;
	}

	keysAABB[i] = FloatFlip(AABBs[i].m_max[axis]); // use max_x/y for sorting (descending), convert it to int
	indicesAABB[i] = i;
}

__kernel void ComputePairs( 
		const __global b2clAABB* aabbs, 
//		__global b2clAABB* test, 
		const __global b2clBodyStatic* bodyStaticListBuffer, // only need body type here, should extract it later
		const __global b2clPolygonShape* shapeListBuffer,
		__global int4* globalIndices, // output
		volatile __global int* pairIndices, // output
		const __global uint* indicesAABB,
		const __global int* shapeToBodyMap,
		volatile __global int* pairCounts, // output
		volatile __global int* pairTotalCount, // output
		int numObjects, 
		int axis, 
		int maxPairs)
{
	int i = get_global_id(0);

	if (i>=numObjects)
		return;

	int shape_i, shape_j, body_i, body_j, type_i, type_j;
	b2clAABB aabb_i, aabb_j;
	shape_i = indicesAABB[i];
	body_i = shapeToBodyMap[shape_i];
	aabb_i = aabbs[shape_i];
	type_i = aabbs[shape_i].m_bType;

	//if (i==0)
	//{
	//	printf("aabb[0]: (%f, %f)-(%f, %f)\n", aabbs[0].m_min[0], aabbs[0].m_min[1], aabbs[0].m_max[0], aabbs[0].m_max[1]);
	//}

//	int localPairCount = 0;
//	
//#define max_pair_per_shape 10
//	int4 localPairIndicesBuffer[max_pair_per_shape]; // assume there will be less than max_pair_per_shape pair for each shape

	unsigned short categoryBitsA = shapeListBuffer[shape_i].m_filter.categoryBits;
	unsigned short maskBitsA = shapeListBuffer[shape_i].m_filter.maskBits;
	short groupIndexA = shapeListBuffer[shape_i].m_filter.groupIndex;

	for (int j=i+1; j<numObjects; j++)
	{
		shape_j = indicesAABB[j];
		//aabb_j = aabbs[shape_j];
		if(aabb_i.m_min[axis] > (aabbs[shape_j].m_max[axis])) 
		{
			break;
		}

		body_j = shapeToBodyMap[shape_j];
		type_j = aabbs[shape_j].m_bType;

		if (body_i==body_j)
			continue;

		bool bIsIntersection = TestAabbAgainstAabb2GlobalGlobal(&aabb_i, &aabbs[shape_j]) && (type_i==2 || type_j==2);

		// check joint collide connected
		bIsIntersection &= ShouldCollideJoints(body_i, body_j, bodyStaticListBuffer[body_i].m_connectedBodyIndices, bodyStaticListBuffer[body_j].m_connectedBodyIndices);

		// check user filtering
		unsigned short categoryBitsB = shapeListBuffer[shape_j].m_filter.categoryBits;
		unsigned short maskBitsB = shapeListBuffer[shape_j].m_filter.maskBits;
		short groupIndexB = shapeListBuffer[shape_j].m_filter.groupIndex;
		bIsIntersection &= ShouldCollide(categoryBitsA, maskBitsA, groupIndexA, categoryBitsB, maskBitsB, groupIndexB);

        int4 currentPairIndices;
        int c_type;
        int curPair, curTotalPair;
		if (bIsIntersection)
		{
			//printf("i: %d, shape_i: %d, shape_j: %d\n", i, shape_i, shape_j);
			//printf("\tAABB[%d]: (%f, %f)-(%f, %f)\n", shape_i, aabbs[shape_i].m_min[0], aabbs[shape_i].m_min[1], aabbs[shape_i].m_max[0], aabbs[shape_i].m_max[1]);
			//printf("\tAABB[%d]: (%f, %f)-(%f, %f)\n", shape_j, aabbs[shape_j].m_min[0], aabbs[shape_j].m_min[1], aabbs[shape_j].m_max[0], aabbs[shape_j].m_max[1]);

			currentPairIndices.x = shape_i;
			currentPairIndices.y = shape_j;
			currentPairIndices.z = body_i;
			currentPairIndices.w = body_j;

			int s_type_i = aabb_i.m_sType;
			int s_type_j = aabbs[shape_j].m_sType;

			// Set c_type according to s_type_i and s_type_j
			// Suppose only have circle (0), edge (1), and polygon (2) at this time
			// 0: circle-circle
			// 1: circle-polygon (A is polygon and B is circle)
			// 2: polygon-polygon
			// 3: edge-circle (A is edge and B is circle)
			// 4: edge-polygon (A is edge and B is polygon)
			// note that edge-edge is NOT supported in Box2D
			if (s_type_i==0) // A is circle
			{
				if (s_type_j==0) // B is circle
				{
					c_type = 0;
				}
				else if (s_type_j==1) // B is edge
				{
					c_type = 3;
					// swap the two shpaes to make sure A is edge and B is circle
					currentPairIndices.x = shape_j;
					currentPairIndices.y = shape_i;
					currentPairIndices.z = body_j;
					currentPairIndices.w = body_i;
				}
				else // B is polygon
				{
					c_type = 1;
					// swap the two shpaes to make sure A is polygon and B is circle
					currentPairIndices.x = shape_j;
					currentPairIndices.y = shape_i;
					currentPairIndices.z = body_j;
					currentPairIndices.w = body_i;
				}
			}
			else if (s_type_i==1) // A is edge
			{
				if (s_type_j==0) // B is circle
				{
					c_type = 3;
				}
				else if (s_type_j==1) // B is edge
				{
					// This should never happen
				}
				else // B is polygon
				{
					c_type = 4;
				}
			}
			else // A is polygon
			{
				if (s_type_j==0) // B is circle
				{
					c_type = 1;
				}
				else if (s_type_j==1) // B is edge
				{
					c_type = 4;
					// swap the two shpaes to make sure A is edge and B is polygon
					currentPairIndices.x = shape_j;
					currentPairIndices.y = shape_i;
					currentPairIndices.z = body_j;
					currentPairIndices.w = body_i;
				}
				else // B is polygon
				{
					c_type = 2;
				}
			}

			// the following two atomic_inc may have some problem?
			// check it later!!!
			curPair = atomic_inc(pairCounts+c_type);
			curTotalPair = atomic_inc(pairTotalCount);
			if (curTotalPair<maxPairs)
			{
				globalIndices[curTotalPair] = currentPairIndices; //flush to main memory
				pairIndices[maxPairs*c_type+curPair] = curTotalPair; //flush to main memory
			}
			//printf("pairCount: %d, shape_i: %d, shape_j: %d, body_i: %d, body_j: %d\n", curPair, shape_i, shape_j, body_i, body_j);
		}
	}
	//int curPair = atomic_add(pairCount, localPairCount);
	//if (curPair+localPairCount<maxPairs)
	//{
	//	for (int k=0; k<localPairCount; k++)
	//	{
	//		pairIndices[curPair+k] = localPairIndicesBuffer[k]; //flush to main memory
	//	}
	//}
}

__kernel void ComputePairsNoAtomic( 
		const __global b2clAABB* aabbs, 
		const __global b2clBodyStatic* bodyStaticListBuffer, // only need body type here, should extract it later
		const __global b2clPolygonShape* shapeListBuffer,
		__global int4* globalIndices, // output
		__global int* pairIndices, // output
		__global int* pairIndicesBinaryBits, // output
		const __global uint* indicesAABB,
		const __global int* shapeToBodyMap,
		int numObjects, 
		int axis, 
		int maxPairsPerFixture,
		int maxPairs)
{
	int i = get_global_id(0);

	if (i>=numObjects)
		return;

	int base_address = i*maxPairsPerFixture;

	int shape_i, shape_j, body_i, body_j, type_i, type_j;
	shape_i = indicesAABB[i];
	body_i = shapeToBodyMap[shape_i];
	type_i = aabbs[shape_i].m_bType;

//	int localPairCount = 0;
//	
//#define max_pair_per_shape 10
//	int4 localPairIndicesBuffer[max_pair_per_shape]; // assume there will be less than max_pair_per_shape pair for each shape

	unsigned short categoryBitsA = shapeListBuffer[shape_i].m_filter.categoryBits;
	unsigned short maskBitsA = shapeListBuffer[shape_i].m_filter.maskBits;
	short groupIndexA = shapeListBuffer[shape_i].m_filter.groupIndex;

	int num_pairs = 0;
	// currently only support 5 types of contacts
	int type_counts[5];
	for (int k=0; k<5; k++)
		type_counts[k] = 0;

	for (int j=i+1; j<numObjects; j++)
	{
		shape_j = indicesAABB[j];
		if(aabbs[shape_i].m_min[axis] > (aabbs[shape_j].m_max[axis])) 
		{
			break;
		}

		body_j = shapeToBodyMap[shape_j];
		type_j = aabbs[shape_j].m_bType;

		if (body_i==body_j)
			continue;

		bool bIsIntersection = 1;//TestAabbAgainstAabb2GlobalGlobal(&aabbs[shape_i], &aabbs[shape_j]) && (type_i==2 || type_j==2);

		// check joint collide connected
		bIsIntersection &= ShouldCollideJoints(body_i, body_j, bodyStaticListBuffer[body_i].m_connectedBodyIndices, bodyStaticListBuffer[body_j].m_connectedBodyIndices);

		// check user filtering
		unsigned short categoryBitsB = shapeListBuffer[shape_j].m_filter.categoryBits;
		unsigned short maskBitsB = shapeListBuffer[shape_j].m_filter.maskBits;
		short groupIndexB = shapeListBuffer[shape_j].m_filter.groupIndex;
		bIsIntersection &= ShouldCollide(categoryBitsA, maskBitsA, groupIndexA, categoryBitsB, maskBitsB, groupIndexB);

        int4 currentPairIndices;
        int c_type;
		if (bIsIntersection)
		{
			currentPairIndices.x = shape_i;
			currentPairIndices.y = shape_j;
			currentPairIndices.z = body_i;
			currentPairIndices.w = body_j;

			int s_type_i = aabbs[shape_i].m_sType;
			int s_type_j = aabbs[shape_j].m_sType;

			// Set c_type according to s_type_i and s_type_j
			// Suppose only have circle (0), edge (1), and polygon (2) at this time
			// 0: circle-circle
			// 1: circle-polygon (A is polygon and B is circle)
			// 2: polygon-polygon
			// 3: edge-circle (A is edge and B is circle)
			// 4: edge-polygon (A is edge and B is polygon)
			// note that edge-edge is NOT supported in Box2D
			if (s_type_i==0) // A is circle
			{
				if (s_type_j==0) // B is circle
				{
					c_type = 0;
				}
				else if (s_type_j==1) // B is edge
				{
					c_type = 3;
					// swap the two shpaes to make sure A is edge and B is circle
					currentPairIndices.x = shape_j;
					currentPairIndices.y = shape_i;
					currentPairIndices.z = body_j;
					currentPairIndices.w = body_i;
				}
				else // B is polygon
				{
					c_type = 1;
					// swap the two shpaes to make sure A is polygon and B is circle
					currentPairIndices.x = shape_j;
					currentPairIndices.y = shape_i;
					currentPairIndices.z = body_j;
					currentPairIndices.w = body_i;
				}
			}
			else if (s_type_i==1) // A is edge
			{
				if (s_type_j==0) // B is circle
				{
					c_type = 3;
				}
				else if (s_type_j==1) // B is edge
				{
					// This should never happen
				}
				else // B is polygon
				{
					c_type = 4;
				}
			}
			else // A is polygon
			{
				if (s_type_j==0) // B is circle
				{
					c_type = 1;
				}
				else if (s_type_j==1) // B is edge
				{
					c_type = 4;
					// swap the two shpaes to make sure A is edge and B is polygon
					currentPairIndices.x = shape_j;
					currentPairIndices.y = shape_i;
					currentPairIndices.z = body_j;
					currentPairIndices.w = body_i;
				}
				else // B is polygon
				{
					c_type = 2;
				}
			}

			if (num_pairs<maxPairs)
			{
				globalIndices[base_address + num_pairs] = currentPairIndices;
				pairIndices[maxPairs*c_type + base_address + type_counts[c_type]] = base_address + num_pairs;
				pairIndicesBinaryBits[maxPairs*c_type + base_address + type_counts[c_type]] = 1;
				num_pairs++;
				type_counts[c_type]++;
			}
		}
	}
}

#define WORKGROUP_SIZE 256
//#define WORKGROUP_SIZE 1024

__kernel void computePairsLocalMemory( 
		__global const b2clAABB* aabbs, 
		const __global b2clBodyStatic* bodyStaticListBuffer, // only need body type here, should extract it later
		const __global b2clPolygonShape* shapeListBuffer,
		__global int4* globalIndices, // output
		__global int4* pairIndices, // output
		const __global uint* indicesAABB,
		const __global int* shapeToBodyMap,
		volatile __global int* pairCount, // output
		volatile __global int* pairTotalCount, // output
		int numObjects, 
		int axis, 
		int maxPairs)
{
	int i = get_global_id(0);

	//if (i>=numObjects)
	//	return;

	int localId = get_local_id(0);

	__local int numActiveWgItems[1];
	__local int breakRequest[1];
	__local int localShapeI[WORKGROUP_SIZE*2]; // = indicesAABB[i];
	__local b2clAABB localAabbs[WORKGROUP_SIZE*2]; // = aabbs[shape_i];
	__local int localBodyI[WORKGROUP_SIZE*2]; // = shapeToBodyMap[shape_i];
	__local int localBodyType[WORKGROUP_SIZE*2]; // = bodyStaticListBuffer[shapeToBodyMap[shape_i]].m_type;

	if (localId==0)
	{
		numActiveWgItems[0] = 0;
		breakRequest[0] = 0;
	}
	int localCount=0;
	int block=0;

	int shape_0, shape_i, body_i, shape_i2, body_i2;
	b2clAABB myAabb;
	int myShapeI, myBodyI, myType;

	// load shape_i
	shape_0 = indicesAABB[0];
	shape_i = i<numObjects ? indicesAABB[i] : shape_0;
	myShapeI = shape_i;
	localShapeI[localId] = myShapeI;
	shape_i2 = (i+WORKGROUP_SIZE)<numObjects ? indicesAABB[i+WORKGROUP_SIZE]: shape_0;
	localShapeI[localId+WORKGROUP_SIZE] = shape_i2;

	// load AABB
	myAabb = aabbs[shape_i];
	float testValue = 	myAabb.m_max[axis];
	localAabbs[localId] = myAabb;
	localAabbs[localId+WORKGROUP_SIZE] = aabbs[shape_i2];

	// load body_i
	body_i = shapeToBodyMap[shape_i];
	myBodyI = body_i;
	localBodyI[localId] = myBodyI;
	body_i2 = shapeToBodyMap[shape_i2];
	localBodyI[localId+WORKGROUP_SIZE] = body_i2;

	// load type_i
	myType = bodyStaticListBuffer[body_i].m_type;
	localBodyType[localId] = myType;
	localBodyType[localId+WORKGROUP_SIZE] = bodyStaticListBuffer[body_i2].m_type;

	barrier(CLK_LOCAL_MEM_FENCE);
	atomic_inc(numActiveWgItems);
	barrier(CLK_LOCAL_MEM_FENCE);
	int localBreak = 0;
	
	int j=i+1;
	do
	{
		barrier(CLK_LOCAL_MEM_FENCE);
	
		if (j<numObjects)
		{
	  		if(testValue < (localAabbs[localCount+localId+1].m_min[axis])) 
			{
				if (!localBreak)
				{
					atomic_inc(breakRequest);
					localBreak = 1;
				}
			}
		}
		
		barrier(CLK_LOCAL_MEM_FENCE);
		
		if (j>=numObjects && !localBreak)
		{
			atomic_inc(breakRequest);
			localBreak = 1;
		}
		barrier(CLK_LOCAL_MEM_FENCE);
		
		if (!localBreak)
		{
			bool bIsIntersection = TestAabbAgainstAabb2(&myAabb,&localAabbs[localCount+localId+1]) &&
				(myType!=0 || localBodyType[localCount+localId+1]!=0);
			if (bIsIntersection)
			{
				int4 currentPairIndices;
				currentPairIndices.x = myShapeI;
				currentPairIndices.y = localShapeI[localCount+localId+1];
				currentPairIndices.z = myBodyI;
				currentPairIndices.w = localBodyI[localCount+localId+1];
				int curPair = atomic_inc (pairCount);
				if (curPair<maxPairs)
				{
						pairIndices[curPair] = currentPairIndices; //flush to main memory
				}
			}
		}
		
		barrier(CLK_LOCAL_MEM_FENCE);

		localCount++;
		if (localCount==WORKGROUP_SIZE)
		{
			localCount = 0;
			block+=WORKGROUP_SIZE;			

			// load shape_i
			shape_i = (i+block)<numObjects ? indicesAABB[i+block] : shape_0;
			localShapeI[localId] = shape_i;
			shape_i2 = (i+block+WORKGROUP_SIZE)<numObjects ? indicesAABB[i+block+WORKGROUP_SIZE]: shape_0;
			localShapeI[localId+WORKGROUP_SIZE] = shape_i2;

			// load AABB
			localAabbs[localId] = aabbs[shape_i];
			localAabbs[localId+WORKGROUP_SIZE] = aabbs[shape_i2];

			// load body_i
			body_i = shapeToBodyMap[shape_i];
			localBodyI[localId] = body_i;
			body_i2 = shapeToBodyMap[shape_i2];
			localBodyI[localId+WORKGROUP_SIZE] = body_i2;

			// load type_i
			localBodyType[localId] = bodyStaticListBuffer[body_i].m_type;
			localBodyType[localId+WORKGROUP_SIZE] = bodyStaticListBuffer[body_i2].m_type;
		}
		j++;
		
	} while (breakRequest[0]<numActiveWgItems[0]);
	
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// ComputeAABBIntersection
//
// Kernel for AABBQuery user callback.
// Check intersections between the input AABB and existing AABBs.
// Indices of intersecting AABBs are stored in intersectingShapeIndices.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void ComputeAABBIntersection( 
		float4 inputAabb,
		const __global b2clAABB* aabbs, 
		const __global uint* indicesAABB,
		int numObjects,
		volatile __global int* intersectionCounts, // for each shape type
		volatile __global int* intersectionTotalCount,
		__global unsigned int* intersectingShapeIndices,
		__global unsigned int* intersectingshapeTypes)
{
	int i = get_global_id(0);

	if (i >= numObjects)
		return;

	unsigned int shape_i = indicesAABB[i];

	b2clAABB aabb;
	aabb.m_min[0] = inputAabb.x;
	aabb.m_min[1] = inputAabb.y;
	aabb.m_max[0] = inputAabb.z;
	aabb.m_max[1] = inputAabb.w;

	if(aabbs[shape_i].m_min[0] > aabb.m_max[0] || aabbs[shape_i].m_max[0] < aabb.m_min[0] ||
	   aabbs[shape_i].m_min[1] > aabb.m_max[1] || aabbs[shape_i].m_max[1] < aabb.m_min[1])
	   return;

	unsigned int s_type_i = aabbs[shape_i].m_sType;

	int curIntersection = atomic_inc(intersectionCounts + s_type_i);
	int curTotalIntersection = atomic_inc(intersectionTotalCount);

	intersectingShapeIndices[curTotalIntersection] = shape_i; 
	intersectingshapeTypes[curTotalIntersection] = s_type_i;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// RayCircleIntersection
//
// Kernel for RayCast user callback.
// Check intersection between the input ray and circle shapes.
// The algorithm is from b2CircleShape::RayCast()
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void RayCircleIntersection( 
		float4 ray,
		const __global b2clPolygonShape* shapeListBuffer,
		const __global unsigned int* shapeIndices,
		const __global b2clTransform* xfGlobal,
		const __global int* shapeToBodyMap,
		int offset,
		int numObjects,
		__global b2clRayCastOutput* outputBuffer)
{
	int i = get_global_id(0) + offset;

	if (i >= offset + numObjects)
		return;

	__global b2clRayCastOutput* output = outputBuffer + i;

	unsigned int shapeIndex = shapeIndices[i];
	const b2clPolygonShape shape = shapeListBuffer[shapeIndex];
	unsigned int bodyIndex = shapeToBodyMap[shapeIndex];
	const b2clTransform xf = xfGlobal[bodyIndex];

	output->shapeIndex = shapeIndex;

	float2 position = b2clMul_Transform(&xf, shape.m_centroid);
	float2 s = (float2)(ray.x, ray.y) - position;
	float b = b2clDot(s, s) - shape.m_radius * shape.m_radius;

	// Solve quadratic equation.
	float2 r = (float2)(ray.z, ray.w) - (float2)(ray.x, ray.y);
	float c =  b2clDot(s, r);
	float rr = b2clDot(r, r);
	float sigma = c * c - rr * b;

	// Check for negative discriminant and short segment.
	if (sigma < 0.0f || rr < b2_epsilon)
	{
		output->isCollide = 0;
		return;
	}

	// Find the point of intersection of the line with the circle.
	float a = -(c + sqrt(sigma));

	// Is the intersection point on the segment?
	if (0.0f <= a && a <= 1.0f * rr)
	{
		a /= rr;
		output->fraction = a;
		float2 normal = normalize(s + a * r);
		output->normal[0] = normal.x;
		output->normal[1] = normal.y;
		output->isCollide = 1;
	}
	else
	{
		output->isCollide = 0;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// RayEdgeIntersection
//
// Kernel for RayCast user callback.
// Check intersection between the input ray and edge shapes.
// The algorithm is from b2EdgeShape::RayCast()
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void RayEdgeIntersection( 
		float4 ray,
		const __global b2clPolygonShape* shapeListBuffer,
		const __global unsigned int* shapeIndices,
		const __global b2clTransform* xfGlobal,
		const __global int* shapeToBodyMap,
		int offset,
		int numObjects,
		__global b2clRayCastOutput* outputBuffer)
{
	int i = get_global_id(0) + offset;

	if (i >= offset + numObjects)
		return;

	__global b2clRayCastOutput* output = outputBuffer + i;

	unsigned int shapeIndex = shapeIndices[i];
	const b2clPolygonShape shape = shapeListBuffer[shapeIndex];
	unsigned int bodyIndex = shapeToBodyMap[shapeIndex];
	const b2clTransform xf = xfGlobal[bodyIndex];

	output->shapeIndex = shapeIndex;

	// Put the ray into the edge's frame of reference.
	float2 p1 = b2clMulT_Rotate(xf.q, (float2)(ray.x, ray.y) - xf.p);
	float2 p2 = b2clMulT_Rotate(xf.q, (float2)(ray.z, ray.w) - xf.p);
	float2 d = p2 - p1;

	float2 v1 = shape.m_vertices[0];
	float2 v2 = shape.m_vertices[1];
	float2 e = v2 - v1;
	float2 normal = normalize((float2)(e.y, -e.x));

	// q = p1 + t * d
	// dot(normal, q - v1) = 0
	// dot(normal, p1 - v1) + t * dot(normal, d) = 0
	float numerator = b2clDot(normal, v1 - p1);
	float denominator = b2clDot(normal, d);

	if (denominator == 0.0f)
	{
		output->isCollide = 0;
		return;
	}

	float t = numerator / denominator;
	if (t < 0.0f || 1.0f < t)
	{
		output->isCollide = 0;
		return;
	}

	float2 q = p1 + t * d;

	// q = v1 + s * r
	// s = dot(q - v1, r) / dot(r, r)
	float2 r = v2 - v1;
	float rr = b2clDot(r, r);
	if (rr == 0.0f)
	{
		output->isCollide = 0;
		return;
	}

	float s = b2clDot(q - v1, r) / rr;
	if (s < 0.0f || 1.0f < s)
	{
		output->isCollide = 0;
		return;
	}

	output->fraction = t;
	if (numerator > 0.0f)
	{
		output->normal[0] = -normal.x;
		output->normal[1] = -normal.y;
	}
	else
	{
		output->normal[0] = normal.x;
		output->normal[1] = normal.y;
	}
	output->isCollide = 1;
	
	return;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// RayPolygonIntersection
//
// Kernel for RayCast user callback.
// Check intersection between the input ray and polygon shapes.
// The algorithm is from b2PolygonShape::RayCast()
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void RayPolygonIntersection( 
		float4 ray,
		const __global b2clPolygonShape* shapeListBuffer,
		const __global unsigned int* shapeIndices,
		const __global b2clTransform* xfGlobal,
		const __global int* shapeToBodyMap,
		int offset,
		int numObjects,
		__global b2clRayCastOutput* outputBuffer)
{
	int i = get_global_id(0) + offset;

	if (i >= offset + numObjects)
		return;

	__global b2clRayCastOutput* output = outputBuffer + i;

	unsigned int shapeIndex = shapeIndices[i];
	const b2clPolygonShape shape = shapeListBuffer[shapeIndex];
	unsigned int bodyIndex = shapeToBodyMap[shapeIndex];
	const b2clTransform xf = xfGlobal[bodyIndex];

	output->shapeIndex = shapeIndex;

	// Put the ray into the polygon's frame of reference.
	float2 p1 = b2clMulT_Rotate(xf.q, (float2)(ray.x, ray.y) - xf.p);
	float2 p2 = b2clMulT_Rotate(xf.q, (float2)(ray.z, ray.w) - xf.p);
	float2 d = p2 - p1;

	float lower = 0.0f, upper = 1.0f;

	int index = -1;

	for (int i = 0; i < shape.m_vertexCount; ++i)
	{
		// p = p1 + a * d
		// dot(normal, p - v) = 0
		// dot(normal, p1 - v) + a * dot(normal, d) = 0
		float numerator = b2clDot(shape.m_normals[i], shape.m_vertices[i] - p1);
		float denominator = b2clDot(shape.m_normals[i], d);

		if (denominator == 0.0f)
		{	
			if (numerator < 0.0f)
			{
				output->isCollide = 0;
				return;
			}
		}
		else
		{
			// Note: we want this predicate without division:
			// lower < numerator / denominator, where denominator < 0
			// Since denominator < 0, we have to flip the inequality:
			// lower < numerator / denominator <==> denominator * lower > numerator.
			if (denominator < 0.0f && numerator < lower * denominator)
			{
				// Increase lower.
				// The segment enters this half-space.
				lower = numerator / denominator;
				index = i;
			}
			else if (denominator > 0.0f && numerator < upper * denominator)
			{
				// Decrease upper.
				// The segment exits this half-space.
				upper = numerator / denominator;
			}
		}

		// The use of epsilon here causes the assert on lower to trip
		// in some cases. Apparently the use of epsilon was to make edge
		// shapes work, but now those are handled separately.
		//if (upper < lower - b2_epsilon)
		if (upper < lower)
		{
			output->isCollide = 0;
			return;
		}
	}

	//b2Assert(0.0f <= lower && lower <= input.maxFraction);

	if (index >= 0)
	{
		output->fraction = lower;
		float2 normal = b2clMul_Rotate(xf.q, shape.m_normals[index]);
		output->normal[0] = normal.x;
		output->normal[1] = normal.y;
		output->isCollide = 1;
	}
	else
	{
		output->isCollide = 0;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// RayChainIntersection
//
// Kernel for RayCast user callback.
// But this function is never called and edge shape is used for chains.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void RayChainIntersection( 
		float4 ray,
		const __global b2clPolygonShape* shapeListBuffer,
		const __global unsigned int* shapeIndices,
		const __global b2clTransform* xfGlobal,
		const __global int* shapeToBodyMap,
		int offset,
		int numObjects,
		__global b2clRayCastOutput* outputBuffer)
{
	int i = get_global_id(0) + offset;

	if (i >= offset + numObjects)
		return;

	__global b2clRayCastOutput* output = outputBuffer + i;

	output->isCollide = 0;
}/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/


/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/


#pragma OPENCL EXTENSION cl_amd_printf : enable

/// The maximum number of contact points between two convex shapes. Do
/// not change this value.
#define b2cl_maxManifoldPoints	2

/// The maximum number of vertices on a convex polygon. You cannot increase
/// this too much because b2BlockAllocator has a maximum object size.
#define b2cl_maxPolygonVertices	8

/// A velocity threshold for elastic collisions. Any collision with a relative linear
/// velocity below this threshold will be treated as inelastic.
//#define b2cl_velocityThreshold		0.01f
#define b2cl_velocityThreshold		1.0f

/// This is used to fatten AABBs in the dynamic tree. This is used to predict
/// the future position based on the current displacement.
/// This is a dimensionless multiplier.
#define b2cl_aabbMultiplier		2.0f

#define	b2_maxFloat	FLT_MAX
#define	b2_epsilon FLT_EPSILON
#define b2_pi 3.14159265359f
#define b2_maxTranslation 2.0f
#define b2_maxRotation 0.5f*b2_pi
#define b2_baumgarte 0.2f
#define b2_linearSlop 0.005f
#define b2_angularSlop			(2.0f / 180.0f * b2_pi)
#define b2_polygonRadius		(2.0f * b2_linearSlop)
#define b2_maxLinearCorrection 0.2f
#define b2_maxAngularCorrection		(8.0f / 180.0f * b2_pi)

#ifndef MAXFLOAT
#define MAXFLOAT      3.402823466e+38F
#endif


/// The features that intersect to form the contact point
/// This must be 4 bytes or less.
typedef struct b2clContactFeature
{
	uchar indexA;		///< Feature index on shapeA
	uchar indexB;		///< Feature index on shapeB
	uchar typeA;		///< The feature type on shapeA
	uchar typeB;		///< The feature type on shapeB
} b2clContactFeature;

/// Contact ids to facilitate warm starting.
typedef union b2clContactID
{
	b2clContactFeature cf;
	uint key;					///< Used to quickly compare contact ids.
} b2clContactID;

/// A manifold point is a contact point belonging to a contact
/// manifold. It holds details related to the geometry and dynamics
/// of the contact points.
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleB
/// -e_faceA: the local center of cirlceB or the clip point of polygonB
/// -e_faceB: the clip point of polygonA
/// This structure is stored across time steps, so we keep it small.
/// Note: the impulses are used for internal caching and may not
/// provide reliable contact forces, especially for high speed collisions.
typedef struct b2clManifoldPoint
{
	float2 localPoint;		///< usage depends on manifold type
	float normalImpulse;	///< the non-penetration impulse
	float tangentImpulse;	///< the friction impulse
	b2clContactID id;			///< uniquely identifies a contact point between two shapes
	float dummy; // for alignment
} b2clManifoldPoint;

/// A manifold for two touching convex shapes.
/// Box2D supports multiple types of contact:
/// - clip point versus plane with radius
/// - point versus point with radius (circles)
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleA
/// -e_faceA: the center of faceA
/// -e_faceB: the center of faceB
/// Similarly the local normal usage:
/// -e_circles: not used
/// -e_faceA: the normal on polygonA
/// -e_faceB: the normal on polygonB
/// We store contacts in this way so that position correction can
/// account for movement, which is critical for continuous physics.
/// All contact scenarios must be expressed in one of these types.
/// This structure is stored across time steps, so we keep it small.
typedef struct b2clManifold
{
	float2 localNormal;								///< not use for Type::e_points
	float2 localPoint;								///< usage depends on manifold type
	b2clManifoldPoint points[b2cl_maxManifoldPoints];	///< the points of contact
	int type;
	int pointCount;								///< the number of manifold points
	//float2 test;
} b2clManifold;

typedef struct b2clFilter
{
	unsigned short categoryBits;
	unsigned short maskBits;
	short groupIndex;
	short dummy;
} b2clFilter;

/// A convex polygon. It is assumed that the interior of the polygon is to
/// the left of each edge.
/// Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.
/// In most cases you should not need many vertices for a convex polygon.
//////////////
/// We reuse b2clPolygonShape for b2clCircleShape
/// We may have to change this later
typedef struct b2clPolygonShape
{
	float2 m_centroid;
	float2 m_vertices[b2cl_maxPolygonVertices];
	float2 m_normals[b2cl_maxPolygonVertices];
	int m_type;
	float m_radius;
	int m_vertexCount;
	int m_bIsSensor;
	b2clFilter m_filter;
} b2clPolygonShape;

/// A transform contains translation and rotation. It is used to represent
/// the position and orientation of rigid frames.
typedef struct b2clTransform
{
	float2 p;
	float2 q;
} b2clTransform;

/// This describes the motion of a body/shape for TOI computation.
/// Shapes are defined with respect to the body origin, which may
/// no coincide with the center of mass. However, to support dynamics
/// we must interpolate the center of mass position.
typedef struct b2clSweep
{
	float2 localCenter;	///< local center of mass position
	float2 c0, c;		///< center world positions
	float a0, a;		///< world angles

	/// Fraction of the current time step in the range [0,1]
	/// c0 and a0 are the positions at alpha0.
	float alpha0;
	float dummy;
}  b2clSweep;

/// Used for computing contact manifolds.
typedef struct b2clClipVertex
{
	float2 v;
	b2clContactID id;
} b2clClipVertex;

typedef struct clb2Velocity
{
    float vx;
    float vy;
    float w;
}clb2Velocity;

typedef struct clb2Position
{
    float cx;
    float cy;
    float a;
}clb2Position;

typedef struct clb2Contact
{
    int color;
    int indexA;
    int indexB;
    float friction;
    float2 normal;
    float invMassA;
    float invIA;
    float invMassB;
    float invIB;
}clb2Contact;

typedef struct clb2Impulse
{
    float normalImpulse1;
    float tangentImpulse1;
    
    float normalImpulse2;
    float tangentImpulse2;
}clb2Impulse;

typedef struct clb2Points
{
    float2 rA1;
    float2 rB1;
    float normalMass1;
    float tangentMass1;
    
    float2 rA2;
    float2 rB2;
    float normalMass2;
    float tangentMass2;
    
    float velocityBias1;
    float velocityBias2;
}clb2Points;

typedef struct b2clFixtureStatic
{
	float m_friction;
	float m_restitution;
	int m_last_uid;
	int dummy; 
} b2clFixtureStatic;

#define MAX_CONNECTED_BODY_INDICES 8
typedef struct b2clBodyStatic
{
	float2 m_localCenter;	///< local center of mass position
	float /*m_mass,*/ m_invMass;
	// Rotational inertia about the center of mass.
	float /*m_I,*/ m_invI;
	float m_linearDamping;
	float m_angularDamping;
	float m_gravityScale;
	float m_type;
	int m_connectedBodyIndices[MAX_CONNECTED_BODY_INDICES];
	int m_bIsBullet;
	int dummy;
} b2clBodyStatic;

typedef struct b2clBodyDynamic
{
	b2clSweep m_sweep;		// the swept motion for CCD

	float2 m_linearVelocity;
	float2 m_force;
	float m_angularVelocity;
	float m_torque;
	int m_last_uid ;
	int dummy ; 
} b2clBodyDynamic;

// Extract useful information of manifolds for position constraint solver
typedef struct clb2Manifold
{
    float2 localNormal;
    float2 localPoint;
    float2 localPoints1;
    float2 localPoints2;
    int pointCount;
    int type;
    float radiusA;
    float radiusB;
    float2 localCenterA;
    float2 localCenterB;
}clb2Manifold;

typedef struct{
    int type;
	int pointCount;
	float localPointX;
	float localPointY;
	float localNormalX;
	float localNormalY; 
	float point0X;
	float point0Y;
	float point1X;
	float point1Y; 
}clb2SDManifold;

typedef struct{
	int fixtureAIndex;
	int fixtureBIndex;
	int bodyAIndex ; 
	int bodyBIndex ; 
}clb2SDContact;

typedef struct{
	int bodyIndex ;
	float posX;
	float posY ; 
	float posAngle;
	float xfX;
	float xfY;
	float xfS;
	float xfC;
	float alpha;
	float velocityX;
	float velocityY;
	float velocityAngular; 
}clb2SDBody;

typedef struct clb2PositionSolverManifold
{
    float2 normal;
    float2 point;
    float separation;
}clb2PositionSolverManifold;

typedef struct clb2Rotation
{
    float s;
    float c;
}clb2Rotation;

typedef struct clb2Transform
{
    clb2Rotation rotation;
    float2 translation;
}clb2Transform;

typedef struct b2clMat22
{
	float ex[2];
	float ey[2];
}b2clMat22;

typedef struct b2clMat33
{
	float ex[3];
	float ey[3];
	float ez[3];
}b2clMat33;

enum b2clLimitState
{
	e_inactiveLimit,
	e_atLowerLimit,
	e_atUpperLimit,
	e_equalLimits
};

enum b2JointType
{
	e_unknownJoint,
	e_revoluteJoint,
	e_prismaticJoint,
	e_distanceJoint,
	e_pulleyJoint,
	e_mouseJoint,
	e_gearJoint,
	e_wheelJoint,
    e_weldJoint,
	e_frictionJoint,
	e_ropeJoint
};

typedef struct b2clDistanceJointDatastruct
{
	float frequencyHz;
	float dampingRatio;
	float bias;

	float localAnchorA[2];
	float localAnchorB[2];
	float gamma;
	float nlength;

	float u[2];
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	float mass;
} b2clDistanceJointData;

typedef struct b2clRevoluteJointData
{
	float localAnchorA[2];
	float localAnchorB[2];

	int enableMotor;
	float maxMotorTorque;
	float motorSpeed;

	int enableLimit;
	float referenceAngle;
	float lowerAngle;
	float upperAngle;

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat33 mass;			// effective mass for point-to-point constraint.
	float motorMass;	// effective mass for motor/limit angular constraint.
	int limitState;
} b2clRevoluteJointData;

typedef struct b2clPrismaticJointData
{
	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float localXAxisA[2];
	float localYAxisA[2];
	float referenceAngle;
	float lowerTranslation;
	float upperTranslation;
	float maxMotorForce;
	float motorSpeed;
	int enableLimit;
	int enableMotor;
	int limitState;

	// Solver temp
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	float axis[2], perp[2];
	float s1, s2;
	float a1, a2;
	b2clMat33 K;
	float motorMass;
} b2clPrismaticJointData;

typedef struct b2clGearJointData
{
	int joint1;
	int joint2;
	int typeA;
	int typeB;

	float localAnchorA[2];
	float localAnchorB[2];
	float localAnchorC[2];
	float localAnchorD[2];

	float localAxisC[2];
	float localAxisD[2];

	float referenceAngleA;
	float referenceAngleB;

	float gearConstant;
	float ratio;

	// Solver temp
	float lcA[2], lcB[2], lcC[2], lcD[2];
	float mA, mB, mC, mD;
	float iA, iB, iC, iD;
	float JvAC[2], JvBD[2];
	float JwA, JwB, JwC, JwD;
	float mass;
} b2clGearJointData;

typedef struct b2clPulleyJointData
{
	float groundAnchorA[2];
	float groundAnchorB[2];
	float lengthA;
	float lengthB;
	float localAnchorA[2];
	float localAnchorB[2]; 
	float pulleyConstant; 
	float ratio; 
	float uA[2]; 
	float uB[2]; 
	float rA[2]; 
	float rB[2]; 
	float localCenterA[2];
	float localCenterB[2]; 
	float invMassA; 
	float invMassB; 
	float invIA; 
	float invIB;
	float mass; 
}b2clPulleyJointData; 

typedef struct b2clRopeJointData
{	
	float localAnchorA[2];
	float localAnchorB[2]; 
	float maxLength; 
	float nlength;
	float u[2]; 
	float rA[2]; 
	float rB[2]; 
	float localCenterA[2];
	float localCenterB[2]; 
	float invMassA; 
	float invMassB; 
	float invIA; 
	float invIB;
	float mass; 
	int limitState; 
} b2clRopeJointData; 

typedef struct b2clWheelJointData
{
	float frequencyHz;
	float dampingRatio;

	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float localXAxisA[2];
	float localYAxisA[2];

	float maxMotorTorque;
	float motorSpeed;
	int enableMotor;

	// Solver temp
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;

	float ax[2], ay[2];
	float sAx, sBx;
	float sAy, sBy;

	float mass;
	float motorMass;
	float springMass;

	float bias;
	float gamma;
} b2clWheelJointData;

typedef struct b2clWeldJointData
{
	float frequencyHz;
	float dampingRatio;
	float bias;

	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float referenceAngle;
	float gamma;

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat33 mass;
} b2clWeldJointData;

typedef struct b2clMouseJointData
{
	float localAnchorB[2];
	float targetA[2];
	float frequencyHz;
	float dampingRatio;
	float beta;
	
	// Solver shared
	float maxForce;
	float gamma;

	// Solver temp
	float rB[2];
	float localCenterB[2];
	float invMassB;
	float invIB;
	b2clMat22 mass;
	float C[2];
} b2clMouseJointData;

typedef struct b2clFrictionJointData
{
	float localAnchorA[2];
	float localAnchorB[2];

	float maxForce; 
	float maxTorque; 

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat22 linearMass;
	float angularMass; 
} b2clFrictionJointData;

typedef struct clJoint
{
	int index;

	// impulse : 4 floats
	union a1{
		struct x1{
			float impulse[3];
		}x;
		struct y1{
			float scalarImpulse;
			float springImpulse;
		}y;
		struct z1{
			float linearImpulse[2];
			float angularImpulse;
		}z;
	}a;
	float motorImpulse;

	int color;
	int type;
	int collideConnected;

	int indexA, indexB, indexC, indexD;

	union b1{
		b2clDistanceJointData distanceJointData;
		b2clRevoluteJointData revoluteJointData;
		b2clPrismaticJointData prismaticJointData;
		b2clGearJointData gearJointData;
		b2clPulleyJointData pulleyJointData;
		b2clRopeJointData ropeJointData;
		b2clWheelJointData wheelJointData;
		b2clWeldJointData weldJointData;
		b2clMouseJointData mouseJointData;
		b2clFrictionJointData frictionJointData;
	}b;
} b2clJoint;

typedef struct
{
	int index;
    float nimpulse[4];
} b2clJointImpulseNode;

typedef struct
{
	int isCollide;
	float normal[2];
	float fraction;
	unsigned int shapeIndex;
} b2clRayCastOutput;

typedef struct
{
	float2 m_buffer[2];
	float2 m_vertices[b2cl_maxPolygonVertices];
	int m_count;
	float m_radius;
} b2clDistanceProxy;

typedef struct 
{
	float metric;		///< length or area
	short count;
	unsigned char indexA[3];	///< vertices on shape A
	unsigned char indexB[3];	///< vertices on shape B
} b2clSimplexCache;

/// Input for b2Distance.
/// You have to option to use the shape radii
/// in the computation. Even 
typedef struct 
{
	b2clDistanceProxy proxyA;
	b2clDistanceProxy proxyB;
	b2clTransform transformA;
	b2clTransform transformB;
	bool useRadii;
} b2clDistanceInput;

/// Output for b2Distance.
typedef struct
{
	float2 pointA;		///< closest point on shapeA
	float2 pointB;		///< closest point on shapeB
	float ndistance;
	int iterations;	///< number of GJK iterations used
} b2clDistanceOutput;

typedef struct
{
	b2clDistanceProxy proxyA;
	b2clDistanceProxy proxyB;
	b2clSweep sweepA;
	b2clSweep sweepB;
	float tMax;		// defines sweep interval [0, tMax]
	float dummy;
} b2clTOIInput;

enum b2clTOIOutputState
{
	e_unknown,
	e_failed,
	e_overlapped,
	e_touching,
	e_separated
};

typedef struct
{
	int state;
	float t;
} b2clTOIOutput;

typedef struct
{
	float2 wA;		// support point in proxyA
	float2 wB;		// support point in proxyB
	float2 w;		// wB - wA
	float a;		// barycentric coordinate for closest point
	int indexA;	// wA index
	int indexB;	// wB index
} b2clSimplexVertex;

typedef struct 
{
	b2clSimplexVertex m_v1, m_v2, m_v3;
	int m_count;
} b2clSimplex;

//typedef struct{
//float v[30];
//} testData; 

//==============================================================================================
// Math functions
//==============================================================================================

/// Multiply two rotations: q * r
inline float2 b2clMul_TwoRotation(const float2 q, const float2 r)
{
	// [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
	// [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]
	// s = qs * rc + qc * rs
	// c = qc * rc - qs * rs
	float2 qr;
	qr.x = q.x * r.y + q.y * r.x;
	qr.y = q.y * r.y - q.x * r.x;
	return qr;
}

/// Transpose multiply two rotations: qT * r
inline float2 b2clMulT_TwoRotation(const float2 q, const float2 r)
{
	// [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
	// [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]
	// s = qc * rs - qs * rc
	// c = qc * rc + qs * rs
	float2 qr;
	qr.x = q.y * r.x - q.x * r.y;
	qr.y = q.y * r.y + q.x * r.x;
	return qr;
}

/// Rotate a vector
inline float2 b2clMul_Rotate(const float2 q, const float2 v)
{
	float2 result;
	result.x = q.y * v.x - q.x * v.y;
	result.y = q.x * v.x + q.y * v.y;

	return result;
}

/// Inverse rotate a vector
inline float2 b2clMulT_Rotate(const float2 q, const float2 v)
{
	float2 result;
	result.x = q.y * v.x + q.x * v.y;
	result.y = -q.x * v.x + q.y * v.y;

	return result;
}

/// Transform a vector
inline float2 b2clMul_Transform(const b2clTransform *T, const float2 v)
{
	float2 result;
	result.x = (T->q.y * v.x - T->q.x * v.y) + T->p.x;
	result.y = (T->q.x * v.x + T->q.y * v.y) + T->p.y;

	return result;
}

/// Invert transform a vector
inline float2 b2clMulT_Transform(const b2clTransform *T, const float2 v)
{
	float px = v.x - T->p.x;
	float py = v.y - T->p.y;
	float2 result;
	result.x = (T->q.y * px + T->q.x * py);
	result.y = (-T->q.x * px + T->q.y * py);

	return result;
}

// v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
//    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
inline b2clTransform b2clMul_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
	b2clTransform C;
	C.q = b2clMul_TwoRotation(A->q, B->q);
	C.p = b2clMul_TwoRotation(A->q, B->p) + A->p;
	return C;
}

// v2 = A.q' * (B.q * v1 + B.p - A.p)
//    = A.q' * B.q * v1 + A.q' * (B.p - A.p)
inline b2clTransform b2clMulT_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
	b2clTransform C;
	C.q = b2clMulT_TwoRotation(A->q, B->q);
	C.p = b2clMulT_TwoRotation(A->q, B->p - A->p);
	return C;
}

/// Perform the dot product on two vectors.
inline float b2clDot(const float2 a, const float2 b)
{
	return a.x * b.x + a.y * b.y;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float b2clCross_VV(const float2 a, const float2 b)
{
	return a.x * b.y - a.y * b.x;
}

/// Perform the cross product on a vector and a scalar. In 2D this produces
/// a vector.
inline float2 b2clCross_VS(const float2 a, float s)
{
	return (float2)(s * a.y, -s *a.x);
}

/// Perform the cross product on a scalar and a vector. In 2D this produces
/// a vector.
inline float2 b2clCross_SV(float s, const float2 a)
{
	return (float2)(-s * a.y, s * a.x);
}

inline float b2clClamp(float a, float low, float high)
{
	return max(low, min(a, high));
}

inline float2 b2clMin(const float2 a, const float2 b)
{
	return (float2)(min(a.x, b.x), min(a.y, b.y));
}

inline float2 b2clMax(const float2 a, const float2 b)
{
	return (float2)(max(a.x, b.x), max(a.y, b.y));
}

inline float b2clDistanceSquared(const float2 a, const float2 b)
{
	float2 c = a - b;
	return b2clDot(c, c);
}

inline float b2clDistance(const float2 a, const float2 b)
{
	float2 c = a - b;
	return sqrt(b2clDot(c, c));
}

inline float b2clLengthSquared(const float2 v)
{
	return b2clDot(v, v);
}

inline float b2clAbs(float a)
{
	return a > 0.0f ? a : -a;
}

/// Perform the dot product on two vectors.
inline float b2clDot3(const float3 a, const float3 b)
{
	return a.x * b.x + a.y * b.y + a.z * b.z;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float3 b2clCross3_VV(const float3 a, const float3 b)
{
	return (float3)(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float3 b2clMat33Solve(const b2clMat33 mat, const float3 b)
{
	float3 ex = (float3)(mat.ex[0], mat.ex[1], mat.ex[2]);
	float3 ey = (float3)(mat.ey[0], mat.ey[1], mat.ey[2]);
	float3 ez = (float3)(mat.ez[0], mat.ez[1], mat.ez[2]);

	float det = b2clDot3(ex, b2clCross3_VV(ey, ez));

	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float3 x;
	x.x = det * b2clDot3(b, b2clCross3_VV(ey, ez));
	x.y = det * b2clDot3(ex, b2clCross3_VV(b, ez));
	x.z = det * b2clDot3(ex, b2clCross3_VV(ey, b));
	return x;
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float2 b2clMat33Solve22(const b2clMat33 mat, const float2 b)
{
	float2 ex = (float2)(mat.ex[0], mat.ex[1]);
	float2 ey = (float2)(mat.ey[0], mat.ey[1]);

	float det = ex.x * ey.y - ey.x * ex.y;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float2 x;
	x.x = det * (ey.y * b.x - ey.x * b.y);
	x.y = det * (ex.x * b.y - ex.y * b.x);
	return x;
}

inline float2 b2clMat22Solve(const b2clMat22 mat, const float2 b)
{
	float2 ex = (float2)(mat.ex[0], mat.ex[1]);
	float2 ey = (float2)(mat.ey[0], mat.ey[1]);

	float det = ex.x * ey.y - ey.x * ex.y;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float2 x;
	x.x = det * (ey.y * b.x - ey.x * b.y);
	x.y = det * (ex.x * b.y - ex.y * b.x);
	return x;
}

inline float2 b2clMat33Mul22(const b2clMat33 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float2 b2clMat22Mul(const b2clMat22 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline void b2clGetInverse22(const b2clMat33 in, b2clMat33* out)
{
	float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
	float det = a * d - b * c;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}

	out->ex[0] =  det * d;	out->ey[0] = -det * b; out->ex[2] = 0.0f;
	out->ex[1] = -det * c;	out->ey[1] =  det * a; out->ey[2] = 0.0f;
	out->ez[0] = 0.0f; out->ez[1] = 0.0f; out->ez[2] = 0.0f;
}

inline void b2clGetSymInverse33(const b2clMat33 in, b2clMat33* out)
{
	//float det = b2clDot(ex, b2clCross(ey, ez));
	float det = in.ex[0] * (in.ey[1] * in.ez[2] - in.ey[2] * in.ez[1]) 
		+ in.ex[1] * (in.ey[2] * in.ez[0] - in.ey[0] * in.ez[2]) 
		+ in.ex[2] * (in.ey[0] * in.ez[1] - in.ey[1] * in.ez[0]);

	if (det != 0.0f)
	{
		det = 1.0f / det;
	}

	float a11 = in.ex[0], a12 = in.ey[0], a13 = in.ez[0];
	float a22 = in.ey[1], a23 = in.ez[1];
	float a33 = in.ez[2];

	out->ex[0] = det * (a22 * a33 - a23 * a23);
	out->ex[1] = det * (a13 * a23 - a12 * a33);
	out->ex[2] = det * (a12 * a23 - a13 * a22);

	out->ey[0] = out->ex[1];
	out->ey[1] = det * (a11 * a33 - a13 * a13);
	out->ey[2] = det * (a13 * a12 - a11 * a23);

	out->ez[0] = out->ex[2];
	out->ez[1] = out->ey[2];
	out->ez[2] = det * (a11 * a22 - a12 * a12);
}

inline float2 b2clMat33MulV2(const b2clMat33 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float3 b2clMat33MulV3(const b2clMat33 A, const float3 v)
{
	//return v.x * A.ex + v.y * A.ey + v.z * A.ez;
	return (float3)(A.ex[0] * v.x + A.ey[0] * v.y + A.ez[0] * v.z,
		A.ex[1] * v.x + A.ey[1] * v.y + A.ez[1] * v.z,
		A.ex[2] * v.x + A.ey[2] * v.y + A.ez[2] * v.z);
}

inline void b2clMat22GetInverse(const b2clMat22 in, b2clMat22* out)
{
	float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
	float det = a * d - b * c;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	out->ex[0] =  det * d;	out->ey[0] = -det * b;
	out->ex[1] = -det * c;	out->ey[1] =  det * a;
}

inline void b2clSweepNormalize(b2clSweep* sweep)
{
	float twoPi = 2.0f * b2_pi;
	float d =  twoPi * floor(sweep->a0 / twoPi);
	sweep->a0 -= d;
	sweep->a -= d;
}

inline void b2clSweepGetTransform(b2clSweep* sweep, b2clTransform* xf, float beta)
{
	xf->p = (1.0f - beta) * sweep->c0 + beta * sweep->c;
	float angle = (1.0f - beta) * sweep->a0 + beta * sweep->a;
	xf->q.x = sin(angle);
	xf->q.y = cos(angle);

	// Shift to origin
	xf->p -= b2clMul_Rotate(xf->q, sweep->localCenter);
}

inline void b2clSweepAdvance(b2clSweep* sweep, float alpha)
{
	float beta = (alpha - sweep->alpha0) / (1.0f - sweep->alpha0);
	sweep->c0 = (1.0f - beta) * sweep->c0 + beta * sweep->c;
	sweep->a0 = (1.0f - beta) * sweep->a0 + beta * sweep->a;
	sweep->alpha0 = alpha;
}
inline void b2clBodySweepAdvance (b2clBodyDynamic* body, b2clTransform* xf, float alpha) {
	b2clSweepAdvance(&(body->m_sweep), alpha); 
	body->m_sweep.c = body->m_sweep.c0;
	body->m_sweep.a = body->m_sweep.a0;
    xf->q.x = sin (body->m_sweep.a);
	xf->q.y = cos (body->m_sweep.a); 
	xf->p = body->m_sweep.c - b2clMul_Rotate(xf->q, body->m_sweep.localCenter);
}

inline void b2clDistanceProxySet(b2clDistanceProxy* proxy, const b2clPolygonShape* shape)
{
	proxy->m_count = shape->m_vertexCount;
	proxy->m_radius = shape->m_radius;
	for (int i = 0; i < shape->m_vertexCount; ++i)
	{
		proxy->m_vertices[i] = shape->m_vertices[i];
	}
}

inline int b2clDistanceProxyGetSupport(const b2clDistanceProxy* proxy, float2 d)
{
	int bestIndex = 0;
	float bestValue = b2clDot(proxy->m_vertices[0], d);
	for (int i = 1; i < proxy->m_count; ++i)
	{
		float value = b2clDot(proxy->m_vertices[i], d);
		if (value > bestValue)
		{
			bestIndex = i;
			bestValue = value;
		}
	}
	return bestIndex;
}

inline float2 b2clDistanceProxyGetVertex(const b2clDistanceProxy* proxy, int index)
{
	return proxy->m_vertices[index];
}

// Convert a vector into a unit vector. Returns the length.
inline float b2clNormalize(float2* v)
{
	float length = sqrt(b2clDot(*v, *v));
	if (length < b2_epsilon)
	{
		return 0.0f;
	}
	float invLength = 1.0f / length;
	(*v).x *= invLength;
	(*v).y *= invLength;

	return length;
}

/*
inline float cos_wrapper(float a)
{
	//float sina = sin(a);
	//return sqrt(1-sina*sina);

	//return sin(1.5707963268-a);

	return cos(a);
}
*/

//#include <Box2D/Common/OpenCL/b2CLTypeDefOCL.h>

////////////////////////////////////////////////////////////////////////////////////////////////////
// ReadLastJointImpulses
// 
// Read joint impulses of the last frame for warm starting.
// b2clJointImpulseNode contains impulses of the last frame.
// Joint index is used to find the position of the impulse of a joint in the array.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void ReadLastJointImpulses(
                                 __global b2clJoint* joints, // output
								 const __global b2clJointImpulseNode* lastJointImpulses, // input, joint impulses of the last frame
								 const __global int* jointImpulseKeys,
								 const __global int* jointImpulseGlobalIndices,
								 const unsigned int jointCount,
								 const unsigned int lastjointCount)
{
    unsigned int jointIndex = get_global_id(0);

    if (jointIndex >= jointCount) return;

	__global b2clJoint* currentJoint = joints + jointIndex;
	int currentId = currentJoint->index;

	// binary search
	int lb = 0; // low bound
	int ub = lastjointCount-1; // upper bound
	int mid;
	bool bFound = false;
	uint midId;
	
	while (lb <= ub)
	{
		mid = (lb+ub)/2;
		
		midId = jointImpulseKeys[mid];

		if (midId == currentId)
		{
			bFound = true;
			break;
		}
		else if (midId < currentId)
		{
			ub = mid - 1;
		}
		else
		{
			lb = mid + 1;
		}
	}

	if (bFound)
	{
		const __global b2clJointImpulseNode* storedNode = lastJointImpulses + jointImpulseGlobalIndices[mid];
		currentJoint->a.x.impulse[0] = storedNode->nimpulse[0];
		currentJoint->a.x.impulse[1] = storedNode->nimpulse[1];
		currentJoint->a.x.impulse[2] = storedNode->nimpulse[2];
		currentJoint->motorImpulse = storedNode->nimpulse[3];
	}
	else
	{
		currentJoint->a.x.impulse[0] = 0.0f;
		currentJoint->a.x.impulse[1] = 0.0f;
		currentJoint->a.x.impulse[2] = 0.0f;
		currentJoint->motorImpulse = 0.0f;
	}
}
/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/

/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/


#pragma OPENCL EXTENSION cl_amd_printf : enable

/// The maximum number of contact points between two convex shapes. Do
/// not change this value.
#define b2cl_maxManifoldPoints	2

/// The maximum number of vertices on a convex polygon. You cannot increase
/// this too much because b2BlockAllocator has a maximum object size.
#define b2cl_maxPolygonVertices	8

/// A velocity threshold for elastic collisions. Any collision with a relative linear
/// velocity below this threshold will be treated as inelastic.
//#define b2cl_velocityThreshold		0.01f
#define b2cl_velocityThreshold		1.0f

/// This is used to fatten AABBs in the dynamic tree. This is used to predict
/// the future position based on the current displacement.
/// This is a dimensionless multiplier.
#define b2cl_aabbMultiplier		2.0f

#define	b2_maxFloat	FLT_MAX
#define	b2_epsilon FLT_EPSILON
#define b2_pi 3.14159265359f
#define b2_maxTranslation 2.0f
#define b2_maxRotation 0.5f*b2_pi
#define b2_baumgarte 0.2f
#define b2_linearSlop 0.005f
#define b2_angularSlop			(2.0f / 180.0f * b2_pi)
#define b2_polygonRadius		(2.0f * b2_linearSlop)
#define b2_maxLinearCorrection 0.2f
#define b2_maxAngularCorrection		(8.0f / 180.0f * b2_pi)

#ifndef MAXFLOAT
#define MAXFLOAT      3.402823466e+38F
#endif


/// The features that intersect to form the contact point
/// This must be 4 bytes or less.
typedef struct b2clContactFeature
{
	uchar indexA;		///< Feature index on shapeA
	uchar indexB;		///< Feature index on shapeB
	uchar typeA;		///< The feature type on shapeA
	uchar typeB;		///< The feature type on shapeB
} b2clContactFeature;

/// Contact ids to facilitate warm starting.
typedef union b2clContactID
{
	b2clContactFeature cf;
	uint key;					///< Used to quickly compare contact ids.
} b2clContactID;

/// A manifold point is a contact point belonging to a contact
/// manifold. It holds details related to the geometry and dynamics
/// of the contact points.
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleB
/// -e_faceA: the local center of cirlceB or the clip point of polygonB
/// -e_faceB: the clip point of polygonA
/// This structure is stored across time steps, so we keep it small.
/// Note: the impulses are used for internal caching and may not
/// provide reliable contact forces, especially for high speed collisions.
typedef struct b2clManifoldPoint
{
	float2 localPoint;		///< usage depends on manifold type
	float normalImpulse;	///< the non-penetration impulse
	float tangentImpulse;	///< the friction impulse
	b2clContactID id;			///< uniquely identifies a contact point between two shapes
	float dummy; // for alignment
} b2clManifoldPoint;

/// A manifold for two touching convex shapes.
/// Box2D supports multiple types of contact:
/// - clip point versus plane with radius
/// - point versus point with radius (circles)
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleA
/// -e_faceA: the center of faceA
/// -e_faceB: the center of faceB
/// Similarly the local normal usage:
/// -e_circles: not used
/// -e_faceA: the normal on polygonA
/// -e_faceB: the normal on polygonB
/// We store contacts in this way so that position correction can
/// account for movement, which is critical for continuous physics.
/// All contact scenarios must be expressed in one of these types.
/// This structure is stored across time steps, so we keep it small.
typedef struct b2clManifold
{
	float2 localNormal;								///< not use for Type::e_points
	float2 localPoint;								///< usage depends on manifold type
	b2clManifoldPoint points[b2cl_maxManifoldPoints];	///< the points of contact
	int type;
	int pointCount;								///< the number of manifold points
	//float2 test;
} b2clManifold;

typedef struct b2clFilter
{
	unsigned short categoryBits;
	unsigned short maskBits;
	short groupIndex;
	short dummy;
} b2clFilter;

/// A convex polygon. It is assumed that the interior of the polygon is to
/// the left of each edge.
/// Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.
/// In most cases you should not need many vertices for a convex polygon.
//////////////
/// We reuse b2clPolygonShape for b2clCircleShape
/// We may have to change this later
typedef struct b2clPolygonShape
{
	float2 m_centroid;
	float2 m_vertices[b2cl_maxPolygonVertices];
	float2 m_normals[b2cl_maxPolygonVertices];
	int m_type;
	float m_radius;
	int m_vertexCount;
	int m_bIsSensor;
	b2clFilter m_filter;
} b2clPolygonShape;

/// A transform contains translation and rotation. It is used to represent
/// the position and orientation of rigid frames.
typedef struct b2clTransform
{
	float2 p;
	float2 q;
} b2clTransform;

/// This describes the motion of a body/shape for TOI computation.
/// Shapes are defined with respect to the body origin, which may
/// no coincide with the center of mass. However, to support dynamics
/// we must interpolate the center of mass position.
typedef struct b2clSweep
{
	float2 localCenter;	///< local center of mass position
	float2 c0, c;		///< center world positions
	float a0, a;		///< world angles

	/// Fraction of the current time step in the range [0,1]
	/// c0 and a0 are the positions at alpha0.
	float alpha0;
	float dummy;
}  b2clSweep;

/// Used for computing contact manifolds.
typedef struct b2clClipVertex
{
	float2 v;
	b2clContactID id;
} b2clClipVertex;

typedef struct clb2Velocity
{
    float vx;
    float vy;
    float w;
}clb2Velocity;

typedef struct clb2Position
{
    float cx;
    float cy;
    float a;
}clb2Position;

typedef struct clb2Contact
{
    int color;
    int indexA;
    int indexB;
    float friction;
    float2 normal;
    float invMassA;
    float invIA;
    float invMassB;
    float invIB;
}clb2Contact;

typedef struct clb2Impulse
{
    float normalImpulse1;
    float tangentImpulse1;
    
    float normalImpulse2;
    float tangentImpulse2;
}clb2Impulse;

typedef struct clb2Points
{
    float2 rA1;
    float2 rB1;
    float normalMass1;
    float tangentMass1;
    
    float2 rA2;
    float2 rB2;
    float normalMass2;
    float tangentMass2;
    
    float velocityBias1;
    float velocityBias2;
}clb2Points;

typedef struct b2clFixtureStatic
{
	float m_friction;
	float m_restitution;
	int m_last_uid;
	int dummy; 
} b2clFixtureStatic;

#define MAX_CONNECTED_BODY_INDICES 8
typedef struct b2clBodyStatic
{
	float2 m_localCenter;	///< local center of mass position
	float /*m_mass,*/ m_invMass;
	// Rotational inertia about the center of mass.
	float /*m_I,*/ m_invI;
	float m_linearDamping;
	float m_angularDamping;
	float m_gravityScale;
	float m_type;
	int m_connectedBodyIndices[MAX_CONNECTED_BODY_INDICES];
	int m_bIsBullet;
	int dummy;
} b2clBodyStatic;

typedef struct b2clBodyDynamic
{
	b2clSweep m_sweep;		// the swept motion for CCD

	float2 m_linearVelocity;
	float2 m_force;
	float m_angularVelocity;
	float m_torque;
	int m_last_uid ;
	int dummy ; 
} b2clBodyDynamic;

// Extract useful information of manifolds for position constraint solver
typedef struct clb2Manifold
{
    float2 localNormal;
    float2 localPoint;
    float2 localPoints1;
    float2 localPoints2;
    int pointCount;
    int type;
    float radiusA;
    float radiusB;
    float2 localCenterA;
    float2 localCenterB;
}clb2Manifold;

typedef struct{
    int type;
	int pointCount;
	float localPointX;
	float localPointY;
	float localNormalX;
	float localNormalY; 
	float point0X;
	float point0Y;
	float point1X;
	float point1Y; 
}clb2SDManifold;

typedef struct{
	int fixtureAIndex;
	int fixtureBIndex;
	int bodyAIndex ; 
	int bodyBIndex ; 
}clb2SDContact;

typedef struct{
	int bodyIndex ;
	float posX;
	float posY ; 
	float posAngle;
	float xfX;
	float xfY;
	float xfS;
	float xfC;
	float alpha;
	float velocityX;
	float velocityY;
	float velocityAngular; 
}clb2SDBody;

typedef struct clb2PositionSolverManifold
{
    float2 normal;
    float2 point;
    float separation;
}clb2PositionSolverManifold;

typedef struct clb2Rotation
{
    float s;
    float c;
}clb2Rotation;

typedef struct clb2Transform
{
    clb2Rotation rotation;
    float2 translation;
}clb2Transform;

typedef struct b2clMat22
{
	float ex[2];
	float ey[2];
}b2clMat22;

typedef struct b2clMat33
{
	float ex[3];
	float ey[3];
	float ez[3];
}b2clMat33;

enum b2clLimitState
{
	e_inactiveLimit,
	e_atLowerLimit,
	e_atUpperLimit,
	e_equalLimits
};

enum b2JointType
{
	e_unknownJoint,
	e_revoluteJoint,
	e_prismaticJoint,
	e_distanceJoint,
	e_pulleyJoint,
	e_mouseJoint,
	e_gearJoint,
	e_wheelJoint,
    e_weldJoint,
	e_frictionJoint,
	e_ropeJoint
};

typedef struct b2clDistanceJointDatastruct
{
	float frequencyHz;
	float dampingRatio;
	float bias;

	float localAnchorA[2];
	float localAnchorB[2];
	float gamma;
	float nlength;

	float u[2];
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	float mass;
} b2clDistanceJointData;

typedef struct b2clRevoluteJointData
{
	float localAnchorA[2];
	float localAnchorB[2];

	int enableMotor;
	float maxMotorTorque;
	float motorSpeed;

	int enableLimit;
	float referenceAngle;
	float lowerAngle;
	float upperAngle;

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat33 mass;			// effective mass for point-to-point constraint.
	float motorMass;	// effective mass for motor/limit angular constraint.
	int limitState;
} b2clRevoluteJointData;

typedef struct b2clPrismaticJointData
{
	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float localXAxisA[2];
	float localYAxisA[2];
	float referenceAngle;
	float lowerTranslation;
	float upperTranslation;
	float maxMotorForce;
	float motorSpeed;
	int enableLimit;
	int enableMotor;
	int limitState;

	// Solver temp
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	float axis[2], perp[2];
	float s1, s2;
	float a1, a2;
	b2clMat33 K;
	float motorMass;
} b2clPrismaticJointData;

typedef struct b2clGearJointData
{
	int joint1;
	int joint2;
	int typeA;
	int typeB;

	float localAnchorA[2];
	float localAnchorB[2];
	float localAnchorC[2];
	float localAnchorD[2];

	float localAxisC[2];
	float localAxisD[2];

	float referenceAngleA;
	float referenceAngleB;

	float gearConstant;
	float ratio;

	// Solver temp
	float lcA[2], lcB[2], lcC[2], lcD[2];
	float mA, mB, mC, mD;
	float iA, iB, iC, iD;
	float JvAC[2], JvBD[2];
	float JwA, JwB, JwC, JwD;
	float mass;
} b2clGearJointData;

typedef struct b2clPulleyJointData
{
	float groundAnchorA[2];
	float groundAnchorB[2];
	float lengthA;
	float lengthB;
	float localAnchorA[2];
	float localAnchorB[2]; 
	float pulleyConstant; 
	float ratio; 
	float uA[2]; 
	float uB[2]; 
	float rA[2]; 
	float rB[2]; 
	float localCenterA[2];
	float localCenterB[2]; 
	float invMassA; 
	float invMassB; 
	float invIA; 
	float invIB;
	float mass; 
}b2clPulleyJointData; 

typedef struct b2clRopeJointData
{	
	float localAnchorA[2];
	float localAnchorB[2]; 
	float maxLength; 
	float nlength;
	float u[2]; 
	float rA[2]; 
	float rB[2]; 
	float localCenterA[2];
	float localCenterB[2]; 
	float invMassA; 
	float invMassB; 
	float invIA; 
	float invIB;
	float mass; 
	int limitState; 
} b2clRopeJointData; 

typedef struct b2clWheelJointData
{
	float frequencyHz;
	float dampingRatio;

	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float localXAxisA[2];
	float localYAxisA[2];

	float maxMotorTorque;
	float motorSpeed;
	int enableMotor;

	// Solver temp
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;

	float ax[2], ay[2];
	float sAx, sBx;
	float sAy, sBy;

	float mass;
	float motorMass;
	float springMass;

	float bias;
	float gamma;
} b2clWheelJointData;

typedef struct b2clWeldJointData
{
	float frequencyHz;
	float dampingRatio;
	float bias;

	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float referenceAngle;
	float gamma;

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat33 mass;
} b2clWeldJointData;

typedef struct b2clMouseJointData
{
	float localAnchorB[2];
	float targetA[2];
	float frequencyHz;
	float dampingRatio;
	float beta;
	
	// Solver shared
	float maxForce;
	float gamma;

	// Solver temp
	float rB[2];
	float localCenterB[2];
	float invMassB;
	float invIB;
	b2clMat22 mass;
	float C[2];
} b2clMouseJointData;

typedef struct b2clFrictionJointData
{
	float localAnchorA[2];
	float localAnchorB[2];

	float maxForce; 
	float maxTorque; 

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat22 linearMass;
	float angularMass; 
} b2clFrictionJointData;

typedef struct clJoint
{
	int index;

	// impulse : 4 floats
	union a1{
		struct x1{
			float impulse[3];
		}x;
		struct y1{
			float scalarImpulse;
			float springImpulse;
		}y;
		struct z1{
			float linearImpulse[2];
			float angularImpulse;
		}z;
	}a;
	float motorImpulse;

	int color;
	int type;
	int collideConnected;

	int indexA, indexB, indexC, indexD;

	union b1{
		b2clDistanceJointData distanceJointData;
		b2clRevoluteJointData revoluteJointData;
		b2clPrismaticJointData prismaticJointData;
		b2clGearJointData gearJointData;
		b2clPulleyJointData pulleyJointData;
		b2clRopeJointData ropeJointData;
		b2clWheelJointData wheelJointData;
		b2clWeldJointData weldJointData;
		b2clMouseJointData mouseJointData;
		b2clFrictionJointData frictionJointData;
	}b;
} b2clJoint;

typedef struct
{
	int index;
    float nimpulse[4];
} b2clJointImpulseNode;

typedef struct
{
	int isCollide;
	float normal[2];
	float fraction;
	unsigned int shapeIndex;
} b2clRayCastOutput;

typedef struct
{
	float2 m_buffer[2];
	float2 m_vertices[b2cl_maxPolygonVertices];
	int m_count;
	float m_radius;
} b2clDistanceProxy;

typedef struct 
{
	float metric;		///< length or area
	short count;
	unsigned char indexA[3];	///< vertices on shape A
	unsigned char indexB[3];	///< vertices on shape B
} b2clSimplexCache;

/// Input for b2Distance.
/// You have to option to use the shape radii
/// in the computation. Even 
typedef struct 
{
	b2clDistanceProxy proxyA;
	b2clDistanceProxy proxyB;
	b2clTransform transformA;
	b2clTransform transformB;
	bool useRadii;
} b2clDistanceInput;

/// Output for b2Distance.
typedef struct
{
	float2 pointA;		///< closest point on shapeA
	float2 pointB;		///< closest point on shapeB
	float ndistance;
	int iterations;	///< number of GJK iterations used
} b2clDistanceOutput;

typedef struct
{
	b2clDistanceProxy proxyA;
	b2clDistanceProxy proxyB;
	b2clSweep sweepA;
	b2clSweep sweepB;
	float tMax;		// defines sweep interval [0, tMax]
	float dummy;
} b2clTOIInput;

enum b2clTOIOutputState
{
	e_unknown,
	e_failed,
	e_overlapped,
	e_touching,
	e_separated
};

typedef struct
{
	int state;
	float t;
} b2clTOIOutput;

typedef struct
{
	float2 wA;		// support point in proxyA
	float2 wB;		// support point in proxyB
	float2 w;		// wB - wA
	float a;		// barycentric coordinate for closest point
	int indexA;	// wA index
	int indexB;	// wB index
} b2clSimplexVertex;

typedef struct 
{
	b2clSimplexVertex m_v1, m_v2, m_v3;
	int m_count;
} b2clSimplex;

//typedef struct{
//float v[30];
//} testData; 

//==============================================================================================
// Math functions
//==============================================================================================

/// Multiply two rotations: q * r
inline float2 b2clMul_TwoRotation(const float2 q, const float2 r)
{
	// [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
	// [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]
	// s = qs * rc + qc * rs
	// c = qc * rc - qs * rs
	float2 qr;
	qr.x = q.x * r.y + q.y * r.x;
	qr.y = q.y * r.y - q.x * r.x;
	return qr;
}

/// Transpose multiply two rotations: qT * r
inline float2 b2clMulT_TwoRotation(const float2 q, const float2 r)
{
	// [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
	// [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]
	// s = qc * rs - qs * rc
	// c = qc * rc + qs * rs
	float2 qr;
	qr.x = q.y * r.x - q.x * r.y;
	qr.y = q.y * r.y + q.x * r.x;
	return qr;
}

/// Rotate a vector
inline float2 b2clMul_Rotate(const float2 q, const float2 v)
{
	float2 result;
	result.x = q.y * v.x - q.x * v.y;
	result.y = q.x * v.x + q.y * v.y;

	return result;
}

/// Inverse rotate a vector
inline float2 b2clMulT_Rotate(const float2 q, const float2 v)
{
	float2 result;
	result.x = q.y * v.x + q.x * v.y;
	result.y = -q.x * v.x + q.y * v.y;

	return result;
}

/// Transform a vector
inline float2 b2clMul_Transform(const b2clTransform *T, const float2 v)
{
	float2 result;
	result.x = (T->q.y * v.x - T->q.x * v.y) + T->p.x;
	result.y = (T->q.x * v.x + T->q.y * v.y) + T->p.y;

	return result;
}

/// Invert transform a vector
inline float2 b2clMulT_Transform(const b2clTransform *T, const float2 v)
{
	float px = v.x - T->p.x;
	float py = v.y - T->p.y;
	float2 result;
	result.x = (T->q.y * px + T->q.x * py);
	result.y = (-T->q.x * px + T->q.y * py);

	return result;
}

// v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
//    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
inline b2clTransform b2clMul_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
	b2clTransform C;
	C.q = b2clMul_TwoRotation(A->q, B->q);
	C.p = b2clMul_TwoRotation(A->q, B->p) + A->p;
	return C;
}

// v2 = A.q' * (B.q * v1 + B.p - A.p)
//    = A.q' * B.q * v1 + A.q' * (B.p - A.p)
inline b2clTransform b2clMulT_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
	b2clTransform C;
	C.q = b2clMulT_TwoRotation(A->q, B->q);
	C.p = b2clMulT_TwoRotation(A->q, B->p - A->p);
	return C;
}

/// Perform the dot product on two vectors.
inline float b2clDot(const float2 a, const float2 b)
{
	return a.x * b.x + a.y * b.y;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float b2clCross_VV(const float2 a, const float2 b)
{
	return a.x * b.y - a.y * b.x;
}

/// Perform the cross product on a vector and a scalar. In 2D this produces
/// a vector.
inline float2 b2clCross_VS(const float2 a, float s)
{
	return (float2)(s * a.y, -s *a.x);
}

/// Perform the cross product on a scalar and a vector. In 2D this produces
/// a vector.
inline float2 b2clCross_SV(float s, const float2 a)
{
	return (float2)(-s * a.y, s * a.x);
}

inline float b2clClamp(float a, float low, float high)
{
	return max(low, min(a, high));
}

inline float2 b2clMin(const float2 a, const float2 b)
{
	return (float2)(min(a.x, b.x), min(a.y, b.y));
}

inline float2 b2clMax(const float2 a, const float2 b)
{
	return (float2)(max(a.x, b.x), max(a.y, b.y));
}

inline float b2clDistanceSquared(const float2 a, const float2 b)
{
	float2 c = a - b;
	return b2clDot(c, c);
}

inline float b2clDistance(const float2 a, const float2 b)
{
	float2 c = a - b;
	return sqrt(b2clDot(c, c));
}

inline float b2clLengthSquared(const float2 v)
{
	return b2clDot(v, v);
}

inline float b2clAbs(float a)
{
	return a > 0.0f ? a : -a;
}

/// Perform the dot product on two vectors.
inline float b2clDot3(const float3 a, const float3 b)
{
	return a.x * b.x + a.y * b.y + a.z * b.z;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float3 b2clCross3_VV(const float3 a, const float3 b)
{
	return (float3)(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float3 b2clMat33Solve(const b2clMat33 mat, const float3 b)
{
	float3 ex = (float3)(mat.ex[0], mat.ex[1], mat.ex[2]);
	float3 ey = (float3)(mat.ey[0], mat.ey[1], mat.ey[2]);
	float3 ez = (float3)(mat.ez[0], mat.ez[1], mat.ez[2]);

	float det = b2clDot3(ex, b2clCross3_VV(ey, ez));

	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float3 x;
	x.x = det * b2clDot3(b, b2clCross3_VV(ey, ez));
	x.y = det * b2clDot3(ex, b2clCross3_VV(b, ez));
	x.z = det * b2clDot3(ex, b2clCross3_VV(ey, b));
	return x;
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float2 b2clMat33Solve22(const b2clMat33 mat, const float2 b)
{
	float2 ex = (float2)(mat.ex[0], mat.ex[1]);
	float2 ey = (float2)(mat.ey[0], mat.ey[1]);

	float det = ex.x * ey.y - ey.x * ex.y;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float2 x;
	x.x = det * (ey.y * b.x - ey.x * b.y);
	x.y = det * (ex.x * b.y - ex.y * b.x);
	return x;
}

inline float2 b2clMat22Solve(const b2clMat22 mat, const float2 b)
{
	float2 ex = (float2)(mat.ex[0], mat.ex[1]);
	float2 ey = (float2)(mat.ey[0], mat.ey[1]);

	float det = ex.x * ey.y - ey.x * ex.y;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float2 x;
	x.x = det * (ey.y * b.x - ey.x * b.y);
	x.y = det * (ex.x * b.y - ex.y * b.x);
	return x;
}

inline float2 b2clMat33Mul22(const b2clMat33 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float2 b2clMat22Mul(const b2clMat22 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline void b2clGetInverse22(const b2clMat33 in, b2clMat33* out)
{
	float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
	float det = a * d - b * c;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}

	out->ex[0] =  det * d;	out->ey[0] = -det * b; out->ex[2] = 0.0f;
	out->ex[1] = -det * c;	out->ey[1] =  det * a; out->ey[2] = 0.0f;
	out->ez[0] = 0.0f; out->ez[1] = 0.0f; out->ez[2] = 0.0f;
}

inline void b2clGetSymInverse33(const b2clMat33 in, b2clMat33* out)
{
	//float det = b2clDot(ex, b2clCross(ey, ez));
	float det = in.ex[0] * (in.ey[1] * in.ez[2] - in.ey[2] * in.ez[1]) 
		+ in.ex[1] * (in.ey[2] * in.ez[0] - in.ey[0] * in.ez[2]) 
		+ in.ex[2] * (in.ey[0] * in.ez[1] - in.ey[1] * in.ez[0]);

	if (det != 0.0f)
	{
		det = 1.0f / det;
	}

	float a11 = in.ex[0], a12 = in.ey[0], a13 = in.ez[0];
	float a22 = in.ey[1], a23 = in.ez[1];
	float a33 = in.ez[2];

	out->ex[0] = det * (a22 * a33 - a23 * a23);
	out->ex[1] = det * (a13 * a23 - a12 * a33);
	out->ex[2] = det * (a12 * a23 - a13 * a22);

	out->ey[0] = out->ex[1];
	out->ey[1] = det * (a11 * a33 - a13 * a13);
	out->ey[2] = det * (a13 * a12 - a11 * a23);

	out->ez[0] = out->ex[2];
	out->ez[1] = out->ey[2];
	out->ez[2] = det * (a11 * a22 - a12 * a12);
}

inline float2 b2clMat33MulV2(const b2clMat33 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float3 b2clMat33MulV3(const b2clMat33 A, const float3 v)
{
	//return v.x * A.ex + v.y * A.ey + v.z * A.ez;
	return (float3)(A.ex[0] * v.x + A.ey[0] * v.y + A.ez[0] * v.z,
		A.ex[1] * v.x + A.ey[1] * v.y + A.ez[1] * v.z,
		A.ex[2] * v.x + A.ey[2] * v.y + A.ez[2] * v.z);
}

inline void b2clMat22GetInverse(const b2clMat22 in, b2clMat22* out)
{
	float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
	float det = a * d - b * c;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	out->ex[0] =  det * d;	out->ey[0] = -det * b;
	out->ex[1] = -det * c;	out->ey[1] =  det * a;
}

inline void b2clSweepNormalize(b2clSweep* sweep)
{
	float twoPi = 2.0f * b2_pi;
	float d =  twoPi * floor(sweep->a0 / twoPi);
	sweep->a0 -= d;
	sweep->a -= d;
}

inline void b2clSweepGetTransform(b2clSweep* sweep, b2clTransform* xf, float beta)
{
	xf->p = (1.0f - beta) * sweep->c0 + beta * sweep->c;
	float angle = (1.0f - beta) * sweep->a0 + beta * sweep->a;
	xf->q.x = sin(angle);
	xf->q.y = cos(angle);

	// Shift to origin
	xf->p -= b2clMul_Rotate(xf->q, sweep->localCenter);
}

inline void b2clSweepAdvance(b2clSweep* sweep, float alpha)
{
	float beta = (alpha - sweep->alpha0) / (1.0f - sweep->alpha0);
	sweep->c0 = (1.0f - beta) * sweep->c0 + beta * sweep->c;
	sweep->a0 = (1.0f - beta) * sweep->a0 + beta * sweep->a;
	sweep->alpha0 = alpha;
}
inline void b2clBodySweepAdvance (b2clBodyDynamic* body, b2clTransform* xf, float alpha) {
	b2clSweepAdvance(&(body->m_sweep), alpha); 
	body->m_sweep.c = body->m_sweep.c0;
	body->m_sweep.a = body->m_sweep.a0;
    xf->q.x = sin (body->m_sweep.a);
	xf->q.y = cos (body->m_sweep.a); 
	xf->p = body->m_sweep.c - b2clMul_Rotate(xf->q, body->m_sweep.localCenter);
}

inline void b2clDistanceProxySet(b2clDistanceProxy* proxy, const b2clPolygonShape* shape)
{
	proxy->m_count = shape->m_vertexCount;
	proxy->m_radius = shape->m_radius;
	for (int i = 0; i < shape->m_vertexCount; ++i)
	{
		proxy->m_vertices[i] = shape->m_vertices[i];
	}
}

inline int b2clDistanceProxyGetSupport(const b2clDistanceProxy* proxy, float2 d)
{
	int bestIndex = 0;
	float bestValue = b2clDot(proxy->m_vertices[0], d);
	for (int i = 1; i < proxy->m_count; ++i)
	{
		float value = b2clDot(proxy->m_vertices[i], d);
		if (value > bestValue)
		{
			bestIndex = i;
			bestValue = value;
		}
	}
	return bestIndex;
}

inline float2 b2clDistanceProxyGetVertex(const b2clDistanceProxy* proxy, int index)
{
	return proxy->m_vertices[index];
}

// Convert a vector into a unit vector. Returns the length.
inline float b2clNormalize(float2* v)
{
	float length = sqrt(b2clDot(*v, *v));
	if (length < b2_epsilon)
	{
		return 0.0f;
	}
	float invLength = 1.0f / length;
	(*v).x *= invLength;
	(*v).y *= invLength;

	return length;
}

/*
inline float cos_wrapper(float a)
{
	//float sina = sin(a);
	//return sqrt(1-sina*sina);

	//return sin(1.5707963268-a);

	return cos(a);
}
*/

//#include <Box2D/Common/OpenCL/b2CLTypeDefOCL.h>

//==============================================================================================
// Sub-functions
//==============================================================================================

// Find the separation between poly1 and poly2 for a give edge normal on poly1.
static float b2clEdgeSeparation(const b2clPolygonShape* poly1, const b2clTransform* xf1, int edge1,
							  const b2clPolygonShape* poly2, const b2clTransform* xf2, float4 *test)
{
	const float2* vertices1 = poly1->m_vertices;
	const float2* normals1 = poly1->m_normals;

	int count2 = poly2->m_vertexCount;
	const float2* vertices2 = poly2->m_vertices;

	//b2Assert(0 <= edge1 && edge1 < poly1->m_vertexCount);

	// Convert normal from poly1's frame into poly2's frame.
	float2 normal1World = b2clMul_Rotate(xf1->q, normals1[edge1]);
	float2 normal1 = b2clMulT_Rotate(xf2->q, normal1World);

	// Find support vertex on poly2 for -normal.
	int index = 0;
	float minDot = MAXFLOAT;

	for (int i = 0; i < count2; ++i)
	{
		float dotProduct = dot(vertices2[i], normal1);
		if (dotProduct < minDot)
		{
			minDot = dotProduct;
			index = i;
		}
	}

	float2 v1 = b2clMul_Transform(xf1, vertices1[edge1]);
	float2 v2 = b2clMul_Transform(xf2, vertices2[index]);
	float separation = dot(v2 - v1, normal1World);
	(*test).xy = vertices2[index];
	(*test).zw = index;
	return separation;
}

// Find the max separation between poly1 and poly2 using edge normals from poly1.
float b2clFindMaxSeparation(int* edgeIndex,
							const b2clPolygonShape* poly1, const b2clTransform* xf1,
							const b2clPolygonShape* poly2, const b2clTransform* xf2,
							float4 *test)
{
	int count1 = poly1->m_vertexCount;
	const float2* normals1 = poly1->m_normals;

	// Vector pointing from the centroid of poly1 to the centroid of poly2.
	float2 d = b2clMul_Transform(xf2, poly2->m_centroid) - b2clMul_Transform(xf1, poly1->m_centroid);
	float2 dLocal1 = b2clMulT_Rotate(xf1->q, d);

	(*test).x = poly1->m_centroid.x;
	(*test).y = poly1->m_centroid.y;
	(*test).z = poly2->m_centroid.x;
	(*test).w = poly2->m_centroid.y;

	// Find edge normal on poly1 that has the largest projection onto d.
	int edge = 0;
	float maxDot = -MAXFLOAT;
	for (int i = 0; i < count1; ++i)
	{
		float dotProduct = dot(normals1[i], dLocal1);
		if (dotProduct > maxDot)
		{
			maxDot = dotProduct;
			edge = i;
		}
	}

	float4 temp;
	// Get the separation for the edge normal.
	float s = b2clEdgeSeparation(poly1, xf1, edge, poly2, xf2, &temp);

	// Check the separation for the previous edge normal.
	int prevEdge = edge - 1 >= 0 ? edge - 1 : count1 - 1;
	float sPrev = b2clEdgeSeparation(poly1, xf1, prevEdge, poly2, xf2, &temp);

	// Check the separation for the next edge normal.
	int nextEdge = edge + 1 < count1 ? edge + 1 : 0;
	float sNext = b2clEdgeSeparation(poly1, xf1, nextEdge, poly2, xf2, &temp);

	// Find the best edge and the search direction.
	int bestEdge;
	float bestSeparation;
	int increment;
	if (sPrev > s && sPrev > sNext)
	{
		increment = -1;
		bestEdge = prevEdge;
		bestSeparation = sPrev;
	}
	else if (sNext > s)
	{
		increment = 1;
		bestEdge = nextEdge;
		bestSeparation = sNext;
	}
	else
	{
		*edgeIndex = edge;
		return s;
	}

	// Perform a local search for the best edge normal.
	for ( ; ; )
	{
		if (increment == -1)
			edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
		else
			edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;

		s = b2clEdgeSeparation(poly1, xf1, edge, poly2, xf2, &temp);

		if (s > bestSeparation)
		{
			bestEdge = edge;
			bestSeparation = s;
		}
		else
		{
			break;
		}
	}

	*edgeIndex = bestEdge;

	return bestSeparation;
}

static void b2clFindIncidentEdge(b2clClipVertex c[2],
							 const b2clPolygonShape* poly1, const b2clTransform* xf1, int edge1,
							 const b2clPolygonShape* poly2, const b2clTransform* xf2)
{
	const float2* normals1 = poly1->m_normals;

	int count2 = poly2->m_vertexCount;
	const float2* vertices2 = poly2->m_vertices;
	const float2* normals2 = poly2->m_normals;

	//b2Assert(0 <= edge1 && edge1 < poly1->m_vertexCount);

	// Get the normal of the reference edge in poly2's frame.
	float2 normal1 = b2clMulT_Rotate(xf2->q, b2clMul_Rotate(xf1->q, normals1[edge1]));

	// Find the incident edge on poly2.
	int index = 0;
	float minDot = MAXFLOAT;
	for (int i = 0; i < count2; ++i)
	{
		float dotProduct = dot(normal1, normals2[i]);
		if (dotProduct < minDot)
		{
			minDot = dotProduct;
			index = i;
		}
	}

	// Build the clip vertices for the incident edge.
	int i1 = index;
	int i2 = i1 + 1 < count2 ? i1 + 1 : 0;

	c[0].v = b2clMul_Transform(xf2, vertices2[i1]);
	c[0].id.cf.indexA = (uint)edge1;
	c[0].id.cf.indexB = (uint)i1;
	c[0].id.cf.typeA = 1;
	c[0].id.cf.typeB = 0;

	c[1].v = b2clMul_Transform(xf2, vertices2[i2]);
	c[1].id.cf.indexA = (uint)edge1;
	c[1].id.cf.indexB = (uint)i2;
	c[1].id.cf.typeA = 1;
	c[1].id.cf.typeB = 0;
}

// Sutherland-Hodgman clipping.
int b2clClipSegmentToLine(b2clClipVertex vOut[2], const b2clClipVertex vIn[2],
							const float2 normal, float offset, int vertexIndexA)
{
	// Start with no output points
	int numOut = 0;

	// Calculate the distance of end points to the line
	float distance0 = dot(normal, vIn[0].v) - offset;
	float distance1 = dot(normal, vIn[1].v) - offset;

	// If the points are behind the plane
	if (distance0 <= 0.0f) vOut[numOut++] = vIn[0];
	if (distance1 <= 0.0f) vOut[numOut++] = vIn[1];

	// If the points are on different sides of the plane
	if (distance0 * distance1 < 0.0f)
	{
		// Find intersection point of edge and plane
		float interp = distance0 / (distance0 - distance1);
		vOut[numOut].v = vIn[0].v + interp * (vIn[1].v - vIn[0].v);

		// VertexA is hitting edgeB.
		vOut[numOut].id.cf.indexA = vertexIndexA;
		vOut[numOut].id.cf.indexB = vIn[0].id.cf.indexB;
		vOut[numOut].id.cf.typeA = 0;
		vOut[numOut].id.cf.typeB = 1;
		++numOut;
	}

	return numOut;
}

//==============================================================================================
// Main kernel function
//==============================================================================================

// Find edge normal of max separation on A - return if separating axis is found
// Find edge normal of max separation on B - return if separation axis is found
// Choose reference edge as min(minA, minB)
// Find incident edge
// Clip

// The normal points from 1 to 2
__kernel void b2clCollidePolygons(__global b2clManifold* manifolds, // output
					  const __global b2clPolygonShape* polyGlobal, const __global b2clTransform* xfGlobal,
					  const __global int4* indices,
					  const int contactNum)
{
    unsigned int i = get_global_id(0);

	if (i>=contactNum)
		return;

	b2clManifold manifold;

	manifold.pointCount = 0;
	int type;

	int4 index;
	b2clPolygonShape polyA, polyB;
	b2clTransform xfA, xfB;

	index = indices[i];
	polyA = polyGlobal[index.x];
	polyB = polyGlobal[index.y];
	xfA = xfGlobal[index.z];
	xfB = xfGlobal[index.w];

	float totalRadius = polyA.m_radius + polyB.m_radius;

	float4 test;

	int edgeA = 0;
	float separationA = b2clFindMaxSeparation(&edgeA, &polyA, &xfA, &polyB, &xfB, &test);

	if (separationA > totalRadius)
	{
		manifolds[i] = manifold;
		return;
	}

	int edgeB = 0;
	float separationB = b2clFindMaxSeparation(&edgeB, &polyB, &xfB, &polyA, &xfA, &test);
	if (separationB > totalRadius)
	{
		manifolds[i] = manifold;
		return;
	}

	const b2clPolygonShape* poly1;	// reference polygon
	const b2clPolygonShape* poly2;	// incident polygon
	b2clTransform *xf1, *xf2;
	int edge1;		// reference edge
	uint flip;
	const float k_relativeTol = 0.98f;
	const float k_absoluteTol = 0.001f;

	if (separationB > k_relativeTol * separationA + k_absoluteTol)
	{
		poly1 = &polyB;
		poly2 = &polyA;
		xf1 = &xfB;
		xf2 = &xfA;
		edge1 = edgeB;
		manifold.type = 2;
		flip = 1;
	}
	else
	{
		poly1 = &polyA;
		poly2 = &polyB;
		xf1 = &xfA;
		xf2 = &xfB;
		edge1 = edgeA;
		manifold.type = 1;
		flip = 0;
	}

	b2clClipVertex incidentEdge[2];
	b2clFindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);

	int count1 = poly1->m_vertexCount;
	const float2* vertices1 = poly1->m_vertices;

	int iv1 = edge1;
	int iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;

	float2 v11 = vertices1[iv1];
	float2 v12 = vertices1[iv2];

	float2 localTangent = v12 - v11;
	localTangent = normalize(localTangent);
	
	float2 localNormal = b2clCross_VS(localTangent, 1.0f);
	float2 planePoint = 0.5f * (v11 + v12);

	float2 tangent = b2clMul_Rotate(xf1->q, localTangent);
	float2 normal = b2clCross_VS(tangent, 1.0f);
	
	v11 = b2clMul_Transform(xf1, v11);
	v12 = b2clMul_Transform(xf1, v12);

	// Face offset.
	float frontOffset = dot(normal, v11);

	// Side offsets, extended by polytope skin thickness.
	float sideOffset1 = -dot(tangent, v11) + totalRadius;
	float sideOffset2 = dot(tangent, v12) + totalRadius;

	// Clip incident edge against extruded edge1 side edges.
	b2clClipVertex clipPoints1[2];
	b2clClipVertex clipPoints2[2];
	int np;

	// Clip to box side 1
	np = b2clClipSegmentToLine(clipPoints1, incidentEdge, -tangent, sideOffset1, iv1);

	if (np < 2)
	{
		manifolds[i] = manifold;
		return;
	}

	// Clip to negative box side 1
	np = b2clClipSegmentToLine(clipPoints2, clipPoints1,  tangent, sideOffset2, iv2);

	if (np < 2)
	{
		manifolds[i] = manifold;
		return;
	}

	// Now clipPoints2 contains the clipped points.
	manifold.localNormal = localNormal;
	manifold.localPoint = planePoint;

	int pointCount = 0;
	for (int k = 0; k < b2cl_maxManifoldPoints; ++k)
	{
		float separation = dot(normal, clipPoints2[k].v) - frontOffset;

		if (separation <= totalRadius)
		{
			b2clManifoldPoint* cp = manifold.points + pointCount;
			cp->localPoint = b2clMulT_Transform(xf2, clipPoints2[k].v);
			cp->id = clipPoints2[k].id;
			if (flip)
			{
				// Swap features
				b2clContactFeature cf = cp->id.cf;
				cp->id.cf.indexA = cf.indexB;
				cp->id.cf.indexB = cf.indexA;
				cp->id.cf.typeA = cf.typeB;
				cp->id.cf.typeB = cf.typeA;
			}
			++pointCount;
		}
	}

	manifold.pointCount = pointCount;

	for (int k = 0; k < manifold.pointCount; ++k)
	{
		b2clManifoldPoint* mp2 = manifold.points + k;
		mp2->normalImpulse = 0.0f;
		mp2->tangentImpulse = 0.0f;
		int key2 = mp2->id.key;

		b2clManifold oldManifold = manifolds[i];
		for (int j = 0; j < oldManifold.pointCount; ++j)
		{
			b2clManifoldPoint* mp1 = oldManifold.points + j;

			if (mp1->id.key == key2)
			{
				mp2->normalImpulse = mp1->normalImpulse;
				mp2->tangentImpulse = mp1->tangentImpulse;
				break;
			}
		}
		//manifold.test.x = oldManifold.pointCount;
	}

	manifolds[i] = manifold;
}

__kernel void b2clCollideCircles(__global b2clManifold* manifolds, // output
					  const __global b2clPolygonShape* polyGlobal, const __global b2clTransform* xfGlobal,
					  const __global int4* global_indices,
					  const __global int* pair_indices,
					  const int maxContactNum,
					  const int contactNum)
{
    unsigned int i = get_global_id(0);

	if (i>=contactNum)
		return;

	b2clManifold manifold/* = manifolds[i]*/;

	manifold.pointCount = 0;
	int type;

	int pair_index;
	int4 index;
	b2clPolygonShape circleA, circleB;
	b2clTransform xfA, xfB;

	pair_index = pair_indices[i]; // 0 is contact type for circle-circle
	index = global_indices[pair_index];
	circleA = polyGlobal[index.x];
	circleB = polyGlobal[index.y];
	xfA = xfGlobal[index.z];
	xfB = xfGlobal[index.w];

	float totalRadius = circleA.m_radius + circleB.m_radius;
	// Vector pointing from the centroid of poly1 to the centroid of poly2.
	float2 d = b2clMul_Transform(&xfA, circleA.m_centroid) - b2clMul_Transform(&xfB, circleB.m_centroid);
	float distSqr = b2clDot(d, d);

	if (distSqr > totalRadius * totalRadius)
	{
		manifolds[pair_index] = manifold;
		return;
	}

	manifold.type = 0; // b2Manifold::e_circles
	manifold.localPoint = circleA.m_centroid;
	manifold.localNormal = 0;
	manifold.pointCount = 1;

	manifold.points[0].localPoint = circleB.m_centroid;
	manifold.points[0].id.key = 0;

	manifolds[pair_index] = manifold;
}

__kernel void b2clCompactForOneContact(
					const __global int *CompactIn_data, // input
					__global int *CompactOut_data, // output
					__global int *numValidData // output
					)
{
	*numValidData = CompactIn_data[0];
	if (*numValidData)
		CompactOut_data[0] = 0;
}/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/



/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/


#pragma OPENCL EXTENSION cl_amd_printf : enable

/// The maximum number of contact points between two convex shapes. Do
/// not change this value.
#define b2cl_maxManifoldPoints	2

/// The maximum number of vertices on a convex polygon. You cannot increase
/// this too much because b2BlockAllocator has a maximum object size.
#define b2cl_maxPolygonVertices	8

/// A velocity threshold for elastic collisions. Any collision with a relative linear
/// velocity below this threshold will be treated as inelastic.
//#define b2cl_velocityThreshold		0.01f
#define b2cl_velocityThreshold		1.0f

/// This is used to fatten AABBs in the dynamic tree. This is used to predict
/// the future position based on the current displacement.
/// This is a dimensionless multiplier.
#define b2cl_aabbMultiplier		2.0f

#define	b2_maxFloat	FLT_MAX
#define	b2_epsilon FLT_EPSILON
#define b2_pi 3.14159265359f
#define b2_maxTranslation 2.0f
#define b2_maxRotation 0.5f*b2_pi
#define b2_baumgarte 0.2f
#define b2_linearSlop 0.005f
#define b2_angularSlop			(2.0f / 180.0f * b2_pi)
#define b2_polygonRadius		(2.0f * b2_linearSlop)
#define b2_maxLinearCorrection 0.2f
#define b2_maxAngularCorrection		(8.0f / 180.0f * b2_pi)

#ifndef MAXFLOAT
#define MAXFLOAT      3.402823466e+38F
#endif


/// The features that intersect to form the contact point
/// This must be 4 bytes or less.
typedef struct b2clContactFeature
{
	uchar indexA;		///< Feature index on shapeA
	uchar indexB;		///< Feature index on shapeB
	uchar typeA;		///< The feature type on shapeA
	uchar typeB;		///< The feature type on shapeB
} b2clContactFeature;

/// Contact ids to facilitate warm starting.
typedef union b2clContactID
{
	b2clContactFeature cf;
	uint key;					///< Used to quickly compare contact ids.
} b2clContactID;

/// A manifold point is a contact point belonging to a contact
/// manifold. It holds details related to the geometry and dynamics
/// of the contact points.
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleB
/// -e_faceA: the local center of cirlceB or the clip point of polygonB
/// -e_faceB: the clip point of polygonA
/// This structure is stored across time steps, so we keep it small.
/// Note: the impulses are used for internal caching and may not
/// provide reliable contact forces, especially for high speed collisions.
typedef struct b2clManifoldPoint
{
	float2 localPoint;		///< usage depends on manifold type
	float normalImpulse;	///< the non-penetration impulse
	float tangentImpulse;	///< the friction impulse
	b2clContactID id;			///< uniquely identifies a contact point between two shapes
	float dummy; // for alignment
} b2clManifoldPoint;

/// A manifold for two touching convex shapes.
/// Box2D supports multiple types of contact:
/// - clip point versus plane with radius
/// - point versus point with radius (circles)
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleA
/// -e_faceA: the center of faceA
/// -e_faceB: the center of faceB
/// Similarly the local normal usage:
/// -e_circles: not used
/// -e_faceA: the normal on polygonA
/// -e_faceB: the normal on polygonB
/// We store contacts in this way so that position correction can
/// account for movement, which is critical for continuous physics.
/// All contact scenarios must be expressed in one of these types.
/// This structure is stored across time steps, so we keep it small.
typedef struct b2clManifold
{
	float2 localNormal;								///< not use for Type::e_points
	float2 localPoint;								///< usage depends on manifold type
	b2clManifoldPoint points[b2cl_maxManifoldPoints];	///< the points of contact
	int type;
	int pointCount;								///< the number of manifold points
	//float2 test;
} b2clManifold;

typedef struct b2clFilter
{
	unsigned short categoryBits;
	unsigned short maskBits;
	short groupIndex;
	short dummy;
} b2clFilter;

/// A convex polygon. It is assumed that the interior of the polygon is to
/// the left of each edge.
/// Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.
/// In most cases you should not need many vertices for a convex polygon.
//////////////
/// We reuse b2clPolygonShape for b2clCircleShape
/// We may have to change this later
typedef struct b2clPolygonShape
{
	float2 m_centroid;
	float2 m_vertices[b2cl_maxPolygonVertices];
	float2 m_normals[b2cl_maxPolygonVertices];
	int m_type;
	float m_radius;
	int m_vertexCount;
	int m_bIsSensor;
	b2clFilter m_filter;
} b2clPolygonShape;

/// A transform contains translation and rotation. It is used to represent
/// the position and orientation of rigid frames.
typedef struct b2clTransform
{
	float2 p;
	float2 q;
} b2clTransform;

/// This describes the motion of a body/shape for TOI computation.
/// Shapes are defined with respect to the body origin, which may
/// no coincide with the center of mass. However, to support dynamics
/// we must interpolate the center of mass position.
typedef struct b2clSweep
{
	float2 localCenter;	///< local center of mass position
	float2 c0, c;		///< center world positions
	float a0, a;		///< world angles

	/// Fraction of the current time step in the range [0,1]
	/// c0 and a0 are the positions at alpha0.
	float alpha0;
	float dummy;
}  b2clSweep;

/// Used for computing contact manifolds.
typedef struct b2clClipVertex
{
	float2 v;
	b2clContactID id;
} b2clClipVertex;

typedef struct clb2Velocity
{
    float vx;
    float vy;
    float w;
}clb2Velocity;

typedef struct clb2Position
{
    float cx;
    float cy;
    float a;
}clb2Position;

typedef struct clb2Contact
{
    int color;
    int indexA;
    int indexB;
    float friction;
    float2 normal;
    float invMassA;
    float invIA;
    float invMassB;
    float invIB;
}clb2Contact;

typedef struct clb2Impulse
{
    float normalImpulse1;
    float tangentImpulse1;
    
    float normalImpulse2;
    float tangentImpulse2;
}clb2Impulse;

typedef struct clb2Points
{
    float2 rA1;
    float2 rB1;
    float normalMass1;
    float tangentMass1;
    
    float2 rA2;
    float2 rB2;
    float normalMass2;
    float tangentMass2;
    
    float velocityBias1;
    float velocityBias2;
}clb2Points;

typedef struct b2clFixtureStatic
{
	float m_friction;
	float m_restitution;
	int m_last_uid;
	int dummy; 
} b2clFixtureStatic;

#define MAX_CONNECTED_BODY_INDICES 8
typedef struct b2clBodyStatic
{
	float2 m_localCenter;	///< local center of mass position
	float /*m_mass,*/ m_invMass;
	// Rotational inertia about the center of mass.
	float /*m_I,*/ m_invI;
	float m_linearDamping;
	float m_angularDamping;
	float m_gravityScale;
	float m_type;
	int m_connectedBodyIndices[MAX_CONNECTED_BODY_INDICES];
	int m_bIsBullet;
	int dummy;
} b2clBodyStatic;

typedef struct b2clBodyDynamic
{
	b2clSweep m_sweep;		// the swept motion for CCD

	float2 m_linearVelocity;
	float2 m_force;
	float m_angularVelocity;
	float m_torque;
	int m_last_uid ;
	int dummy ; 
} b2clBodyDynamic;

// Extract useful information of manifolds for position constraint solver
typedef struct clb2Manifold
{
    float2 localNormal;
    float2 localPoint;
    float2 localPoints1;
    float2 localPoints2;
    int pointCount;
    int type;
    float radiusA;
    float radiusB;
    float2 localCenterA;
    float2 localCenterB;
}clb2Manifold;

typedef struct{
    int type;
	int pointCount;
	float localPointX;
	float localPointY;
	float localNormalX;
	float localNormalY; 
	float point0X;
	float point0Y;
	float point1X;
	float point1Y; 
}clb2SDManifold;

typedef struct{
	int fixtureAIndex;
	int fixtureBIndex;
	int bodyAIndex ; 
	int bodyBIndex ; 
}clb2SDContact;

typedef struct{
	int bodyIndex ;
	float posX;
	float posY ; 
	float posAngle;
	float xfX;
	float xfY;
	float xfS;
	float xfC;
	float alpha;
	float velocityX;
	float velocityY;
	float velocityAngular; 
}clb2SDBody;

typedef struct clb2PositionSolverManifold
{
    float2 normal;
    float2 point;
    float separation;
}clb2PositionSolverManifold;

typedef struct clb2Rotation
{
    float s;
    float c;
}clb2Rotation;

typedef struct clb2Transform
{
    clb2Rotation rotation;
    float2 translation;
}clb2Transform;

typedef struct b2clMat22
{
	float ex[2];
	float ey[2];
}b2clMat22;

typedef struct b2clMat33
{
	float ex[3];
	float ey[3];
	float ez[3];
}b2clMat33;

enum b2clLimitState
{
	e_inactiveLimit,
	e_atLowerLimit,
	e_atUpperLimit,
	e_equalLimits
};

enum b2JointType
{
	e_unknownJoint,
	e_revoluteJoint,
	e_prismaticJoint,
	e_distanceJoint,
	e_pulleyJoint,
	e_mouseJoint,
	e_gearJoint,
	e_wheelJoint,
    e_weldJoint,
	e_frictionJoint,
	e_ropeJoint
};

typedef struct b2clDistanceJointDatastruct
{
	float frequencyHz;
	float dampingRatio;
	float bias;

	float localAnchorA[2];
	float localAnchorB[2];
	float gamma;
	float nlength;

	float u[2];
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	float mass;
} b2clDistanceJointData;

typedef struct b2clRevoluteJointData
{
	float localAnchorA[2];
	float localAnchorB[2];

	int enableMotor;
	float maxMotorTorque;
	float motorSpeed;

	int enableLimit;
	float referenceAngle;
	float lowerAngle;
	float upperAngle;

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat33 mass;			// effective mass for point-to-point constraint.
	float motorMass;	// effective mass for motor/limit angular constraint.
	int limitState;
} b2clRevoluteJointData;

typedef struct b2clPrismaticJointData
{
	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float localXAxisA[2];
	float localYAxisA[2];
	float referenceAngle;
	float lowerTranslation;
	float upperTranslation;
	float maxMotorForce;
	float motorSpeed;
	int enableLimit;
	int enableMotor;
	int limitState;

	// Solver temp
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	float axis[2], perp[2];
	float s1, s2;
	float a1, a2;
	b2clMat33 K;
	float motorMass;
} b2clPrismaticJointData;

typedef struct b2clGearJointData
{
	int joint1;
	int joint2;
	int typeA;
	int typeB;

	float localAnchorA[2];
	float localAnchorB[2];
	float localAnchorC[2];
	float localAnchorD[2];

	float localAxisC[2];
	float localAxisD[2];

	float referenceAngleA;
	float referenceAngleB;

	float gearConstant;
	float ratio;

	// Solver temp
	float lcA[2], lcB[2], lcC[2], lcD[2];
	float mA, mB, mC, mD;
	float iA, iB, iC, iD;
	float JvAC[2], JvBD[2];
	float JwA, JwB, JwC, JwD;
	float mass;
} b2clGearJointData;

typedef struct b2clPulleyJointData
{
	float groundAnchorA[2];
	float groundAnchorB[2];
	float lengthA;
	float lengthB;
	float localAnchorA[2];
	float localAnchorB[2]; 
	float pulleyConstant; 
	float ratio; 
	float uA[2]; 
	float uB[2]; 
	float rA[2]; 
	float rB[2]; 
	float localCenterA[2];
	float localCenterB[2]; 
	float invMassA; 
	float invMassB; 
	float invIA; 
	float invIB;
	float mass; 
}b2clPulleyJointData; 

typedef struct b2clRopeJointData
{	
	float localAnchorA[2];
	float localAnchorB[2]; 
	float maxLength; 
	float nlength;
	float u[2]; 
	float rA[2]; 
	float rB[2]; 
	float localCenterA[2];
	float localCenterB[2]; 
	float invMassA; 
	float invMassB; 
	float invIA; 
	float invIB;
	float mass; 
	int limitState; 
} b2clRopeJointData; 

typedef struct b2clWheelJointData
{
	float frequencyHz;
	float dampingRatio;

	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float localXAxisA[2];
	float localYAxisA[2];

	float maxMotorTorque;
	float motorSpeed;
	int enableMotor;

	// Solver temp
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;

	float ax[2], ay[2];
	float sAx, sBx;
	float sAy, sBy;

	float mass;
	float motorMass;
	float springMass;

	float bias;
	float gamma;
} b2clWheelJointData;

typedef struct b2clWeldJointData
{
	float frequencyHz;
	float dampingRatio;
	float bias;

	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float referenceAngle;
	float gamma;

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat33 mass;
} b2clWeldJointData;

typedef struct b2clMouseJointData
{
	float localAnchorB[2];
	float targetA[2];
	float frequencyHz;
	float dampingRatio;
	float beta;
	
	// Solver shared
	float maxForce;
	float gamma;

	// Solver temp
	float rB[2];
	float localCenterB[2];
	float invMassB;
	float invIB;
	b2clMat22 mass;
	float C[2];
} b2clMouseJointData;

typedef struct b2clFrictionJointData
{
	float localAnchorA[2];
	float localAnchorB[2];

	float maxForce; 
	float maxTorque; 

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat22 linearMass;
	float angularMass; 
} b2clFrictionJointData;

typedef struct clJoint
{
	int index;

	// impulse : 4 floats
	union a1{
		struct x1{
			float impulse[3];
		}x;
		struct y1{
			float scalarImpulse;
			float springImpulse;
		}y;
		struct z1{
			float linearImpulse[2];
			float angularImpulse;
		}z;
	}a;
	float motorImpulse;

	int color;
	int type;
	int collideConnected;

	int indexA, indexB, indexC, indexD;

	union b1{
		b2clDistanceJointData distanceJointData;
		b2clRevoluteJointData revoluteJointData;
		b2clPrismaticJointData prismaticJointData;
		b2clGearJointData gearJointData;
		b2clPulleyJointData pulleyJointData;
		b2clRopeJointData ropeJointData;
		b2clWheelJointData wheelJointData;
		b2clWeldJointData weldJointData;
		b2clMouseJointData mouseJointData;
		b2clFrictionJointData frictionJointData;
	}b;
} b2clJoint;

typedef struct
{
	int index;
    float nimpulse[4];
} b2clJointImpulseNode;

typedef struct
{
	int isCollide;
	float normal[2];
	float fraction;
	unsigned int shapeIndex;
} b2clRayCastOutput;

typedef struct
{
	float2 m_buffer[2];
	float2 m_vertices[b2cl_maxPolygonVertices];
	int m_count;
	float m_radius;
} b2clDistanceProxy;

typedef struct 
{
	float metric;		///< length or area
	short count;
	unsigned char indexA[3];	///< vertices on shape A
	unsigned char indexB[3];	///< vertices on shape B
} b2clSimplexCache;

/// Input for b2Distance.
/// You have to option to use the shape radii
/// in the computation. Even 
typedef struct 
{
	b2clDistanceProxy proxyA;
	b2clDistanceProxy proxyB;
	b2clTransform transformA;
	b2clTransform transformB;
	bool useRadii;
} b2clDistanceInput;

/// Output for b2Distance.
typedef struct
{
	float2 pointA;		///< closest point on shapeA
	float2 pointB;		///< closest point on shapeB
	float ndistance;
	int iterations;	///< number of GJK iterations used
} b2clDistanceOutput;

typedef struct
{
	b2clDistanceProxy proxyA;
	b2clDistanceProxy proxyB;
	b2clSweep sweepA;
	b2clSweep sweepB;
	float tMax;		// defines sweep interval [0, tMax]
	float dummy;
} b2clTOIInput;

enum b2clTOIOutputState
{
	e_unknown,
	e_failed,
	e_overlapped,
	e_touching,
	e_separated
};

typedef struct
{
	int state;
	float t;
} b2clTOIOutput;

typedef struct
{
	float2 wA;		// support point in proxyA
	float2 wB;		// support point in proxyB
	float2 w;		// wB - wA
	float a;		// barycentric coordinate for closest point
	int indexA;	// wA index
	int indexB;	// wB index
} b2clSimplexVertex;

typedef struct 
{
	b2clSimplexVertex m_v1, m_v2, m_v3;
	int m_count;
} b2clSimplex;

//typedef struct{
//float v[30];
//} testData; 

//==============================================================================================
// Math functions
//==============================================================================================

/// Multiply two rotations: q * r
inline float2 b2clMul_TwoRotation(const float2 q, const float2 r)
{
	// [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
	// [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]
	// s = qs * rc + qc * rs
	// c = qc * rc - qs * rs
	float2 qr;
	qr.x = q.x * r.y + q.y * r.x;
	qr.y = q.y * r.y - q.x * r.x;
	return qr;
}

/// Transpose multiply two rotations: qT * r
inline float2 b2clMulT_TwoRotation(const float2 q, const float2 r)
{
	// [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
	// [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]
	// s = qc * rs - qs * rc
	// c = qc * rc + qs * rs
	float2 qr;
	qr.x = q.y * r.x - q.x * r.y;
	qr.y = q.y * r.y + q.x * r.x;
	return qr;
}

/// Rotate a vector
inline float2 b2clMul_Rotate(const float2 q, const float2 v)
{
	float2 result;
	result.x = q.y * v.x - q.x * v.y;
	result.y = q.x * v.x + q.y * v.y;

	return result;
}

/// Inverse rotate a vector
inline float2 b2clMulT_Rotate(const float2 q, const float2 v)
{
	float2 result;
	result.x = q.y * v.x + q.x * v.y;
	result.y = -q.x * v.x + q.y * v.y;

	return result;
}

/// Transform a vector
inline float2 b2clMul_Transform(const b2clTransform *T, const float2 v)
{
	float2 result;
	result.x = (T->q.y * v.x - T->q.x * v.y) + T->p.x;
	result.y = (T->q.x * v.x + T->q.y * v.y) + T->p.y;

	return result;
}

/// Invert transform a vector
inline float2 b2clMulT_Transform(const b2clTransform *T, const float2 v)
{
	float px = v.x - T->p.x;
	float py = v.y - T->p.y;
	float2 result;
	result.x = (T->q.y * px + T->q.x * py);
	result.y = (-T->q.x * px + T->q.y * py);

	return result;
}

// v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
//    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
inline b2clTransform b2clMul_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
	b2clTransform C;
	C.q = b2clMul_TwoRotation(A->q, B->q);
	C.p = b2clMul_TwoRotation(A->q, B->p) + A->p;
	return C;
}

// v2 = A.q' * (B.q * v1 + B.p - A.p)
//    = A.q' * B.q * v1 + A.q' * (B.p - A.p)
inline b2clTransform b2clMulT_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
	b2clTransform C;
	C.q = b2clMulT_TwoRotation(A->q, B->q);
	C.p = b2clMulT_TwoRotation(A->q, B->p - A->p);
	return C;
}

/// Perform the dot product on two vectors.
inline float b2clDot(const float2 a, const float2 b)
{
	return a.x * b.x + a.y * b.y;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float b2clCross_VV(const float2 a, const float2 b)
{
	return a.x * b.y - a.y * b.x;
}

/// Perform the cross product on a vector and a scalar. In 2D this produces
/// a vector.
inline float2 b2clCross_VS(const float2 a, float s)
{
	return (float2)(s * a.y, -s *a.x);
}

/// Perform the cross product on a scalar and a vector. In 2D this produces
/// a vector.
inline float2 b2clCross_SV(float s, const float2 a)
{
	return (float2)(-s * a.y, s * a.x);
}

inline float b2clClamp(float a, float low, float high)
{
	return max(low, min(a, high));
}

inline float2 b2clMin(const float2 a, const float2 b)
{
	return (float2)(min(a.x, b.x), min(a.y, b.y));
}

inline float2 b2clMax(const float2 a, const float2 b)
{
	return (float2)(max(a.x, b.x), max(a.y, b.y));
}

inline float b2clDistanceSquared(const float2 a, const float2 b)
{
	float2 c = a - b;
	return b2clDot(c, c);
}

inline float b2clDistance(const float2 a, const float2 b)
{
	float2 c = a - b;
	return sqrt(b2clDot(c, c));
}

inline float b2clLengthSquared(const float2 v)
{
	return b2clDot(v, v);
}

inline float b2clAbs(float a)
{
	return a > 0.0f ? a : -a;
}

/// Perform the dot product on two vectors.
inline float b2clDot3(const float3 a, const float3 b)
{
	return a.x * b.x + a.y * b.y + a.z * b.z;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float3 b2clCross3_VV(const float3 a, const float3 b)
{
	return (float3)(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float3 b2clMat33Solve(const b2clMat33 mat, const float3 b)
{
	float3 ex = (float3)(mat.ex[0], mat.ex[1], mat.ex[2]);
	float3 ey = (float3)(mat.ey[0], mat.ey[1], mat.ey[2]);
	float3 ez = (float3)(mat.ez[0], mat.ez[1], mat.ez[2]);

	float det = b2clDot3(ex, b2clCross3_VV(ey, ez));

	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float3 x;
	x.x = det * b2clDot3(b, b2clCross3_VV(ey, ez));
	x.y = det * b2clDot3(ex, b2clCross3_VV(b, ez));
	x.z = det * b2clDot3(ex, b2clCross3_VV(ey, b));
	return x;
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float2 b2clMat33Solve22(const b2clMat33 mat, const float2 b)
{
	float2 ex = (float2)(mat.ex[0], mat.ex[1]);
	float2 ey = (float2)(mat.ey[0], mat.ey[1]);

	float det = ex.x * ey.y - ey.x * ex.y;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float2 x;
	x.x = det * (ey.y * b.x - ey.x * b.y);
	x.y = det * (ex.x * b.y - ex.y * b.x);
	return x;
}

inline float2 b2clMat22Solve(const b2clMat22 mat, const float2 b)
{
	float2 ex = (float2)(mat.ex[0], mat.ex[1]);
	float2 ey = (float2)(mat.ey[0], mat.ey[1]);

	float det = ex.x * ey.y - ey.x * ex.y;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float2 x;
	x.x = det * (ey.y * b.x - ey.x * b.y);
	x.y = det * (ex.x * b.y - ex.y * b.x);
	return x;
}

inline float2 b2clMat33Mul22(const b2clMat33 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float2 b2clMat22Mul(const b2clMat22 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline void b2clGetInverse22(const b2clMat33 in, b2clMat33* out)
{
	float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
	float det = a * d - b * c;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}

	out->ex[0] =  det * d;	out->ey[0] = -det * b; out->ex[2] = 0.0f;
	out->ex[1] = -det * c;	out->ey[1] =  det * a; out->ey[2] = 0.0f;
	out->ez[0] = 0.0f; out->ez[1] = 0.0f; out->ez[2] = 0.0f;
}

inline void b2clGetSymInverse33(const b2clMat33 in, b2clMat33* out)
{
	//float det = b2clDot(ex, b2clCross(ey, ez));
	float det = in.ex[0] * (in.ey[1] * in.ez[2] - in.ey[2] * in.ez[1]) 
		+ in.ex[1] * (in.ey[2] * in.ez[0] - in.ey[0] * in.ez[2]) 
		+ in.ex[2] * (in.ey[0] * in.ez[1] - in.ey[1] * in.ez[0]);

	if (det != 0.0f)
	{
		det = 1.0f / det;
	}

	float a11 = in.ex[0], a12 = in.ey[0], a13 = in.ez[0];
	float a22 = in.ey[1], a23 = in.ez[1];
	float a33 = in.ez[2];

	out->ex[0] = det * (a22 * a33 - a23 * a23);
	out->ex[1] = det * (a13 * a23 - a12 * a33);
	out->ex[2] = det * (a12 * a23 - a13 * a22);

	out->ey[0] = out->ex[1];
	out->ey[1] = det * (a11 * a33 - a13 * a13);
	out->ey[2] = det * (a13 * a12 - a11 * a23);

	out->ez[0] = out->ex[2];
	out->ez[1] = out->ey[2];
	out->ez[2] = det * (a11 * a22 - a12 * a12);
}

inline float2 b2clMat33MulV2(const b2clMat33 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float3 b2clMat33MulV3(const b2clMat33 A, const float3 v)
{
	//return v.x * A.ex + v.y * A.ey + v.z * A.ez;
	return (float3)(A.ex[0] * v.x + A.ey[0] * v.y + A.ez[0] * v.z,
		A.ex[1] * v.x + A.ey[1] * v.y + A.ez[1] * v.z,
		A.ex[2] * v.x + A.ey[2] * v.y + A.ez[2] * v.z);
}

inline void b2clMat22GetInverse(const b2clMat22 in, b2clMat22* out)
{
	float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
	float det = a * d - b * c;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	out->ex[0] =  det * d;	out->ey[0] = -det * b;
	out->ex[1] = -det * c;	out->ey[1] =  det * a;
}

inline void b2clSweepNormalize(b2clSweep* sweep)
{
	float twoPi = 2.0f * b2_pi;
	float d =  twoPi * floor(sweep->a0 / twoPi);
	sweep->a0 -= d;
	sweep->a -= d;
}

inline void b2clSweepGetTransform(b2clSweep* sweep, b2clTransform* xf, float beta)
{
	xf->p = (1.0f - beta) * sweep->c0 + beta * sweep->c;
	float angle = (1.0f - beta) * sweep->a0 + beta * sweep->a;
	xf->q.x = sin(angle);
	xf->q.y = cos(angle);

	// Shift to origin
	xf->p -= b2clMul_Rotate(xf->q, sweep->localCenter);
}

inline void b2clSweepAdvance(b2clSweep* sweep, float alpha)
{
	float beta = (alpha - sweep->alpha0) / (1.0f - sweep->alpha0);
	sweep->c0 = (1.0f - beta) * sweep->c0 + beta * sweep->c;
	sweep->a0 = (1.0f - beta) * sweep->a0 + beta * sweep->a;
	sweep->alpha0 = alpha;
}
inline void b2clBodySweepAdvance (b2clBodyDynamic* body, b2clTransform* xf, float alpha) {
	b2clSweepAdvance(&(body->m_sweep), alpha); 
	body->m_sweep.c = body->m_sweep.c0;
	body->m_sweep.a = body->m_sweep.a0;
    xf->q.x = sin (body->m_sweep.a);
	xf->q.y = cos (body->m_sweep.a); 
	xf->p = body->m_sweep.c - b2clMul_Rotate(xf->q, body->m_sweep.localCenter);
}

inline void b2clDistanceProxySet(b2clDistanceProxy* proxy, const b2clPolygonShape* shape)
{
	proxy->m_count = shape->m_vertexCount;
	proxy->m_radius = shape->m_radius;
	for (int i = 0; i < shape->m_vertexCount; ++i)
	{
		proxy->m_vertices[i] = shape->m_vertices[i];
	}
}

inline int b2clDistanceProxyGetSupport(const b2clDistanceProxy* proxy, float2 d)
{
	int bestIndex = 0;
	float bestValue = b2clDot(proxy->m_vertices[0], d);
	for (int i = 1; i < proxy->m_count; ++i)
	{
		float value = b2clDot(proxy->m_vertices[i], d);
		if (value > bestValue)
		{
			bestIndex = i;
			bestValue = value;
		}
	}
	return bestIndex;
}

inline float2 b2clDistanceProxyGetVertex(const b2clDistanceProxy* proxy, int index)
{
	return proxy->m_vertices[index];
}

// Convert a vector into a unit vector. Returns the length.
inline float b2clNormalize(float2* v)
{
	float length = sqrt(b2clDot(*v, *v));
	if (length < b2_epsilon)
	{
		return 0.0f;
	}
	float invLength = 1.0f / length;
	(*v).x *= invLength;
	(*v).y *= invLength;

	return length;
}

/*
inline float cos_wrapper(float a)
{
	//float sina = sin(a);
	//return sqrt(1-sina*sina);

	//return sin(1.5707963268-a);

	return cos(a);
}
*/

//#include <Box2D/Common/OpenCL/b2CLTypeDefOCL.h>

//==============================================================================================
// Structures
//==============================================================================================

// This structure is used to keep track of the best separating axis.
typedef struct
{
	int type;
	int index;
	float separation;
} b2clEPAxis;

// This holds polygon B expressed in frame A.
typedef struct
{
	float2 vertices[b2cl_maxPolygonVertices];
	float2 normals[b2cl_maxPolygonVertices];
	int count;
} b2clTempPolygon;

// Reference face used for clipping
typedef struct
{
	int i1, i2;
	
	float2 v1, v2;
	
	float2 normal;
	
	float2 sideNormal1;
	float sideOffset1;
	
	float2 sideNormal2;
	float sideOffset2;
} b2clReferenceFace;

//==============================================================================================
// Sub-functions
//==============================================================================================

// Find the separation between poly1 and poly2 for a give edge normal on poly1.
static float b2clEdgeSeparation(const b2clPolygonShape* poly1, const b2clTransform* xf1, int edge1,
							  const b2clPolygonShape* poly2, const b2clTransform* xf2/*, float4 *test*/)
{
	const float2* vertices1 = poly1->m_vertices;
	const float2* normals1 = poly1->m_normals;

	int count2 = poly2->m_vertexCount;
	const float2* vertices2 = poly2->m_vertices;

	//b2Assert(0 <= edge1 && edge1 < poly1->m_vertexCount);

	// Convert normal from poly1's frame into poly2's frame.
	float2 normal1World = b2clMul_Rotate(xf1->q, normals1[edge1]);
	float2 normal1 = b2clMulT_Rotate(xf2->q, normal1World);

	// Find support vertex on poly2 for -normal.
	int index = 0;
	float minDot = MAXFLOAT;

	for (int i = 0; i < count2; ++i)
	{
		float dotProduct = dot(vertices2[i], normal1);
		if (dotProduct < minDot)
		{
			minDot = dotProduct;
			index = i;
		}
	}

	float2 v1 = b2clMul_Transform(xf1, vertices1[edge1]);
	float2 v2 = b2clMul_Transform(xf2, vertices2[index]);
	float separation = dot(v2 - v1, normal1World);
	//(*test).xy = vertices2[index];
	//(*test).zw = index;
	return separation;
}

// Find the max separation between poly1 and poly2 using edge normals from poly1.
float b2clFindMaxSeparation(int* edgeIndex,
							const b2clPolygonShape* poly1, const b2clTransform* xf1,
							const b2clPolygonShape* poly2, const b2clTransform* xf2
							/*, float4 *test*/)
{
	int count1 = poly1->m_vertexCount;
	const float2* normals1 = poly1->m_normals;

	// Vector pointing from the centroid of poly1 to the centroid of poly2.
	float2 d = b2clMul_Transform(xf2, poly2->m_centroid) - b2clMul_Transform(xf1, poly1->m_centroid);
	float2 dLocal1 = b2clMulT_Rotate(xf1->q, d);

	//(*test).x = poly1->m_centroid.x;
	//(*test).y = poly1->m_centroid.y;
	//(*test).z = poly2->m_centroid.x;
	//(*test).w = poly2->m_centroid.y;

	// Find edge normal on poly1 that has the largest projection onto d.
	int edge = 0;
	float maxDot = -MAXFLOAT;
	for (int i = 0; i < count1; ++i)
	{
		float dotProduct = dot(normals1[i], dLocal1);
		if (dotProduct > maxDot)
		{
			maxDot = dotProduct;
			edge = i;
		}
	}

	//float4 temp;
	// Get the separation for the edge normal.
	float s = b2clEdgeSeparation(poly1, xf1, edge, poly2, xf2/*, &temp*/);

	// Check the separation for the previous edge normal.
	int prevEdge = edge - 1 >= 0 ? edge - 1 : count1 - 1;
	float sPrev = b2clEdgeSeparation(poly1, xf1, prevEdge, poly2, xf2/*, &temp*/);

	// Check the separation for the next edge normal.
	int nextEdge = edge + 1 < count1 ? edge + 1 : 0;
	float sNext = b2clEdgeSeparation(poly1, xf1, nextEdge, poly2, xf2/*, &temp*/);

	// Find the best edge and the search direction.
	int bestEdge;
	float bestSeparation;
	int increment;
	if (sPrev > s && sPrev > sNext)
	{
		increment = -1;
		bestEdge = prevEdge;
		bestSeparation = sPrev;
	}
	else if (sNext > s)
	{
		increment = 1;
		bestEdge = nextEdge;
		bestSeparation = sNext;
	}
	else
	{
		*edgeIndex = edge;
		return s;
	}

	// Perform a local search for the best edge normal.
	for ( ; ; )
	{
		if (increment == -1)
			edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
		else
			edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;

		s = b2clEdgeSeparation(poly1, xf1, edge, poly2, xf2/*, &temp*/);

		if (s > bestSeparation)
		{
			bestEdge = edge;
			bestSeparation = s;
		}
		else
		{
			break;
		}
	}

	*edgeIndex = bestEdge;

	return bestSeparation;
}

static void b2clFindIncidentEdge(b2clClipVertex c[2],
							 const b2clPolygonShape* poly1, const b2clTransform* xf1, int edge1,
							 const b2clPolygonShape* poly2, const b2clTransform* xf2)
{
	const float2* normals1 = poly1->m_normals;

	int count2 = poly2->m_vertexCount;
	const float2* vertices2 = poly2->m_vertices;
	const float2* normals2 = poly2->m_normals;

	//b2Assert(0 <= edge1 && edge1 < poly1->m_vertexCount);

	// Get the normal of the reference edge in poly2's frame.
	float2 normal1 = b2clMulT_Rotate(xf2->q, b2clMul_Rotate(xf1->q, normals1[edge1]));

	// Find the incident edge on poly2.
	int index = 0;
	float minDot = MAXFLOAT;
	for (int i = 0; i < count2; ++i)
	{
		float dotProduct = dot(normal1, normals2[i]);
		if (dotProduct < minDot)
		{
			minDot = dotProduct;
			index = i;
		}
	}

	// Build the clip vertices for the incident edge.
	int i1 = index;
	int i2 = i1 + 1 < count2 ? i1 + 1 : 0;

	c[0].v = b2clMul_Transform(xf2, vertices2[i1]);
	c[0].id.cf.indexA = (uint)edge1;
	c[0].id.cf.indexB = (uint)i1;
	c[0].id.cf.typeA = 1;
	c[0].id.cf.typeB = 0;

	c[1].v = b2clMul_Transform(xf2, vertices2[i2]);
	c[1].id.cf.indexA = (uint)edge1;
	c[1].id.cf.indexB = (uint)i2;
	c[1].id.cf.typeA = 1;
	c[1].id.cf.typeB = 0;
}

// Sutherland-Hodgman clipping.
int b2clClipSegmentToLine(b2clClipVertex vOut[2], const b2clClipVertex vIn[2],
							const float2 normal, float offset, int vertexIndexA)
{
	// Start with no output points
	int numOut = 0;

	// Calculate the distance of end points to the line
	float distance0 = dot(normal, vIn[0].v) - offset;
	float distance1 = dot(normal, vIn[1].v) - offset;

	// If the points are behind the plane
	if (distance0 <= 0.0f) vOut[numOut++] = vIn[0];
	if (distance1 <= 0.0f) vOut[numOut++] = vIn[1];

	// If the points are on different sides of the plane
	if (distance0 * distance1 < 0.0f)
	{
		// Find intersection point of edge and plane
		float interp = distance0 / (distance0 - distance1);
		vOut[numOut].v = vIn[0].v + interp * (vIn[1].v - vIn[0].v);

		// VertexA is hitting edgeB.
		vOut[numOut].id.cf.indexA = vertexIndexA;
		vOut[numOut].id.cf.indexB = vIn[0].id.cf.indexB;
		vOut[numOut].id.cf.typeA = 0;
		vOut[numOut].id.cf.typeB = 1;
		++numOut;
	}

	return numOut;
}

inline b2clEPAxis b2clComputeEdgeSeparation(bool m_front, b2clTempPolygon *m_polygonB, float2 m_normal, float2 m_v1)
{
	b2clEPAxis axis;
	axis.type = 1; //b2EPAxis::e_edgeA;
	axis.index = m_front ? 0 : 1;
	axis.separation = MAXFLOAT;
	
	for (int i = 0; i < m_polygonB->count; ++i)
	{
		float s = b2clDot(m_normal, m_polygonB->vertices[i] - m_v1);
		if (s < axis.separation)
		{
			axis.separation = s;
		}
	}
	
	return axis;
}

inline b2clEPAxis b2clComputePolygonSeparation(float2 m_normal, b2clTempPolygon *m_polygonB, float2 m_v1, float2 m_v2, float2 m_upperLimit, float2 m_lowerLimit, float m_radius)
{
	b2clEPAxis axis;
	axis.type = 0; //b2EPAxis::e_unknown;
	axis.index = -1;
	axis.separation = -MAXFLOAT;

	float2 perp = (float2)(-m_normal.y, m_normal.x);

	for (int i = 0; i < m_polygonB->count; ++i)
	{
		float2 n = -m_polygonB->normals[i];
		
		float s1 = b2clDot(n, m_polygonB->vertices[i] - m_v1);
		float s2 = b2clDot(n, m_polygonB->vertices[i] - m_v2);
		float s = min(s1, s2);
		
		if (s > m_radius)
		{
			// No collision
			axis.type = 2; //b2EPAxis::e_edgeB;
			axis.index = i;
			axis.separation = s;
			return axis;
		}
		
		// Adjacency
		if (b2clDot(n, perp) >= 0.0f)
		{
			if (b2clDot(n - m_upperLimit, m_normal) < -b2_angularSlop)
			{
				continue;
			}
		}
		else
		{
			if (b2clDot(n - m_lowerLimit, m_normal) < -b2_angularSlop)
			{
				continue;
			}
		}
		
		if (s > axis.separation)
		{
			axis.type = 2; //b2EPAxis::e_edgeB;
			axis.index = i;
			axis.separation = s;
		}
	}
	
	return axis;
}

//==============================================================================================
// Main kernel function
//==============================================================================================

// Find edge normal of max separation on A - return if separating axis is found
// Find edge normal of max separation on B - return if separation axis is found
// Choose reference edge as min(minA, minB)
// Find incident edge
// Clip

// The normal points from 1 to 2
__kernel void b2clCollidePolygons(__global b2clManifold* manifolds, // output
								  __global int* manifoldBinaryBits, // output
								  //__global uint* impulsesKeys, // output
					  const __global b2clPolygonShape* polyGlobal, 
					  const __global b2clTransform* xfGlobal,
					  const __global int4* global_indices,
					  const __global int* pair_indices,
					  const int maxContactNum,
					  const int contactNum)
{
    unsigned int i = get_global_id(0);

	if (i>=contactNum)
		return;

	b2clManifold manifold/* = manifolds[i]*/;

	manifold.pointCount = 0;
    manifold.points[0].normalImpulse = 0;
    manifold.points[0].tangentImpulse = 0;
    manifold.points[1].normalImpulse = 0;
    manifold.points[1].tangentImpulse = 0;
	int type;

	int pair_index;
	int4 index;
	b2clPolygonShape polyA, polyB;
	b2clTransform xfA, xfB;

	pair_index = pair_indices[i + maxContactNum*2]; // 2 is contact type for polygon-polygon
	index = global_indices[pair_index];
	polyA = polyGlobal[index.x];
	polyB = polyGlobal[index.y];
	xfA = xfGlobal[index.z];
	xfB = xfGlobal[index.w];
	bool bSensor = polyA.m_bIsSensor || polyB.m_bIsSensor;

	float totalRadius = polyA.m_radius + polyB.m_radius;

	//float4 test;

	int edgeA = 0;
	float separationA = b2clFindMaxSeparation(&edgeA, &polyA, &xfA, &polyB, &xfB/*, &test*/);

	if (separationA > totalRadius)
	{
		manifolds[pair_index] = manifold;
		manifoldBinaryBits[pair_index] = 0;
		return;
	}

	int edgeB = 0;
	float separationB = b2clFindMaxSeparation(&edgeB, &polyB, &xfB, &polyA, &xfA/*, &test*/);
	if (separationB > totalRadius)
	{
		manifolds[pair_index] = manifold;
		manifoldBinaryBits[pair_index] = 0;
		return;
	}

	const b2clPolygonShape* poly1;	// reference polygon
	const b2clPolygonShape* poly2;	// incident polygon
	b2clTransform *xf1, *xf2;
	int edge1;		// reference edge
	uint flip;
	const float k_relativeTol = 0.98f;
	const float k_absoluteTol = 0.001f;

	if (separationB > k_relativeTol * separationA + k_absoluteTol)
	{
		poly1 = &polyB;
		poly2 = &polyA;
		xf1 = &xfB;
		xf2 = &xfA;
		edge1 = edgeB;
		manifold.type = 2;
		flip = 1;
	}
	else
	{
		poly1 = &polyA;
		poly2 = &polyB;
		xf1 = &xfA;
		xf2 = &xfB;
		edge1 = edgeA;
		manifold.type = 1;
		flip = 0;
	}

	b2clClipVertex incidentEdge[2];
	b2clFindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);

	int count1 = poly1->m_vertexCount;
	const float2* vertices1 = poly1->m_vertices;

	int iv1 = edge1;
	int iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;

	float2 v11 = vertices1[iv1];
	float2 v12 = vertices1[iv2];

	float2 localTangent = v12 - v11;
	localTangent = normalize(localTangent);
	
	float2 localNormal = b2clCross_VS(localTangent, 1.0f);
	float2 planePoint = 0.5f * (v11 + v12);

	float2 tangent = b2clMul_Rotate(xf1->q, localTangent);
	float2 normal = b2clCross_VS(tangent, 1.0f);
	
	v11 = b2clMul_Transform(xf1, v11);
	v12 = b2clMul_Transform(xf1, v12);

	// Face offset.
	float frontOffset = dot(normal, v11);

	// Side offsets, extended by polytope skin thickness.
	float sideOffset1 = -dot(tangent, v11) + totalRadius;
	float sideOffset2 = dot(tangent, v12) + totalRadius;

	// Clip incident edge against extruded edge1 side edges.
	b2clClipVertex clipPoints1[2];
	b2clClipVertex clipPoints2[2];
	int np;

	// Clip to box side 1
	np = b2clClipSegmentToLine(clipPoints1, incidentEdge, -tangent, sideOffset1, iv1);

	if (np < 2)
	{
		manifolds[pair_index] = manifold;
		manifoldBinaryBits[pair_index] = 0;
		return;
	}

	// Clip to negative box side 1
	np = b2clClipSegmentToLine(clipPoints2, clipPoints1,  tangent, sideOffset2, iv2);

	if (np < 2)
	{
		manifolds[pair_index] = manifold;
		manifoldBinaryBits[pair_index] = 0;
		return;
	}

	// Now clipPoints2 contains the clipped points.
	manifold.localNormal = localNormal;
	manifold.localPoint = planePoint;

	int pointCount = 0;
	for (int k = 0; k < b2cl_maxManifoldPoints; ++k)
	{
		float separation = dot(normal, clipPoints2[k].v) - frontOffset;

		if (separation <= totalRadius)
		{
			b2clManifoldPoint* cp = manifold.points + pointCount;
			cp->localPoint = b2clMulT_Transform(xf2, clipPoints2[k].v);
			cp->id = clipPoints2[k].id;
			if (flip)
			{
				// Swap features
				b2clContactFeature cf = cp->id.cf;
				cp->id.cf.indexA = cf.indexB;
				cp->id.cf.indexB = cf.indexA;
				cp->id.cf.typeA = cf.typeB;
				cp->id.cf.typeB = cf.typeA;
			}
			++pointCount;
		}
	}

	manifold.pointCount = pointCount;

	//for (int k = 0; k < manifold.pointCount; ++k)
	//{
	//	b2clManifoldPoint* mp2 = manifold.points + k;
	//	mp2->normalImpulse = 0.0f;
	//	mp2->tangentImpulse = 0.0f;
	//	int key2 = mp2->id.key;

	//	b2clManifold oldManifold = manifolds[i];
	//	for (int j = 0; j < oldManifold.pointCount; ++j)
	//	{
	//		b2clManifoldPoint* mp1 = oldManifold.points + j;

	//		if (mp1->id.key == key2)
	//		{
	//			mp2->normalImpulse = mp1->normalImpulse;
	//			mp2->tangentImpulse = mp1->tangentImpulse;
	//			break;
	//		}
	//	}
	//	manifold.test.x = oldManifold.pointCount;
	//}

	manifolds[pair_index] = manifold;
	manifoldBinaryBits[pair_index] = pointCount>0 ? !bSensor : 0;
}

__kernel void b2clCollideCircles(__global b2clManifold* manifolds, // output
								  __global int* manifoldBinaryBits, // output
								  //__global uint* impulsesKeys, // output
					  const __global b2clPolygonShape* polyGlobal, 
					  const __global b2clTransform* xfGlobal,
					  const __global int4* global_indices,
					  const __global int* pair_indices,
					  const int maxContactNum,
					  const int contactNum)
{
    unsigned int i = get_global_id(0);

	if (i>=contactNum)
		return;

	b2clManifold manifold/* = manifolds[i]*/;

	manifold.pointCount = 0;
    manifold.points[0].normalImpulse = 0;
    manifold.points[0].tangentImpulse = 0;
    manifold.points[1].normalImpulse = 0;
    manifold.points[1].tangentImpulse = 0;
	int type;

	int pair_index;
	int4 index;
	b2clPolygonShape circleA, circleB;
	b2clTransform xfA, xfB;

	pair_index = pair_indices[i]; // 0 is contact type for circle-circle
	index = global_indices[pair_index];
	circleA = polyGlobal[index.x];
	circleB = polyGlobal[index.y];
	xfA = xfGlobal[index.z];
	xfB = xfGlobal[index.w];
	bool bSensor = circleA.m_bIsSensor || circleB.m_bIsSensor;

	float totalRadius = circleA.m_radius + circleB.m_radius;
	// Vector pointing from the centroid of poly1 to the centroid of poly2.
	float2 d = b2clMul_Transform(&xfA, circleA.m_centroid) - b2clMul_Transform(&xfB, circleB.m_centroid);
	float distSqr = b2clDot(d, d);

	if (distSqr > totalRadius * totalRadius)
	{
		manifolds[pair_index] = manifold;
		manifoldBinaryBits[pair_index] = 0;
		return;
	}

	manifold.type = 0; // b2Manifold::e_circles
	manifold.localPoint = circleA.m_centroid;
	manifold.localNormal = 0;
	manifold.pointCount = 1;

	manifold.points[0].localPoint = circleB.m_centroid;
	manifold.points[0].id.key = 0;

	manifolds[pair_index] = manifold;
	manifoldBinaryBits[pair_index] = !bSensor;
}

__kernel void b2clCollidePolygonAndCircle(__global b2clManifold* manifolds, // output
								  __global int* manifoldBinaryBits, // output
								  //__global uint* impulsesKeys, // output
								  const __global b2clPolygonShape* polyGlobal, 
								  const __global b2clTransform* xfGlobal,
								  const __global int4* global_indices,
								  const __global int* pair_indices,
								  const int maxContactNum,
								  const int contactNum)
{
    unsigned int i = get_global_id(0);

	if (i>=contactNum)
		return;

	b2clManifold manifold/* = manifolds[i]*/;

	manifold.pointCount = 0;
    manifold.points[0].normalImpulse = 0;
    manifold.points[0].tangentImpulse = 0;
    manifold.points[1].normalImpulse = 0;
    manifold.points[1].tangentImpulse = 0;
	int type;

	int pair_index;
	int4 index;
	b2clPolygonShape polyA, circleB;
	b2clTransform xfA, xfB;

	pair_index = pair_indices[i + maxContactNum*1]; // 1 is contact type for polygon-circle
	index = global_indices[pair_index];
	polyA = polyGlobal[index.x];
	circleB = polyGlobal[index.y];
	xfA = xfGlobal[index.z];
	xfB = xfGlobal[index.w];
	bool bSensor = polyA.m_bIsSensor || circleB.m_bIsSensor;

	// Compute circle position in the frame of the polygon.
	float2 c = b2clMul_Transform(&xfB, circleB.m_centroid);
	float2 cLocal = b2clMulT_Transform(&xfA, c);

	// Find the min separating edge.
	int normalIndex = 0;
	float separation = -b2_maxFloat;
	float radius = polyA.m_radius + circleB.m_radius;
	int vertexCount = polyA.m_vertexCount;
	const float2* vertices = polyA.m_vertices;
	const float2* normals = polyA.m_normals;

	for (int i = 0; i < vertexCount; ++i)
	{
		float s = b2clDot(normals[i], cLocal - vertices[i]);

		if (s > radius)
		{
			// Early out.
			manifolds[pair_index] = manifold;
			manifoldBinaryBits[pair_index] = 0;
			//printf("early out, pair index: %d\n", pair_index);
			return;
		}

		if (s > separation)
		{
			separation = s;
			normalIndex = i;
		}
	}

	// Vertices that subtend the incident face.
	int vertIndex1 = normalIndex;
	int vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
	float2 v1 = vertices[vertIndex1];
	float2 v2 = vertices[vertIndex2];

	// If the center is inside the polygon ...
	if (separation < b2_epsilon)
	{
		manifold.pointCount = 1;
		manifold.type = 1; //b2Manifold::e_faceA
		manifold.localNormal = normals[normalIndex];
		manifold.localPoint = 0.5f * (v1 + v2);
		manifold.points[0].localPoint = circleB.m_centroid;
		manifold.points[0].id.key = 0;

		manifolds[pair_index] = manifold;
		manifoldBinaryBits[pair_index] = !bSensor;
		return;
	}

	// Compute barycentric coordinates
	float u1 = b2clDot(cLocal - v1, v2 - v1);
	float u2 = b2clDot(cLocal - v2, v1 - v2);
	if (u1 <= 0.0f)
	{
		if (b2clDistanceSquared(cLocal, v1) > radius * radius)
		{
			manifolds[pair_index] = manifold;
			manifoldBinaryBits[pair_index] = 0;
			return;
		}

		manifold.pointCount = 1;
		manifold.type = 1; //b2Manifold::e_faceA
		manifold.localNormal = normalize(cLocal - v1);
		manifold.localPoint = v1;
		manifold.points[0].localPoint = circleB.m_centroid;
		manifold.points[0].id.key = 0;
	}
	else if (u2 <= 0.0f)
	{
		if (b2clDistanceSquared(cLocal, v2) > radius * radius)
		{
			manifolds[pair_index] = manifold;
			manifoldBinaryBits[pair_index] = 0;
			return;
		}

		manifold.pointCount = 1;
		manifold.type = 1; //b2Manifold::e_faceA
		manifold.localNormal = normalize(cLocal - v2);
		manifold.localPoint = v2;
		manifold.points[0].localPoint = circleB.m_centroid;
		manifold.points[0].id.key = 0;
	}
	else
	{
		float2 faceCenter = 0.5f * (v1 + v2);
		float separation = b2clDot(cLocal - faceCenter, normals[vertIndex1]);
		if (separation > radius)
		{
			manifolds[pair_index] = manifold;
			manifoldBinaryBits[pair_index] = 0;
			return;
		}

		manifold.pointCount = 1;
		manifold.type = 1; //b2Manifold::e_faceA
		manifold.localNormal = normals[vertIndex1];
		manifold.localPoint = faceCenter;
		manifold.points[0].localPoint = circleB.m_centroid;
		manifold.points[0].id.key = 0;
	}

	manifolds[pair_index] = manifold;
	manifoldBinaryBits[pair_index] = !bSensor;
}

__kernel void b2clCollideEdgeAndCircle(__global b2clManifold* manifolds, // output
								  __global int* manifoldBinaryBits, // output
								  //__global uint* impulsesKeys, // output
								  const __global b2clPolygonShape* polyGlobal, 
								  const __global b2clTransform* xfGlobal,
								  const __global int4* global_indices,
								  const __global int* pair_indices,
								  const int maxContactNum,
								  const int contactNum)
{
    unsigned int i = get_global_id(0);

	if (i>=contactNum)
		return;

	b2clManifold manifold/* = manifolds[i]*/;

	manifold.pointCount = 0;
    manifold.points[0].normalImpulse = 0;
    manifold.points[0].tangentImpulse = 0;
    manifold.points[1].normalImpulse = 0;
    manifold.points[1].tangentImpulse = 0;
	int type;

	int pair_index;
	int4 index;
	b2clPolygonShape edgeA, circleB;
	b2clTransform xfA, xfB;

	pair_index = pair_indices[i + maxContactNum*3]; // 3 is contact type for edge-circle
	index = global_indices[pair_index];
	edgeA = polyGlobal[index.x];
	circleB = polyGlobal[index.y];
	xfA = xfGlobal[index.z];
	xfB = xfGlobal[index.w];
	bool bSensor = edgeA.m_bIsSensor || circleB.m_bIsSensor;

	// Compute circle in frame of edge
	float2 Q = b2clMulT_Transform(&xfA, b2clMul_Transform(&xfB, circleB.m_centroid));
	
	float2 A = edgeA.m_vertices[0], B = edgeA.m_vertices[1];
	float2 e = B - A;
	
	// Barycentric coordinates
	float u = b2clDot(e, B - Q);
	float v = b2clDot(e, Q - A);
	
	float radius = edgeA.m_radius + circleB.m_radius;
	
	b2clContactFeature cf;
	cf.indexB = 0;
	cf.typeB = 0; //b2ContactFeature::e_vertex;
	
	// Region A
	if (v <= 0.0f)
	{
		float2 P = A;
		float2 d = Q - P;
		float dd = b2clDot(d, d);
		if (dd > radius * radius)
		{
			manifolds[pair_index] = manifold;
			manifoldBinaryBits[pair_index] = 0;
			return;
		}
		
		// Is there an edge connected to A?
		if (edgeA.m_centroid.x) // m_centroid.x is used for m_hasVertex0
		{
			float2 A1 = edgeA.m_vertices[2]; // m_vertices[2] is used for m_vertex0
			float2 B1 = A;
			float2 e1 = B1 - A1;
			float u1 = b2clDot(e1, B1 - Q);
			
			// Is the circle in Region AB of the previous edge?
			if (u1 > 0.0f)
			{
				manifolds[pair_index] = manifold;
				manifoldBinaryBits[pair_index] = 0;
				return;
			}
		}
		
		cf.indexA = 0;
		cf.typeA = 0; //b2ContactFeature::e_vertex;
		manifold.pointCount = 1;
		manifold.type = 0; //b2Manifold::e_circles;
		manifold.localNormal = 0;
		manifold.localPoint = P;
		manifold.points[0].id.key = 0;
		manifold.points[0].id.cf = cf;
		manifold.points[0].localPoint = circleB.m_centroid;

		manifolds[pair_index] = manifold;
		manifoldBinaryBits[pair_index] = !bSensor;
		return;
	}
	
	// Region B
	if (u <= 0.0f)
	{
		float2 P = B;
		float2 d = Q - P;
		float dd = b2clDot(d, d);
		if (dd > radius * radius)
		{
			manifolds[pair_index] = manifold;
			manifoldBinaryBits[pair_index] = 0;
			return;
		}
		
		// Is there an edge connected to B?
		if (edgeA.m_centroid.y) // m_centroid.y is used for m_hasVertex3
		{
			float2 B2 = edgeA.m_vertices[3];
			float2 A2 = B;
			float2 e2 = B2 - A2;
			float v2 = b2clDot(e2, Q - A2);
			
			// Is the circle in Region AB of the next edge?
			if (v2 > 0.0f)
			{
				manifolds[pair_index] = manifold;
				manifoldBinaryBits[pair_index] = 0;
				return;
			}
		}
		
		cf.indexA = 1;
		cf.typeA = 0; //b2ContactFeature::e_vertex;
		manifold.pointCount = 1;
		manifold.type = 0; //b2Manifold::e_circles;
		manifold.localNormal = 0;
		manifold.localPoint = P;
		manifold.points[0].id.key = 0;
		manifold.points[0].id.cf = cf;
		manifold.points[0].localPoint = circleB.m_centroid;

		manifolds[pair_index] = manifold;
		manifoldBinaryBits[pair_index] = !bSensor;
		return;
	}
	
	// Region AB
	float den = b2clDot(e, e);
	float2 P = (1.0f / den) * (u * A + v * B);
	float2 d = Q - P;
	float dd = b2clDot(d, d);
	if (dd > radius * radius)
	{
		manifolds[pair_index] = manifold;
		manifoldBinaryBits[pair_index] = 0;
		return;
	}
	
	float2 n = (float2)(-e.y, e.x);
	if (b2clDot(n, Q - A) < 0.0f)
	{
		float2 nn = (float2)(-n.x, -n.y);
		n = nn;
	}
	n = normalize(n);
	
	cf.indexA = 0;
	cf.typeA = 1; //b2ContactFeature::e_face;
	manifold.pointCount = 1;
	manifold.type = 1; //b2Manifold::e_faceA;
	manifold.localNormal = n;
	manifold.localPoint = A;
	manifold.points[0].id.key = 0;
	manifold.points[0].id.cf = cf;
	manifold.points[0].localPoint = circleB.m_centroid;

	manifolds[pair_index] = manifold;
	manifoldBinaryBits[pair_index] = !bSensor;
}

__kernel void b2clCollideEdgeAndPolygon(__global b2clManifold* manifolds, // output
								  __global int* manifoldBinaryBits, // output
								  //__global uint* impulsesKeys, // output
								  const __global b2clPolygonShape* polyGlobal, 
								  const __global b2clTransform* xfGlobal,
								  const __global int4* global_indices,
								  const __global int* pair_indices,
								  const int maxContactNum,
								  const int contactNum)
{
    unsigned int i = get_global_id(0);

	if (i>=contactNum)
		return;

	b2clManifold manifold/* = manifolds[i]*/;

	manifold.pointCount = 0;
    manifold.points[0].normalImpulse = 0;
    manifold.points[0].tangentImpulse = 0;
    manifold.points[1].normalImpulse = 0;
    manifold.points[1].tangentImpulse = 0;
	int type;

	int pair_index;
	int4 index;
	b2clPolygonShape edgeA, polygonB;
	b2clTransform xfA, xfB;

	pair_index = pair_indices[i + maxContactNum*4]; // 4 is contact type for edge-polygon
	index = global_indices[pair_index];
	edgeA = polyGlobal[index.x];
	polygonB = polyGlobal[index.y];
	xfA = xfGlobal[index.z];
	xfB = xfGlobal[index.w];
	bool bSensor = edgeA.m_bIsSensor || polygonB.m_bIsSensor;

// Algorithm:
// 1. Classify v1 and v2
// 2. Classify polygon centroid as front or back
// 3. Flip normal if necessary
// 4. Initialize normal range to [-pi, pi] about face normal
// 5. Adjust normal range according to adjacent edges
// 6. Visit each separating axes, only accept axes within the range
// 7. Return if _any_ axis indicates separation
// 8. Clip
	b2clTempPolygon m_polygonB;

	b2clTransform m_xf;
	float2 m_centroidB;
	float2 m_v0, m_v1, m_v2, m_v3;
	float2 m_normal0, m_normal1, m_normal2;
	float2 m_normal;
	int m_type1, m_type2;
	float2 m_lowerLimit, m_upperLimit;
	float m_radius;
	bool m_front;

	m_xf = b2clMulT_TwoTransform(&xfA, &xfB);
	
	m_centroidB = b2clMul_Transform(&m_xf, polygonB.m_centroid);
	
	m_v0 = edgeA.m_vertices[2]; // m_vertices[2] is used for m_vertex0
	m_v1 = edgeA.m_vertices[0]; // m_vertices[0] is used for m_vertex1
	m_v2 = edgeA.m_vertices[1]; // m_vertices[1] is used for m_vertex2
	m_v3 = edgeA.m_vertices[3]; // m_vertices[3] is used for m_vertex3
	
	bool hasVertex0 = edgeA.m_centroid.x; // m_centroid.x is used for m_hasVertex0
	bool hasVertex3 = edgeA.m_centroid.y; // m_centroid.y is used for m_hasVertex3
	
	float2 edge1 = m_v2 - m_v1;
	edge1 = normalize(edge1);
	m_normal1 = (float2)(edge1.y, -edge1.x);
	float offset1 = b2clDot(m_normal1, m_centroidB - m_v1);
	float offset0 = 0.0f, offset2 = 0.0f;
	bool convex1 = false, convex2 = false;
	
	// Is there a preceding edge?
	if (hasVertex0)
	{
		float2 edge0 = m_v1 - m_v0;
		edge0 = normalize(edge0);
		m_normal0 = (float2)(edge0.y, -edge0.x);
		convex1 = b2clCross_VV(edge0, edge1) >= 0.0f;
		offset0 = b2clDot(m_normal0, m_centroidB - m_v0);
	}
	
	// Is there a following edge?
	if (hasVertex3)
	{
		float2 edge2 = m_v3 - m_v2;
		edge2 = normalize(edge2);
		m_normal2 = (float2)(edge2.y, -edge2.x);
		convex2 = b2clCross_VV(edge1, edge2) > 0.0f;
		offset2 = b2clDot(m_normal2, m_centroidB - m_v2);
	}
	
	// Determine front or back collision. Determine collision normal limits.
	if (hasVertex0 && hasVertex3)
	{
		if (convex1 && convex2)
		{
			m_front = offset0 >= 0.0f || offset1 >= 0.0f || offset2 >= 0.0f;
			if (m_front)
			{
				m_normal = m_normal1;
				m_lowerLimit = m_normal0;
				m_upperLimit = m_normal2;
			}
			else
			{
				m_normal = -m_normal1;
				m_lowerLimit = -m_normal1;
				m_upperLimit = -m_normal1;
			}
		}
		else if (convex1)
		{
			m_front = offset0 >= 0.0f || (offset1 >= 0.0f && offset2 >= 0.0f);
			if (m_front)
			{
				m_normal = m_normal1;
				m_lowerLimit = m_normal0;
				m_upperLimit = m_normal1;
			}
			else
			{
				m_normal = -m_normal1;
				m_lowerLimit = -m_normal2;
				m_upperLimit = -m_normal1;
			}
		}
		else if (convex2)
		{
			m_front = offset2 >= 0.0f || (offset0 >= 0.0f && offset1 >= 0.0f);
			if (m_front)
			{
				m_normal = m_normal1;
				m_lowerLimit = m_normal1;
				m_upperLimit = m_normal2;
			}
			else
			{
				m_normal = -m_normal1;
				m_lowerLimit = -m_normal1;
				m_upperLimit = -m_normal0;
			}
		}
		else
		{
			m_front = offset0 >= 0.0f && offset1 >= 0.0f && offset2 >= 0.0f;
			if (m_front)
			{
				m_normal = m_normal1;
				m_lowerLimit = m_normal1;
				m_upperLimit = m_normal1;
			}
			else
			{
				m_normal = -m_normal1;
				m_lowerLimit = -m_normal2;
				m_upperLimit = -m_normal0;
			}
		}
	}
	else if (hasVertex0)
	{
		if (convex1)
		{
			m_front = offset0 >= 0.0f || offset1 >= 0.0f;
			if (m_front)
			{
				m_normal = m_normal1;
				m_lowerLimit = m_normal0;
				m_upperLimit = -m_normal1;
			}
			else
			{
				m_normal = -m_normal1;
				m_lowerLimit = m_normal1;
				m_upperLimit = -m_normal1;
			}
		}
		else
		{
			m_front = offset0 >= 0.0f && offset1 >= 0.0f;
			if (m_front)
			{
				m_normal = m_normal1;
				m_lowerLimit = m_normal1;
				m_upperLimit = -m_normal1;
			}
			else
			{
				m_normal = -m_normal1;
				m_lowerLimit = m_normal1;
				m_upperLimit = -m_normal0;
			}
		}
	}
	else if (hasVertex3)
	{
		if (convex2)
		{
			m_front = offset1 >= 0.0f || offset2 >= 0.0f;
			if (m_front)
			{
				m_normal = m_normal1;
				m_lowerLimit = -m_normal1;
				m_upperLimit = m_normal2;
			}
			else
			{
				m_normal = -m_normal1;
				m_lowerLimit = -m_normal1;
				m_upperLimit = m_normal1;
			}
		}
		else
		{
			m_front = offset1 >= 0.0f && offset2 >= 0.0f;
			if (m_front)
			{
				m_normal = m_normal1;
				m_lowerLimit = -m_normal1;
				m_upperLimit = m_normal1;
			}
			else
			{
				m_normal = -m_normal1;
				m_lowerLimit = -m_normal2;
				m_upperLimit = m_normal1;
			}
		}		
	}
	else
	{
		m_front = offset1 >= 0.0f;
		if (m_front)
		{
			m_normal = m_normal1;
			m_lowerLimit = -m_normal1;
			m_upperLimit = -m_normal1;
		}
		else
		{
			m_normal = -m_normal1;
			m_lowerLimit = m_normal1;
			m_upperLimit = m_normal1;
		}
	}
	
	// Get polygonB in frameA
	m_polygonB.count = polygonB.m_vertexCount;
	for (int i = 0; i < polygonB.m_vertexCount; ++i)
	{
		m_polygonB.vertices[i] = b2clMul_Transform(&m_xf, polygonB.m_vertices[i]);
		m_polygonB.normals[i] = b2clMul_Rotate(m_xf.q, polygonB.m_normals[i]);
	}
	
	m_radius = 2.0f * b2_polygonRadius;
	
	manifold.pointCount = 0;
	
	b2clEPAxis edgeAxis = b2clComputeEdgeSeparation(m_front, &m_polygonB, m_normal, m_v1);
	
	// If no valid normal can be found than this edge should not collide.
	if (edgeAxis.type == 0 /*b2EPAxis::e_unknown*/) // ??? Never true?
	{
		manifolds[pair_index] = manifold;
		manifoldBinaryBits[pair_index] = 0;
		return;
	}
	
	if (edgeAxis.separation > m_radius)
	{
		manifolds[pair_index] = manifold;
		manifoldBinaryBits[pair_index] = 0;
		return;
	}
	
	b2clEPAxis polygonAxis = b2clComputePolygonSeparation(m_normal, &m_polygonB, m_v1, m_v2, m_upperLimit, m_lowerLimit, m_radius);
	if (polygonAxis.type != 0 /*b2EPAxis::e_unknown*/ && polygonAxis.separation > m_radius)
	{
		manifolds[pair_index] = manifold;
		manifoldBinaryBits[pair_index] = 0;
		return;
	}
	
	// Use hysteresis for jitter reduction.
	const float k_relativeTol = 0.98f;
	const float k_absoluteTol = 0.001f;
	
	b2clEPAxis primaryAxis;
	if (polygonAxis.type == 0 /*b2EPAxis::e_unknown*/)
	{
		primaryAxis = edgeAxis;
	}
	else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol)
	{
		primaryAxis = polygonAxis;
	}
	else
	{
		primaryAxis = edgeAxis;
	}
	
	b2clClipVertex ie[2];
	b2clReferenceFace rf;
	if (primaryAxis.type == 1 /*b2EPAxis::e_edgeA*/)
	{
		manifold.type = 1; //b2Manifold::e_faceA;
		
		// Search for the polygon normal that is most anti-parallel to the edge normal.
		int bestIndex = 0;
		float bestValue = b2clDot(m_normal, m_polygonB.normals[0]);
		for (int i = 1; i < m_polygonB.count; ++i)
		{
			float value = b2clDot(m_normal, m_polygonB.normals[i]);
			if (value < bestValue)
			{
				bestValue = value;
				bestIndex = i;
			}
		}
		
		int i1 = bestIndex;
		int i2 = i1 + 1 < m_polygonB.count ? i1 + 1 : 0;
		
		ie[0].v = m_polygonB.vertices[i1];
		ie[0].id.cf.indexA = 0;
		ie[0].id.cf.indexB = i1;
		ie[0].id.cf.typeA = 1; //b2ContactFeature::e_face;
		ie[0].id.cf.typeB = 0; //b2ContactFeature::e_vertex;
		
		ie[1].v = m_polygonB.vertices[i2];
		ie[1].id.cf.indexA = 0;
		ie[1].id.cf.indexB = i2;
		ie[1].id.cf.typeA = 1; //b2ContactFeature::e_face;
		ie[1].id.cf.typeB = 0; //b2ContactFeature::e_vertex;
		
		if (m_front)
		{
			rf.i1 = 0;
			rf.i2 = 1;
			rf.v1 = m_v1;
			rf.v2 = m_v2;
			rf.normal = m_normal1;
		}
		else
		{
			rf.i1 = 1;
			rf.i2 = 0;
			rf.v1 = m_v2;
			rf.v2 = m_v1;
			rf.normal = -m_normal1;
		}		
	}
	else
	{
		manifold.type = 2; //b2Manifold::e_faceB;
		
		ie[0].v = m_v1;
		ie[0].id.cf.indexA = 0;
		ie[0].id.cf.indexB = primaryAxis.index;
		ie[0].id.cf.typeA = 0; //b2ContactFeature::e_vertex;
		ie[0].id.cf.typeB = 1; //b2ContactFeature::e_face;
		
		ie[1].v = m_v2;
		ie[1].id.cf.indexA = 0;
		ie[1].id.cf.indexB = primaryAxis.index;		
		ie[1].id.cf.typeA = 0; //b2ContactFeature::e_vertex;
		ie[1].id.cf.typeB = 1; //b2ContactFeature::e_face;
		
		rf.i1 = primaryAxis.index;
		rf.i2 = rf.i1 + 1 < m_polygonB.count ? rf.i1 + 1 : 0;
		rf.v1 = m_polygonB.vertices[rf.i1];
		rf.v2 = m_polygonB.vertices[rf.i2];
		rf.normal = m_polygonB.normals[rf.i1];
	}
	
	rf.sideNormal1 = (float2)(rf.normal.y, -rf.normal.x);
	rf.sideNormal2 = -rf.sideNormal1;
	rf.sideOffset1 = b2clDot(rf.sideNormal1, rf.v1);
	rf.sideOffset2 = b2clDot(rf.sideNormal2, rf.v2);
	
	// Clip incident edge against extruded edge1 side edges.
	b2clClipVertex clipPoints1[2];
	b2clClipVertex clipPoints2[2];
	int np;
	
	// Clip to box side 1
	np = b2clClipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);
	
	if (np < b2cl_maxManifoldPoints)
	{
		manifolds[pair_index] = manifold;
		manifoldBinaryBits[pair_index] = 0;
		return;
	}
	
	// Clip to negative box side 1
	np = b2clClipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);
	
	if (np < b2cl_maxManifoldPoints)
	{
		manifolds[pair_index] = manifold;
		manifoldBinaryBits[pair_index] = 0;
		return;
	}
	
	// Now clipPoints2 contains the clipped points.
	if (primaryAxis.type == 1 /*b2EPAxis::e_edgeA*/)
	{
		manifold.localNormal = rf.normal;
		manifold.localPoint = rf.v1;
	}
	else
	{
		manifold.localNormal = polygonB.m_normals[rf.i1];
		manifold.localPoint = polygonB.m_vertices[rf.i1];
	}
	
	int pointCount = 0;
	for (int i = 0; i < b2cl_maxManifoldPoints; ++i)
	{
		float separation;
		
		separation = b2clDot(rf.normal, clipPoints2[i].v - rf.v1);
		
		if (separation <= m_radius)
		{
			b2clManifoldPoint* cp = manifold.points + pointCount;
			
			if (primaryAxis.type == 1 /*b2EPAxis::e_edgeA*/)
			{
				cp->localPoint = b2clMulT_Transform(&m_xf, clipPoints2[i].v);
				cp->id = clipPoints2[i].id;
			}
			else
			{
				cp->localPoint = clipPoints2[i].v;
				cp->id.cf.typeA = clipPoints2[i].id.cf.typeB;
				cp->id.cf.typeB = clipPoints2[i].id.cf.typeA;
				cp->id.cf.indexA = clipPoints2[i].id.cf.indexB;
				cp->id.cf.indexB = clipPoints2[i].id.cf.indexA;
			}
			
			++pointCount;
		}
	}
	
	manifold.pointCount = pointCount;
	manifolds[pair_index] = manifold;
	manifoldBinaryBits[pair_index] = !bSensor;
}

__kernel void b2clCompactForOneContact(
					const __global int *CompactIn_data, // input
					__global int *CompactOut_data, // output
					__global int *numValidData // output
					)
{
	*numValidData = CompactIn_data[0];
	if (*numValidData)
		CompactOut_data[0] = 0;
}/*
Copyright (c) 2012 Advanced Micro Devices, Inc.  

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
//Originally written by Takahiro Harada


typedef unsigned int u32;
#define GET_GROUP_IDX get_group_id(0)
#define GET_LOCAL_IDX get_local_id(0)
#define GET_GLOBAL_IDX get_global_id(0)
#define GET_GROUP_SIZE get_local_size(0)
#define GROUP_LDS_BARRIER barrier(CLK_LOCAL_MEM_FENCE)

// takahiro end
#define WG_SIZE 128 
#define m_numElems x
#define m_numBlocks y
#define m_numScanBlocks z

/*typedef struct
{
	uint m_numElems;
	uint m_numBlocks;
	uint m_numScanBlocks;
	uint m_padding[1];
} ConstBuffer;
*/

float4 ScanExclusiveFloat4(__local float4* data, u32 n, int lIdx, int lSize)
{
	float4 blocksum;

    int offset = 1;
    for(int nActive=n>>1; nActive>0; nActive>>=1, offset<<=1)
    {
        GROUP_LDS_BARRIER;
        for(int iIdx=lIdx; iIdx<nActive; iIdx+=lSize)
        {
            int ai = offset*(2*iIdx+1)-1;
            int bi = offset*(2*iIdx+2)-1;
            data[bi] += data[ai];
        }
	}

    GROUP_LDS_BARRIER;

    if( lIdx == 0 )
	{
		blocksum = data[ n-1 ];
    data[ n-1 ] = 0;
	}

	GROUP_LDS_BARRIER;

	offset >>= 1;
    for(int nActive=1; nActive<n; nActive<<=1, offset>>=1 )
    {
        GROUP_LDS_BARRIER;
        for( int iIdx = lIdx; iIdx<nActive; iIdx += lSize )
        {
            int ai = offset*(2*iIdx+1)-1;
            int bi = offset*(2*iIdx+2)-1;
            float4 temp = data[ai];
            data[ai] = data[bi];
            data[bi] += temp;
        }
	}
	GROUP_LDS_BARRIER;

	return blocksum;
}

__attribute__((reqd_work_group_size(WG_SIZE,1,1)))
__kernel
void LocalScanKernel(__global float4* dst, __global float4* src, __global float4* sumBuffer,	uint4 cb)
{
	__local float4 ldsData[WG_SIZE*2];

	int gIdx = GET_GLOBAL_IDX;
	int lIdx = GET_LOCAL_IDX;

//	ldsData[2*lIdx]     = ( 2*gIdx < cb.m_numElems )? src[2*gIdx]: 0;
//	ldsData[2*lIdx + 1] = ( 2*gIdx+1 < cb.m_numElems )? src[2*gIdx + 1]: 0;
    
    if ( 2*gIdx < cb.m_numElems )
        ldsData[2*lIdx] = src[2*gIdx];
    else
        ldsData[2*lIdx] = 0;
    
    if ( 2*gIdx+1 < cb.m_numElems )
        ldsData[2*lIdx + 1] = src[2*gIdx + 1];
    else
        ldsData[2*lIdx + 1] = 0;

	float4 sum = ScanExclusiveFloat4(ldsData, WG_SIZE*2, GET_LOCAL_IDX, GET_GROUP_SIZE);

	if( lIdx == 0 ) 
		sumBuffer[GET_GROUP_IDX] = sum;

	if( (2*gIdx) < cb.m_numElems )
    {
        dst[2*gIdx]     = ldsData[2*lIdx];
	}
	if( (2*gIdx + 1) < cb.m_numElems )
	{
        dst[2*gIdx + 1] = ldsData[2*lIdx + 1];
    }
}

__attribute__((reqd_work_group_size(WG_SIZE,1,1)))
__kernel
void AddOffsetKernel(__global float4* dst, __global float4* blockSum, uint4 cb)
{
	const u32 blockSize = WG_SIZE*2;

	int myIdx = GET_GROUP_IDX+1;
	int lIdx = GET_LOCAL_IDX;

	float4 iBlockSum = blockSum[myIdx];

	int endValue = min((myIdx+1)*(blockSize), cb.m_numElems);
	for(int i=myIdx*blockSize+lIdx; i<endValue; i+=GET_GROUP_SIZE)
	{
		dst[i] += iBlockSum;
	}
}

__attribute__((reqd_work_group_size(WG_SIZE,1,1)))
__kernel
void TopLevelScanKernel(__global float4* dst, uint4 cb)
{
	__local float4 ldsData[2048];
	int gIdx = GET_GLOBAL_IDX;
	int lIdx = GET_LOCAL_IDX;
	int lSize = GET_GROUP_SIZE;

	for(int i=lIdx; i<cb.m_numScanBlocks; i+=lSize )
	{
//		ldsData[i] = (i<cb.m_numBlocks)? dst[i]:0;
        if (i<cb.m_numBlocks)
            ldsData[i] = dst[i];
        else
            ldsData[i] = 0;
	}

	GROUP_LDS_BARRIER;

	float4 sum = ScanExclusiveFloat4(ldsData, cb.m_numScanBlocks, GET_LOCAL_IDX, GET_GROUP_SIZE);

	for(int i=lIdx; i<cb.m_numBlocks; i+=lSize )
	{
		dst[i] = ldsData[i];
	}

	if( gIdx == 0 )
	{
		dst[cb.m_numBlocks] = sum;
	}

}
//------------------------------------------------------------
// Purpose :
// ---------
// Prefix sum or prefix scan is an operation where each output element contains the sum of all input elements preceding it.
//
// Algorithm :
// -----------
// The parallel prefix sum has two principal parts, the reduce phase (also known as the up-sweep phase) and the down-sweep phase.
//
// In the up-sweep reduction phase we traverse the computation tree from bottom to top, computing partial sums.
// After this phase, the last element of the array contains the total sum.
//
// During the down-sweep phase, we traverse the tree from the root and use the partial sums to build the scan in place.
//
// Because the scan pictured is an exclusive sum, a zero is inserted into the last element before the start of the down-sweep phase.
// This zero is then propagated back to the first element.
//
// In our implementation, each compute unit loads and sums up two elements (for the deepest depth). Each subsequent depth during the up-sweep
// phase is processed by half of the compute units from the deeper level and the other way around for the down-sweep phase.
//
// In order to be able to scan large arrays, i.e. arrays that have many more elements than the maximum size of a work-group, the prefix sum has to be decomposed.
// Each work-group computes the prefix scan of its sub-range and outputs a single number representing the sum of all elements in its sub-range.
// The workgroup sums are scanned using exactly the same algorithm.
// When the number of work-group results reaches the size of a work-group, the process is reversed and the work-group sums are
// propagated to the sub-ranges, where each work-group adds the incoming sum to all its elements, thus producing the final scanned array.
//
// References :
// ------------
// NVIDIA Mark Harris. Parallel prefix sum (scan) with CUDA. April 2007
// http://developer.download.nvidia.com/compute/cuda/1_1/Website/projects/scan/doc/scan.pdf
// http://graphics.idav.ucdavis.edu/publications/print_pub?pub_id=915
//
// Other references :
// ------------------
// http://developer.nvidia.com/node/57
//------------------------------------------------------------

#pragma OPENCL EXTENSION cl_amd_printf : enable
#define T float
#define SUPPORT_AVOID_BANK_CONFLICT

//------------------------------------------------------------
// kernel__ExclusivePrefixScanSmall
//
// Purpose : do a fast scan on a small chunck of data.
//------------------------------------------------------------

__kernel 
void kernel__ExclusivePrefixScanSmall(
	__global T* input,
	__global T* output,
	__local  T* block,
	const uint length)
{
	int tid = get_local_id(0);
	
	int offset = 1;

    // Cache the computational window in shared memory
	block[2*tid]     = input[2*tid];
	block[2*tid + 1] = input[2*tid + 1];	

    // Build the sum in place up the tree
	for(int d = length>>1; d > 0; d >>=1)
	{
		barrier(CLK_LOCAL_MEM_FENCE);
		
		if(tid<d)
		{
			int ai = offset*(2*tid + 1) - 1;
			int bi = offset*(2*tid + 2) - 1;
			
			block[bi] += block[ai];
		}
		offset *= 2;
	}

    // scan back down the tree

    // Clear the last element
	if(tid == 0)
		block[length - 1] = 0;

    // traverse down the tree building the scan in the place
	for(int d = 1; d < length ; d *= 2)
	{
		offset >>=1;
		barrier(CLK_LOCAL_MEM_FENCE);
		
		if(tid < d)
		{
			int ai = offset*(2*tid + 1) - 1;
			int bi = offset*(2*tid + 2) - 1;
			
			float t = block[ai];
			block[ai] = block[bi];
			block[bi] += t;
		}
	}
	
	barrier(CLK_LOCAL_MEM_FENCE);

    // write the results back to global memory
	output[2*tid]     = block[2*tid];
	output[2*tid + 1] = block[2*tid + 1];
}

//------------------------------------------------------------
// kernel__ExclusivePrefixScan
//
// Purpose : do a scan on a chunck of data.
//------------------------------------------------------------

// Define this to more rigorously avoid bank conflicts, even at the lower (root) levels of the tree.
// To avoid bank conflicts during the tree traversal, we need to add padding to the shared memory array every NUM_BANKS (16) elements.
// Note that due to the higher addressing overhead, performance is lower with ZERO_BANK_CONFLICTS enabled.
// It is provided as an example.
//#define ZERO_BANK_CONFLICTS 

// 16 banks on G80
#define NUM_BANKS 16
#define LOG_NUM_BANKS 4

#ifdef ZERO_BANK_CONFLICTS
	#define CONFLICT_FREE_OFFSET(index) ((index) >> LOG_NUM_BANKS + (index) >> (2*LOG_NUM_BANKS))
#else
	#define CONFLICT_FREE_OFFSET(index) ((index) >> LOG_NUM_BANKS)
#endif

//#define CONFLICT_FREE_OFFSET(index) 0

__kernel
void kernel__ExclusivePrefixScan(
	__global T* dataSet,
	
	__local T* localBuffer,
	
	__global T* blockSums,
	const uint blockSumsSize
	)
{
	const uint gid = get_global_id(0);
	const uint tid = get_local_id(0);
	const uint bid = get_group_id(0);
	const uint lwz  = get_local_size(0);
	
	// The local buffer has 2x the size of the local-work-size, because we manage 2 scans at a time.
    const uint localBufferSize = lwz << 1;
    int offset = 1;
	
    const int tid2_0 = tid << 1;
    const int tid2_1 = tid2_0 + 1;
	
	const int gid2_0 = gid << 1;
    const int gid2_1 = gid2_0 + 1;

	// Cache the datas in local memory

#ifdef SUPPORT_AVOID_BANK_CONFLICT
	uint ai = tid;
	uint bi = tid + lwz;
	uint gai = tid + bid*lwz*2;
	uint gbi = gai + lwz;
	uint bankOffsetA = CONFLICT_FREE_OFFSET(ai); 
	uint bankOffsetB = CONFLICT_FREE_OFFSET(bi);
	localBuffer[ai + bankOffsetA] = (gai < blockSumsSize) ? dataSet[gai] : 0; 
	localBuffer[bi + bankOffsetB] = (gbi < blockSumsSize) ? dataSet[gbi] : 0;
#else
	localBuffer[tid2_0] = (gid2_0 < blockSumsSize) ? dataSet[gid2_0] : 0;
	localBuffer[tid2_1] = (gid2_1 < blockSumsSize) ? dataSet[gid2_1] : 0;
#endif
	
    // bottom-up
    for(uint d = lwz; d > 0; d >>= 1)
	{
        barrier(CLK_LOCAL_MEM_FENCE);
		
        if (tid < d)
		{
#ifdef SUPPORT_AVOID_BANK_CONFLICT
			//uint ai = mad24(offset, (tid2_1+0), -1);	// offset*(tid2_0+1)-1 = offset*(tid2_1+0)-1
            //uint bi = mad24(offset, (tid2_1+1), -1);	// offset*(tid2_1+1)-1;			
			uint i = 2 * offset * tid;
			uint ai = i + offset - 1;
			uint bi = ai + offset;
			ai += CONFLICT_FREE_OFFSET(ai);	// ai += ai / NUM_BANKS;
			bi += CONFLICT_FREE_OFFSET(bi);	// bi += bi / NUM_BANKS;
#else
            const uint ai = mad24(offset, (tid2_1+0), -1);	// offset*(tid2_0+1)-1 = offset*(tid2_1+0)-1
            const uint bi = mad24(offset, (tid2_1+1), -1);	// offset*(tid2_1+1)-1;
#endif

            localBuffer[bi] += localBuffer[ai];
        }
        offset <<= 1;
    }

    barrier(CLK_LOCAL_MEM_FENCE);
	
	/*
	if (tid < 1)
		blockSums[bid] = localBuffer[localBufferSize-1];
		
	barrier(CLK_LOCAL_MEM_FENCE | CLK_GLOBAL_MEM_FENCE);
	
	if (tid < 1)
		localBuffer[localBufferSize - 1] = 0;
	*/
	
	//// for debug
	//uint iii = localBufferSize-1;
	//iii += CONFLICT_FREE_OFFSET(iii);
	//printf("iii: %d, localBuffer[iii]: %d\n", iii, localBuffer[iii]);

    if (tid < 1)
	{
#ifdef SUPPORT_AVOID_BANK_CONFLICT
		uint index = localBufferSize-1;
		index += CONFLICT_FREE_OFFSET(index);
		blockSums[bid] = localBuffer[index];
		localBuffer[index] = 0;
		//printf("bid: %d, lwz: %d, blockSums[bid]: %d\n", bid, lwz, blockSums[bid]);
#else
		// We store the biggest value (the last) to the sum-block for later use.
        blockSums[bid] = localBuffer[localBufferSize-1];		
		//barrier(CLK_LOCAL_MEM_FENCE | CLK_GLOBAL_MEM_FENCE);		
		// Clear the last element
        localBuffer[localBufferSize - 1] = 0;
#endif
    }

    // top-down
    for(uint d = 1; d < localBufferSize; d <<= 1)
	{
        offset >>= 1;
        barrier(CLK_LOCAL_MEM_FENCE);
		
        if (tid < d)
		{
#ifdef SUPPORT_AVOID_BANK_CONFLICT
			//uint ai = mad24(offset, (tid2_1+0), -1);	// offset*(tid2_0+1)-1 = offset*(tid2_1+0)-1
            //uint bi = mad24(offset, (tid2_1+1), -1);	// offset*(tid2_1+1)-1;			
			uint i = 2 * offset * tid;
			uint ai = i + offset - 1;
			uint bi = ai + offset;
			ai += CONFLICT_FREE_OFFSET(ai);	// Apply an offset to the __local memory
			bi += CONFLICT_FREE_OFFSET(bi);
#else
            const uint ai = mad24(offset, (tid2_1+0), -1); // offset*(tid2_0+1)-1 = offset*(tid2_1+0)-1
            const uint bi = mad24(offset, (tid2_1+1), -1); // offset*(tid2_1+1)-1;
#endif

            T tmp = localBuffer[ai];
            localBuffer[ai] = localBuffer[bi];
            localBuffer[bi] += tmp;
        }
    }

    barrier(CLK_LOCAL_MEM_FENCE);

    // Copy back from the local buffer to the output array
	
#ifdef SUPPORT_AVOID_BANK_CONFLICT
	//dataSet[gai] = (gai < blockSumsSize) * localBuffer[ai + bankOffsetA];		
	//dataSet[gbi] = (gbi < blockSumsSize) * localBuffer[bi + bankOffsetB];		

	//printf("gai: %d, gbi: %d, blockSumsSize: %d\n", gai, gbi, blockSumsSize);
	//printf("ai: %d, bankOffsetA: %d, bi: %d, bankOffsetB: %d\n", ai, bankOffsetA, bi, bankOffsetB);
	if (gai < blockSumsSize)
		dataSet[gai] = localBuffer[ai + bankOffsetA];		
	if (gbi < blockSumsSize)
		dataSet[gbi] = localBuffer[bi + bankOffsetB];		
#else
	if (gid2_0 < blockSumsSize)
		dataSet[gid2_0] = localBuffer[tid2_0];
	if (gid2_1 < blockSumsSize)
		dataSet[gid2_1] = localBuffer[tid2_1];
#endif

}

//------------------------------------------------------------
// kernel__ExclusivePrefixScan
//
// Purpose :
// Final step of large-array scan: combine basic inclusive scan with exclusive scan of top elements of input arrays.
//------------------------------------------------------------

__kernel
void kernel__UniformAdd(
	__global T* output,
	__global const T* blockSums,
	const uint outputSize
	)
{
    uint gid = get_global_id(0) * 2;
    const uint tid = get_local_id(0);
    const uint blockId = get_group_id(0);
	
	// Intel SDK fix
	//output[gid] += blockSums[blockId];
	//output[gid+1] += blockSums[blockId];

    __local T localBuffer[1];

#ifdef SUPPORT_AVOID_BANK_CONFLICT
	//uint blockOffset = 1024 - 1;
    if (tid < 1)
	{
        localBuffer[0] = blockSums[blockId/* + blockOffset*/];
		//printf("localBuffer: %d, blockId: %d\n", localBuffer[0], blockId);
	}
#else
    if (tid < 1)
        localBuffer[0] = blockSums[blockId];
#endif

    barrier(CLK_LOCAL_MEM_FENCE);
	
#ifdef SUPPORT_AVOID_BANK_CONFLICT
	unsigned int address = blockId * get_local_size(0) * 2 + get_local_id(0); 
	
	//output[address] += localBuffer[0];
 //   output[address + get_local_size(0)] += (get_local_id(0) + get_local_size(0) < outputSize) * localBuffer[0];

	//printf("address: %d, output[address] before: %d, localBuffer[0]: %d\n", address, output[address], localBuffer[0]);
	if (address < outputSize)
		output[address] += localBuffer[0];
	if (address + get_local_size(0) < outputSize)
		output[address + get_local_size(0)] += localBuffer[0];
#else
	//printf("gid: %d, output[gid] before: %d, localBuffer[0]: %d\n", gid, output[gid], localBuffer[0]);
	if (gid < outputSize)
		output[gid] += localBuffer[0];
	gid++;
	if (gid < outputSize)
		output[gid] += localBuffer[0];
#endif
}//
// File:       scan_kernel.cl
//
// Abstract:   This example shows how to perform an efficient parallel prefix sum (aka Scan)
//             using OpenCL.  Scan is a common data parallel primitive which can be used for 
//             variety of different operations -- this example uses local memory for storing
//             partial sums and avoids memory bank conflicts on architectures which serialize
//             memory operations that are serviced on the same memory bank by offsetting the
//             loads and stores based on the size of the local group and the number of
//             memory banks (see appropriate macro definition).  As a result, this example
//             requires that the local group size > 1.
//
// Version:    <1.0>
//
// Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Inc. ("Apple")
//             in consideration of your agreement to the following terms, and your use,
//             installation, modification or redistribution of this Apple software
//             constitutes acceptance of these terms.  If you do not agree with these
//             terms, please do not use, install, modify or redistribute this Apple
//             software.
//
//             In consideration of your agreement to abide by the following terms, and
//             subject to these terms, Apple grants you a personal, non - exclusive
//             license, under Apple's copyrights in this original Apple software ( the
//             "Apple Software" ), to use, reproduce, modify and redistribute the Apple
//             Software, with or without modifications, in source and / or binary forms;
//             provided that if you redistribute the Apple Software in its entirety and
//             without modifications, you must retain this notice and the following text
//             and disclaimers in all such redistributions of the Apple Software. Neither
//             the name, trademarks, service marks or logos of Apple Inc. may be used to
//             endorse or promote products derived from the Apple Software without specific
//             prior written permission from Apple.  Except as expressly stated in this
//             notice, no other rights or licenses, express or implied, are granted by
//             Apple herein, including but not limited to any patent rights that may be
//             infringed by your derivative works or by other works in which the Apple
//             Software may be incorporated.
//
//             The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO
//             WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
//             WARRANTIES OF NON - INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A
//             PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION
//             ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//
//             IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
//             CONSEQUENTIAL DAMAGES ( INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//             SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//             INTERRUPTION ) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION
//             AND / OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER
//             UNDER THEORY OF CONTRACT, TORT ( INCLUDING NEGLIGENCE ), STRICT LIABILITY OR
//             OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Copyright ( C ) 2008 Apple Inc. All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////////////////////////

#define MEMORY_BANK_COUNT       (16)  // Adjust to your architecture
#define LOG2_MEMORY_BANK_COUNT   (4)  // Set to log2(MEMORY_BANK_COUNT)
#define ELIMINATE_CONFLICTS      (0)  // Enable for slow address calculation, but zero bank conflicts

////////////////////////////////////////////////////////////////////////////////////////////////////

#if (ELIMINATE_CONFLICTS)
#define MEMORY_BANK_OFFSET(index) ((index) >> LOG2_MEMORY_BANK_COUNT + (index) >> (2*LOG2_MEMORY_BANK_COUNT))
#else
#define MEMORY_BANK_OFFSET(index) ((index) >> LOG2_MEMORY_BANK_COUNT)
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////

uint4 
GetAddressMapping(int index)
{
    const uint local_id = get_local_id(0);
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);

    uint2 global_index;
    global_index.x = index + local_id;
    global_index.y = global_index.x + group_size;

    uint2 local_index;
    local_index.x = local_id;
    local_index.y = local_id + group_size;

    return (uint4)(global_index.x, global_index.y, local_index.x, local_index.y);
}

void 
LoadLocalFromGlobal(
    __local int *shared_data,
    __global const int *input_data, 
    const uint4 address_pair,
    const uint n)
{
    const uint global_index_a = address_pair.x; 
    const uint global_index_b = address_pair.y; 

    const uint local_index_a = address_pair.z; 
    const uint local_index_b = address_pair.w; 

    const uint bank_offset_a = MEMORY_BANK_OFFSET(local_index_a);
    const uint bank_offset_b = MEMORY_BANK_OFFSET(local_index_b);

    shared_data[local_index_a + bank_offset_a] = input_data[global_index_a]; 
    shared_data[local_index_b + bank_offset_b] = input_data[global_index_b]; 
}

void 
LoadLocalFromGlobalNonPowerOfTwo(
    __local int *shared_data,
    __global const int *input_data, 
    const uint4 address_pair,
    const uint n)
{
    const uint global_index_a = address_pair.x; 
    const uint global_index_b = address_pair.y; 

    const uint local_index_a = address_pair.z; 
    const uint local_index_b = address_pair.w; 

    const uint bank_offset_a = MEMORY_BANK_OFFSET(local_index_a);
    const uint bank_offset_b = MEMORY_BANK_OFFSET(local_index_b);

    shared_data[local_index_a + bank_offset_a] = input_data[global_index_a]; 
    shared_data[local_index_b + bank_offset_b] = (local_index_b < n) ? input_data[global_index_b] : 0; 
	
	barrier(CLK_LOCAL_MEM_FENCE);
}

void 
StoreLocalToGlobal(
    __global int* output_data, 
    __local const int* shared_data,
    const uint4 address_pair,
    const uint n)
{
    barrier(CLK_LOCAL_MEM_FENCE);

    const uint global_index_a = address_pair.x; 
    const uint global_index_b = address_pair.y; 

    const uint local_index_a = address_pair.z; 
    const uint local_index_b = address_pair.w; 

    const uint bank_offset_a = MEMORY_BANK_OFFSET(local_index_a);
    const uint bank_offset_b = MEMORY_BANK_OFFSET(local_index_b);

    output_data[global_index_a] = shared_data[local_index_a + bank_offset_a]; 
    output_data[global_index_b] = shared_data[local_index_b + bank_offset_b]; 
}

void 
StoreLocalToGlobalNonPowerOfTwo(
    __global int* output_data, 
    __local const int* shared_data,
    const uint4 address_pair,
    const uint n)
{
    barrier(CLK_LOCAL_MEM_FENCE);

    const uint global_index_a = address_pair.x; 
    const uint global_index_b = address_pair.y; 

    const uint local_index_a = address_pair.z; 
    const uint local_index_b = address_pair.w; 

    const uint bank_offset_a = MEMORY_BANK_OFFSET(local_index_a);
    const uint bank_offset_b = MEMORY_BANK_OFFSET(local_index_b);

    output_data[global_index_a] = shared_data[local_index_a + bank_offset_a]; 
    if(local_index_b < n)
        output_data[global_index_b] = shared_data[local_index_b + bank_offset_b]; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void 
ClearLastElement(
    __local int* shared_data, 
    int group_index)
{
    const uint local_id = get_local_id(0);
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);

    if (local_id == 0)
    {
        int index = (group_size << 1) - 1;
        index += MEMORY_BANK_OFFSET(index);
        shared_data[index] = 0;
    }
}

void 
ClearLastElementStoreSum(
    __local int* shared_data, 
    __global int *partial_sums, 
    int group_index)
{
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    const uint local_id = get_local_id(0); 

    if (local_id == 0)
    {
        int index = (group_size << 1) - 1;
        index += MEMORY_BANK_OFFSET(index);
        partial_sums[group_index] = shared_data[index];
        shared_data[index] = 0;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

uint 
BuildPartialSum(
    __local int *shared_data)
{
    const uint local_id = get_local_id(0);
    const uint group_size = get_local_size(0);
    const uint two = 2;
    uint stride = 1;
    
    for (uint j = group_size; j > 0; j >>= 1)
    {
        barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < j)      
        {
            int i  = mul24(mul24(two, stride), local_id);

            uint local_index_a = i + stride - 1;
            uint local_index_b = local_index_a + stride;

            local_index_a += MEMORY_BANK_OFFSET(local_index_a);
            local_index_b += MEMORY_BANK_OFFSET(local_index_b);

            shared_data[local_index_b] += shared_data[local_index_a];
        }

        stride *= two;
    }

    return stride;
}

void 
ScanRootToLeaves(
    __local int *shared_data, 
    uint stride)
{
    const uint local_id = get_local_id(0);
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    const uint two = 2;
    
    for (uint j = 1; j <= group_size; j *= two)
    {
        stride >>= 1;

        barrier(CLK_LOCAL_MEM_FENCE);

        if (local_id < j)
        {
            int i  = mul24(mul24(two, stride), local_id);

            uint local_index_a = i + stride - 1;
            uint local_index_b = local_index_a + stride;

            local_index_a += MEMORY_BANK_OFFSET(local_index_a);
            local_index_b += MEMORY_BANK_OFFSET(local_index_b);

            int t = shared_data[local_index_a];
            shared_data[local_index_a] = shared_data[local_index_b];
            shared_data[local_index_b] += t;
        }
    }
}

void 
PreScanGroup(
    __local int *shared_data, 
    int group_index)
{
    const uint group_id = get_global_id(0) / get_local_size(0);

    int stride = BuildPartialSum(shared_data);               
    ClearLastElement(shared_data, (group_index == 0) ? group_id : group_index);
    ScanRootToLeaves(shared_data, stride);             
}

void 
PreScanGroupStoreSum(
    __global int *partial_sums,
    __local int *shared_data, 
    int group_index) 
{
    const uint group_id = get_global_id(0) / get_local_size(0);

    int stride = BuildPartialSum(shared_data);               
    ClearLastElementStoreSum(shared_data, partial_sums, (group_index == 0) ? group_id : group_index);
    ScanRootToLeaves(shared_data, stride);             
}

////////////////////////////////////////////////////////////////////////////////////////////////////

__kernel void 
PreScanKernel(
    __global int *output_data, 
    __global const int *input_data, 
    __local int* shared_data,
    const uint  group_index, 
    const uint  base_index,
    const uint  n)
{
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    
    uint local_index = (base_index == 0) ? mul24(group_id, (group_size << 1)) : base_index;
    uint4 address_pair = GetAddressMapping(local_index);
    
    LoadLocalFromGlobal(shared_data, input_data, address_pair, n); 
    PreScanGroup(shared_data, group_index); 
    StoreLocalToGlobal(output_data, shared_data, address_pair, n);
}

__kernel void 
PreScanStoreSumKernel(
    __global int *output_data, 
    __global const int *input_data, 
    __global int *partial_sums, 
    __local int* shared_data,
    const uint group_index, 
    const uint base_index,
    const uint n)
{
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);

    uint local_index = (base_index == 0) ? mul24(group_id, (group_size << 1)) : base_index;
    uint4 address_pair = GetAddressMapping(local_index);
    
    LoadLocalFromGlobal(shared_data, input_data, address_pair, n); 
    PreScanGroupStoreSum(partial_sums, shared_data, group_index); 
    StoreLocalToGlobal(output_data, shared_data, address_pair, n);
}

__kernel void 
PreScanStoreSumNonPowerOfTwoKernel(
    __global int *output_data, 
    __global const int *input_data, 
    __global int *partial_sums, 
    __local int* shared_data,
    const uint group_index, 
    const uint base_index,
    const uint n) 
{
    const uint local_id = get_local_id(0);
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);

    uint local_index = (base_index == 0) ? mul24(group_id, (group_size << 1)) : base_index;
    uint4 address_pair = GetAddressMapping(local_index);
    
    LoadLocalFromGlobalNonPowerOfTwo(shared_data, input_data, address_pair, n); 
    PreScanGroupStoreSum(partial_sums, shared_data, group_index); 
    StoreLocalToGlobalNonPowerOfTwo(output_data, shared_data, address_pair, n);
}

__kernel void 
PreScanNonPowerOfTwoKernel(
    __global int *output_data, 
    __global const int *input_data, 
    __local int* shared_data,
    const uint group_index, 
    const uint base_index,
    const uint n)
{
    const uint local_id = get_local_id(0);
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);

    uint local_index = (base_index == 0) ? mul24(group_id, (group_size << 1)) : base_index;
    uint4 address_pair = GetAddressMapping(local_index);
    
    LoadLocalFromGlobalNonPowerOfTwo(shared_data, input_data, address_pair, n); 
    PreScanGroup(shared_data, group_index); 
    StoreLocalToGlobalNonPowerOfTwo(output_data, shared_data, address_pair, n);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

__kernel void UniformAddKernel(
    __global int *output_data, 
    __global int *input_data, 
    __local int *shared_data,
    const uint group_offset, 
    const uint base_index,
    const uint n)
{
    const uint local_id = get_local_id(0);
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);

    if (local_id == 0)
        shared_data[0] = input_data[group_id + group_offset];
    
    barrier(CLK_LOCAL_MEM_FENCE);
    
    uint address = mul24(group_id, (group_size << 1)) + base_index + local_id;
    
    output_data[address]              += shared_data[0];
	if( (local_id + group_size) < n)
		output_data[address + group_size] += shared_data[0];
}

////////////////////////////////////////////////////////////////////////////////////////////////////

__kernel void ParallelCompactKernel( __global int *CompactOut_data, // output
                              __global int *CompactIn_data, 
                              __global int *ScanResult_data, 
                              __global int *numValidData, // output
                              const uint n)
{
    const uint i = get_global_id(0);
    
    if(n==0 && i==0) 
		*numValidData = 0;
	else if (i<n)
	{
		int data = CompactIn_data[i];
		uint addr = ScanResult_data[i];
		if (data>-1)
		{
			CompactOut_data[addr] = data;
			addr++;
		}
		if (i==n-1)
			*numValidData = addr;
	}
}

__kernel void ParallelCompactIndicesKernel( __global int *CompactOut_data, // output
										  __global int *CompactIn_data, 
										  __global int *ScanResult_data, 
										  __global int *numValidData, // output
										  const uint n)
{
    const uint i = get_global_id(0);
    
    if(n==0 && i==0) 
		*numValidData = 0;
	else if (i<n)
	{
		int data = CompactIn_data[i];
		uint addr = ScanResult_data[i];
		if (data>0)
		{
			CompactOut_data[addr] = i;
			addr++;
		}
		if (i==n-1)
			*numValidData = addr;
	}
}

__kernel void ParallelCompactGeneralKernel( __global int *CompactOut_data, // output
										  __global int *CompactIn_data, 
										  __global int *Bit_data,
										  __global int *ScanResult_data, 
										  __global int *numValidData, // output
										  const uint n)
{
    const uint i = get_global_id(0);
    
    if(n==0 && i==0) 
		*numValidData = 0;
	else if (i<n)
	{
		int data = CompactIn_data[i];
		int bit = Bit_data[i];
		uint addr = ScanResult_data[i];
		if (bit>0)
		{
			CompactOut_data[addr] = data;
			addr++;
		}
		if (i==n-1)
			*numValidData = addr;
	}
}//
// File:       scan_kernel.cl
//
// Abstract:   This example shows how to perform an efficient parallel prefix sum (aka Scan)
//             using OpenCL.  Scan is a common data parallel primitive which can be used for 
//             variety of different operations -- this example uses local memory for storing
//             partial sums and avoids memory bank conflicts on architectures which serialize
//             memory operations that are serviced on the same memory bank by offsetting the
//             loads and stores based on the size of the local group and the number of
//             memory banks (see appropriate macro definition).  As a result, this example
//             requires that the local group size > 1.
//
// Version:    <1.0>
//
// Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Inc. ("Apple")
//             in consideration of your agreement to the following terms, and your use,
//             installation, modification or redistribution of this Apple software
//             constitutes acceptance of these terms.  If you do not agree with these
//             terms, please do not use, install, modify or redistribute this Apple
//             software.
//
//             In consideration of your agreement to abide by the following terms, and
//             subject to these terms, Apple grants you a personal, non - exclusive
//             license, under Apple's copyrights in this original Apple software ( the
//             "Apple Software" ), to use, reproduce, modify and redistribute the Apple
//             Software, with or without modifications, in source and / or binary forms;
//             provided that if you redistribute the Apple Software in its entirety and
//             without modifications, you must retain this notice and the following text
//             and disclaimers in all such redistributions of the Apple Software. Neither
//             the name, trademarks, service marks or logos of Apple Inc. may be used to
//             endorse or promote products derived from the Apple Software without specific
//             prior written permission from Apple.  Except as expressly stated in this
//             notice, no other rights or licenses, express or implied, are granted by
//             Apple herein, including but not limited to any patent rights that may be
//             infringed by your derivative works or by other works in which the Apple
//             Software may be incorporated.
//
//             The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO
//             WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
//             WARRANTIES OF NON - INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A
//             PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION
//             ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//
//             IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
//             CONSEQUENTIAL DAMAGES ( INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//             SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//             INTERRUPTION ) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION
//             AND / OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER
//             UNDER THEORY OF CONTRACT, TORT ( INCLUDING NEGLIGENCE ), STRICT LIABILITY OR
//             OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Copyright ( C ) 2008 Apple Inc. All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////////////////////////

#define MEMORY_BANK_COUNT       (16)  // Adjust to your architecture
#define LOG2_MEMORY_BANK_COUNT   (4)  // Set to log2(MEMORY_BANK_COUNT)
#define ELIMINATE_CONFLICTS      (0)  // Enable for slow address calculation, but zero bank conflicts

////////////////////////////////////////////////////////////////////////////////////////////////////

#if (ELIMINATE_CONFLICTS)
#define MEMORY_BANK_OFFSET(index) ((index) >> LOG2_MEMORY_BANK_COUNT + (index) >> (2*LOG2_MEMORY_BANK_COUNT))
#else
#define MEMORY_BANK_OFFSET(index) ((index) >> LOG2_MEMORY_BANK_COUNT)
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////

uint4 
GetAddressMapping(int index)
{
    const uint local_id = get_local_id(0);
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    
    uint2 global_index;
    global_index.x = index + local_id;
    global_index.y = global_index.x + group_size;
    
    uint2 local_index;
    local_index.x = local_id;
    local_index.y = local_id + group_size;
    
    return (uint4)(global_index.x, global_index.y, local_index.x, local_index.y);
}

void 
LoadLocalFromGlobal(
                    __local int *shared_data,
                    __global const int *input_data, 
                    const uint4 address_pair,
                    const uint n)
{
    const uint global_index_a = address_pair.x; 
    const uint global_index_b = address_pair.y; 
    
    const uint local_index_a = address_pair.z; 
    const uint local_index_b = address_pair.w; 
    
    const uint bank_offset_a = MEMORY_BANK_OFFSET(local_index_a);
    const uint bank_offset_b = MEMORY_BANK_OFFSET(local_index_b);
    
    shared_data[local_index_a + bank_offset_a] = input_data[global_index_a]; 
    shared_data[local_index_b + bank_offset_b] = input_data[global_index_b]; 
}

void 
LoadLocalFromGlobalFirstLevel(
                              __local int *shared_data,
                              __global const int *input_data, 
                              const uint4 address_pair,
                              const uint n)
{
    const uint global_index_a = address_pair.x; 
    const uint global_index_b = address_pair.y; 
    
    const uint local_index_a = address_pair.z; 
    const uint local_index_b = address_pair.w; 
    
    const uint bank_offset_a = MEMORY_BANK_OFFSET(local_index_a);
    const uint bank_offset_b = MEMORY_BANK_OFFSET(local_index_b);
    
    int input_data_a = input_data[global_index_a]; 
    int input_data_b = input_data[global_index_b]; 
    
	shared_data[local_index_a + bank_offset_a] = input_data_a>-1 ? 1 : 0; 
    shared_data[local_index_b + bank_offset_b] = input_data_b>-1 ? 1 : 0; 
}

void 
LoadLocalFromGlobalNonPowerOfTwo(
                                 __local int *shared_data,
                                 __global const int *input_data, 
                                 const uint4 address_pair,
                                 const uint n)
{
    const uint global_index_a = address_pair.x; 
    const uint global_index_b = address_pair.y; 
    
    const uint local_index_a = address_pair.z; 
    const uint local_index_b = address_pair.w; 
    
    const uint bank_offset_a = MEMORY_BANK_OFFSET(local_index_a);
    const uint bank_offset_b = MEMORY_BANK_OFFSET(local_index_b);
    
    shared_data[local_index_a + bank_offset_a] = input_data[global_index_a]; 
    shared_data[local_index_b + bank_offset_b] = (local_index_b < n) ? input_data[global_index_b] : 0; 
	
	barrier(CLK_LOCAL_MEM_FENCE);
}

void 
LoadLocalFromGlobalNonPowerOfTwoFirstLevel(
                                           __local int *shared_data,
                                           __global const int *input_data, 
                                           const uint4 address_pair,
                                           const uint n)
{
    const uint global_index_a = address_pair.x; 
    const uint global_index_b = address_pair.y; 
    
    const uint local_index_a = address_pair.z; 
    const uint local_index_b = address_pair.w; 
    
    const uint bank_offset_a = MEMORY_BANK_OFFSET(local_index_a);
    const uint bank_offset_b = MEMORY_BANK_OFFSET(local_index_b);
    
    int input_data_a = input_data[global_index_a]; 
    
	shared_data[local_index_a + bank_offset_a] = input_data_a>-1 ? 1 : 0; 
	if (local_index_b<n)
	{
	    int input_data_b = input_data[global_index_b]; 
		shared_data[local_index_b + bank_offset_b] = input_data_b>-1 ? 1 : 0; 
	}
	else
		shared_data[local_index_b + bank_offset_b] = 0; 
	
	barrier(CLK_LOCAL_MEM_FENCE);
}

void 
StoreLocalToGlobal(
                   __global int* output_data, 
                   __local const int* shared_data,
                   const uint4 address_pair,
                   const uint n)
{
    barrier(CLK_LOCAL_MEM_FENCE);
    
    const uint global_index_a = address_pair.x; 
    const uint global_index_b = address_pair.y; 
    
    const uint local_index_a = address_pair.z; 
    const uint local_index_b = address_pair.w; 
    
    const uint bank_offset_a = MEMORY_BANK_OFFSET(local_index_a);
    const uint bank_offset_b = MEMORY_BANK_OFFSET(local_index_b);
    
    output_data[global_index_a] = shared_data[local_index_a + bank_offset_a]; 
    output_data[global_index_b] = shared_data[local_index_b + bank_offset_b]; 
}

void 
StoreLocalToGlobalFirstLevel(
                             __global int* output_data, 
                             __local const int* shared_data,
                             const uint4 address_pair,
                             const uint n)
{
    barrier(CLK_LOCAL_MEM_FENCE);
    
    const uint global_index_a = address_pair.x; 
    const uint global_index_b = address_pair.y; 
    
    const uint local_index_a = address_pair.z; 
    const uint local_index_b = address_pair.w; 
    
    const uint bank_offset_a = MEMORY_BANK_OFFSET(local_index_a);
    const uint bank_offset_b = MEMORY_BANK_OFFSET(local_index_b);
    
    output_data[global_index_a] = shared_data[local_index_a + bank_offset_a]; 
    output_data[global_index_b] = shared_data[local_index_b + bank_offset_b]; 
}

void 
StoreLocalToGlobalNonPowerOfTwo(
                                __global int* output_data, 
                                __local const int* shared_data,
                                const uint4 address_pair,
                                const uint n)
{
    barrier(CLK_LOCAL_MEM_FENCE);
    
    const uint global_index_a = address_pair.x; 
    const uint global_index_b = address_pair.y; 
    
    const uint local_index_a = address_pair.z; 
    const uint local_index_b = address_pair.w; 
    
    const uint bank_offset_a = MEMORY_BANK_OFFSET(local_index_a);
    const uint bank_offset_b = MEMORY_BANK_OFFSET(local_index_b);
    
    output_data[global_index_a] = shared_data[local_index_a + bank_offset_a]; 
    if(local_index_b < n)
        output_data[global_index_b] = shared_data[local_index_b + bank_offset_b]; 
}

void 
StoreLocalToGlobalNonPowerOfTwoFirstLevel(
                                          __global int* output_data, 
                                          __local const int* shared_data,
                                          const uint4 address_pair,
                                          const uint n)
{
    barrier(CLK_LOCAL_MEM_FENCE);
    
    const uint global_index_a = address_pair.x; 
    const uint global_index_b = address_pair.y; 
    
    const uint local_index_a = address_pair.z; 
    const uint local_index_b = address_pair.w; 
    
    const uint bank_offset_a = MEMORY_BANK_OFFSET(local_index_a);
    const uint bank_offset_b = MEMORY_BANK_OFFSET(local_index_b);
    
    output_data[global_index_a] = shared_data[local_index_a + bank_offset_a]; 
    if(local_index_b < n)
        output_data[global_index_b] = shared_data[local_index_b + bank_offset_b]; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void 
ClearLastElement(
                 __local int* shared_data, 
                 int group_index)
{
    const uint local_id = get_local_id(0);
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    
    if (local_id == 0)
    {
        int index = (group_size << 1) - 1;
        index += MEMORY_BANK_OFFSET(index);
        shared_data[index] = 0;
    }
}

void 
ClearLastElementStoreSum(
                         __local int* shared_data, 
                         __global int *partial_sums, 
                         int group_index)
{
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    const uint local_id = get_local_id(0); 
    
    if (local_id == 0)
    {
        int index = (group_size << 1) - 1;
        index += MEMORY_BANK_OFFSET(index);
        partial_sums[group_index] = shared_data[index];
        shared_data[index] = 0;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

uint 
BuildPartialSum(
                __local int *shared_data)
{
    const uint local_id = get_local_id(0);
    const uint group_size = get_local_size(0);
    const uint two = 2;
    uint stride = 1;
    
    for (uint j = group_size; j > 0; j >>= 1)
    {
        barrier(CLK_LOCAL_MEM_FENCE);
        
        if (local_id < j)      
        {
            int i  = mul24(mul24(two, stride), local_id);
            
            uint local_index_a = i + stride - 1;
            uint local_index_b = local_index_a + stride;
            
            local_index_a += MEMORY_BANK_OFFSET(local_index_a);
            local_index_b += MEMORY_BANK_OFFSET(local_index_b);
            
            shared_data[local_index_b] += shared_data[local_index_a];
        }
        
        stride *= two;
    }
    
    return stride;
}

void 
ScanRootToLeaves(
                 __local int *shared_data, 
                 uint stride)
{
    const uint local_id = get_local_id(0);
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    const uint two = 2;
    
    for (uint j = 1; j <= group_size; j *= two)
    {
        stride >>= 1;
        
        barrier(CLK_LOCAL_MEM_FENCE);
        
        if (local_id < j)
        {
            int i  = mul24(mul24(two, stride), local_id);
            
            uint local_index_a = i + stride - 1;
            uint local_index_b = local_index_a + stride;
            
            local_index_a += MEMORY_BANK_OFFSET(local_index_a);
            local_index_b += MEMORY_BANK_OFFSET(local_index_b);
            
            int t = shared_data[local_index_a];
            shared_data[local_index_a] = shared_data[local_index_b];
            shared_data[local_index_b] += t;
        }
    }
}

void 
PreScanGroup(
             __local int *shared_data, 
             int group_index)
{
    const uint group_id = get_global_id(0) / get_local_size(0);
    
    int stride = BuildPartialSum(shared_data);               
    ClearLastElement(shared_data, (group_index == 0) ? group_id : group_index);
    ScanRootToLeaves(shared_data, stride);             
}

void 
PreScanGroupStoreSum(
                     __global int *partial_sums,
                     __local int *shared_data, 
                     int group_index) 
{
    const uint group_id = get_global_id(0) / get_local_size(0);
    
    int stride = BuildPartialSum(shared_data);               
    ClearLastElementStoreSum(shared_data, partial_sums, (group_index == 0) ? group_id : group_index);
    ScanRootToLeaves(shared_data, stride);             
}

////////////////////////////////////////////////////////////////////////////////////////////////////

__kernel void 
PreScanKernelFirstLevel(
                        __global int *output_data, 
                        __global const int *input_data, 
                        __local int* shared_data,
                        const uint  group_index, 
                        const uint  base_index,
                        const uint  n,
                        const uint  addr_offset)
{
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    
    uint local_index = (base_index == 0) ? mul24(group_id, (group_size << 1)) : base_index;
	local_index += addr_offset;
    uint4 address_pair = GetAddressMapping(local_index);
    
    LoadLocalFromGlobalFirstLevel(shared_data, input_data, address_pair, n); 
    PreScanGroup(shared_data, group_index); 
    StoreLocalToGlobalFirstLevel(output_data, shared_data, address_pair, n);
}

__kernel void 
PreScanKernel(
              __global int *output_data, 
              __global const int *input_data, 
              __local int* shared_data,
              const uint  group_index, 
              const uint  base_index,
              const uint  n,
              const uint  addr_offset)
{
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    
    uint local_index = (base_index == 0) ? mul24(group_id, (group_size << 1)) : base_index;
	local_index += addr_offset;
    uint4 address_pair = GetAddressMapping(local_index);
    
    LoadLocalFromGlobal(shared_data, input_data, address_pair, n); 
    PreScanGroup(shared_data, group_index); 
    StoreLocalToGlobal(output_data, shared_data, address_pair, n);
}

__kernel void 
PreScanStoreSumFirstLevelKernel(
                                __global int *output_data, 
                                __global const int *input_data, 
                                __global int *partial_sums, 
                                __local int* shared_data,
                                const uint group_index, 
                                const uint base_index,
                                const uint  n,
                                const uint  addr_offset)
{
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    
    uint local_index = (base_index == 0) ? mul24(group_id, (group_size << 1)) : base_index;
	local_index += addr_offset;
    uint4 address_pair = GetAddressMapping(local_index);
    
    LoadLocalFromGlobalFirstLevel(shared_data, input_data, address_pair, n); 
    PreScanGroupStoreSum(partial_sums, shared_data, group_index); 
    StoreLocalToGlobalFirstLevel(output_data, shared_data, address_pair, n);
}

__kernel void 
PreScanStoreSumKernel(
                      __global int *output_data, 
                      __global const int *input_data, 
                      __global int *partial_sums, 
                      __local int* shared_data,
                      const uint group_index, 
                      const uint base_index,
                      const uint  n,
                      const uint  addr_offset)
{
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    
    uint local_index = (base_index == 0) ? mul24(group_id, (group_size << 1)) : base_index;
	local_index += addr_offset;
    uint4 address_pair = GetAddressMapping(local_index);
    
    LoadLocalFromGlobal(shared_data, input_data, address_pair, n); 
    PreScanGroupStoreSum(partial_sums, shared_data, group_index); 
    StoreLocalToGlobal(output_data, shared_data, address_pair, n);
}

__kernel void 
PreScanStoreSumNonPowerOfTwoFirstLevelKernel(
                                             __global int *output_data, 
                                             __global const int *input_data, 
                                             __global int *partial_sums, 
                                             __local int* shared_data,
                                             const uint group_index, 
                                             const uint base_index,
                                             const uint  n,
                                             const uint  addr_offset)
{
    const uint local_id = get_local_id(0);
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    
    uint local_index = (base_index == 0) ? mul24(group_id, (group_size << 1)) : base_index;
	local_index += addr_offset;
    uint4 address_pair = GetAddressMapping(local_index);
    
    LoadLocalFromGlobalNonPowerOfTwoFirstLevel(shared_data, input_data, address_pair, n); 
    PreScanGroupStoreSum(partial_sums, shared_data, group_index); 
    StoreLocalToGlobalNonPowerOfTwoFirstLevel(output_data, shared_data, address_pair, n);
}

__kernel void 
PreScanStoreSumNonPowerOfTwoKernel(
                                   __global int *output_data, 
                                   __global const int *input_data, 
                                   __global int *partial_sums, 
                                   __local int* shared_data,
                                   const uint group_index, 
                                   const uint base_index,
                                   const uint  n,
                                   const uint  addr_offset)
{
    const uint local_id = get_local_id(0);
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    
    uint local_index = (base_index == 0) ? mul24(group_id, (group_size << 1)) : base_index;
	local_index += addr_offset;
    uint4 address_pair = GetAddressMapping(local_index);
    
    LoadLocalFromGlobalNonPowerOfTwo(shared_data, input_data, address_pair, n); 
    PreScanGroupStoreSum(partial_sums, shared_data, group_index); 
    StoreLocalToGlobalNonPowerOfTwo(output_data, shared_data, address_pair, n);
}

__kernel void 
PreScanNonPowerOfTwoKernelFirstLevel(
                                     __global int *output_data, 
                                     __global const int *input_data, 
                                     __local int* shared_data,
                                     const uint group_index, 
                                     const uint base_index,
                                     const uint  n,
                                     const uint  addr_offset)
{
    const uint local_id = get_local_id(0);
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    
    uint local_index = (base_index == 0) ? mul24(group_id, (group_size << 1)) : base_index;
	local_index += addr_offset;
    uint4 address_pair = GetAddressMapping(local_index);
    
    LoadLocalFromGlobalNonPowerOfTwoFirstLevel(shared_data, input_data, address_pair, n); 
    PreScanGroup(shared_data, group_index); 
    StoreLocalToGlobalNonPowerOfTwoFirstLevel(output_data, shared_data, address_pair, n);
}

__kernel void 
PreScanNonPowerOfTwoKernel(
                           __global int *output_data, 
                           __global const int *input_data, 
                           __local int* shared_data,
                           const uint group_index, 
                           const uint base_index,
                           const uint  n,
                           const uint  addr_offset)
{
    const uint local_id = get_local_id(0);
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    
    uint local_index = (base_index == 0) ? mul24(group_id, (group_size << 1)) : base_index;
	local_index += addr_offset;
    uint4 address_pair = GetAddressMapping(local_index);
    
    LoadLocalFromGlobalNonPowerOfTwo(shared_data, input_data, address_pair, n); 
    PreScanGroup(shared_data, group_index); 
    StoreLocalToGlobalNonPowerOfTwo(output_data, shared_data, address_pair, n);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

__kernel void UniformAddKernel(
                               __global int *output_data, 
                               __global int *input_data, 
                               __local int *shared_data,
                               const uint group_offset, 
                               const uint base_index,
                               const uint  n,
                               const uint  addr_offset)
{
    const uint local_id = get_local_id(0);
    const uint group_id = get_global_id(0) / get_local_size(0);
    const uint group_size = get_local_size(0);
    
    if (local_id == 0)
        shared_data[0] = input_data[group_id + group_offset];
    
    barrier(CLK_LOCAL_MEM_FENCE);
    
    uint address = mul24(group_id, (group_size << 1)) + base_index + local_id + addr_offset;
    
    output_data[address]              += shared_data[0];
	if( (local_id + group_size) < n)
		output_data[address + group_size] += shared_data[0];
}

////////////////////////////////////////////////////////////////////////////////////////////////////

__kernel void ParallelCompact( __global int *CompactIn_data,
                              __global int *CompactOut_data,
                              __global int *numUsefulNodes,
                              __global int *ScanResult_data, 
                              __global uint *LevelLength_data,
                              const uint max_level_length)
{
    const uint node_id = get_global_id(0);
	const uint move_id = get_global_id(1);
    
    int n=LevelLength_data[move_id]*2;
    
    if(n==0 && node_id==0) numUsefulNodes[move_id] = 0;
    
	if (node_id<n)
	{
		const uint offset = move_id * max_level_length;
        
		int data = CompactIn_data[offset + node_id];
		uint addr = ScanResult_data[offset + node_id];
		if (data>-1)
		{
			CompactOut_data[offset + addr] = data;
			addr++;
		}
		if (node_id==n-1)
			numUsefulNodes[move_id] = addr;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////

__kernel void ParallelCompactFinal( __global int *CompactIn_data,
                              __global int *CompactOut_data,
                              __global int *numUsefulNodes,
                              __global int *ScanResult_data, 
                              __global uint *LevelLength_data,
                              const uint max_level_length)
{
    const uint node_id = get_global_id(0);
	const uint move_id = get_global_id(1);
    
    int n=LevelLength_data[move_id];
    
    if(n==0 && node_id==0) numUsefulNodes[move_id] = 0;
    
	if (node_id<n)
	{
		const uint offset = move_id * max_level_length;
        
		int data = CompactIn_data[offset + node_id];
		uint addr = ScanResult_data[offset + node_id];
		if (data>-1)
		{
			CompactOut_data[offset + addr] = data;
			addr++;
		}
		if (node_id==n-1)
			numUsefulNodes[move_id] = addr;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/

/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/


#pragma OPENCL EXTENSION cl_amd_printf : enable

/// The maximum number of contact points between two convex shapes. Do
/// not change this value.
#define b2cl_maxManifoldPoints  2

/// The maximum number of vertices on a convex polygon. You cannot increase
/// this too much because b2BlockAllocator has a maximum object size.
#define b2cl_maxPolygonVertices 8

/// A velocity threshold for elastic collisions. Any collision with a relative linear
/// velocity below this threshold will be treated as inelastic.
//#define b2cl_velocityThreshold        0.01f
#define b2cl_velocityThreshold      1.0f

/// This is used to fatten AABBs in the dynamic tree. This is used to predict
/// the future position based on the current displacement.
/// This is a dimensionless multiplier.
#define b2cl_aabbMultiplier     2.0f

#define b2_maxFloat FLT_MAX
#define b2_epsilon FLT_EPSILON
#define b2_pi 3.14159265359f
#define b2_maxTranslation 2.0f
#define b2_maxRotation 0.5f*b2_pi
#define b2_baumgarte 0.2f
#define b2_linearSlop 0.005f
#define b2_angularSlop          (2.0f / 180.0f * b2_pi)
#define b2_polygonRadius        (2.0f * b2_linearSlop)
#define b2_maxLinearCorrection 0.2f
#define b2_maxAngularCorrection     (8.0f / 180.0f * b2_pi)

#ifndef MAXFLOAT
#define MAXFLOAT      3.402823466e+38F
#endif


/// The features that intersect to form the contact point
/// This must be 4 bytes or less.
typedef struct b2clContactFeature
{
    uchar indexA;       ///< Feature index on shapeA
    uchar indexB;       ///< Feature index on shapeB
    uchar typeA;        ///< The feature type on shapeA
    uchar typeB;        ///< The feature type on shapeB
} b2clContactFeature;

/// Contact ids to facilitate warm starting.
typedef union b2clContactID
{
    b2clContactFeature cf;
    uint key;                   ///< Used to quickly compare contact ids.
} b2clContactID;

/// A manifold point is a contact point belonging to a contact
/// manifold. It holds details related to the geometry and dynamics
/// of the contact points.
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleB
/// -e_faceA: the local center of cirlceB or the clip point of polygonB
/// -e_faceB: the clip point of polygonA
/// This structure is stored across time steps, so we keep it small.
/// Note: the impulses are used for internal caching and may not
/// provide reliable contact forces, especially for high speed collisions.
typedef struct b2clManifoldPoint
{
    float2 localPoint;      ///< usage depends on manifold type
    float normalImpulse;    ///< the non-penetration impulse
    float tangentImpulse;   ///< the friction impulse
    b2clContactID id;           ///< uniquely identifies a contact point between two shapes
    float dummy; // for alignment
} b2clManifoldPoint;

/// A manifold for two touching convex shapes.
/// Box2D supports multiple types of contact:
/// - clip point versus plane with radius
/// - point versus point with radius (circles)
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleA
/// -e_faceA: the center of faceA
/// -e_faceB: the center of faceB
/// Similarly the local normal usage:
/// -e_circles: not used
/// -e_faceA: the normal on polygonA
/// -e_faceB: the normal on polygonB
/// We store contacts in this way so that position correction can
/// account for movement, which is critical for continuous physics.
/// All contact scenarios must be expressed in one of these types.
/// This structure is stored across time steps, so we keep it small.
typedef struct b2clManifold
{
    float2 localNormal;                             ///< not use for Type::e_points
    float2 localPoint;                              ///< usage depends on manifold type
    b2clManifoldPoint points[b2cl_maxManifoldPoints];   ///< the points of contact
    int type;
    int pointCount;                             ///< the number of manifold points
    //float2 test;
} b2clManifold;

typedef struct b2clFilter
{
    unsigned short categoryBits;
    unsigned short maskBits;
    short groupIndex;
    short dummy;
} b2clFilter;

/// A convex polygon. It is assumed that the interior of the polygon is to
/// the left of each edge.
/// Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.
/// In most cases you should not need many vertices for a convex polygon.
//////////////
/// We reuse b2clPolygonShape for b2clCircleShape
/// We may have to change this later
typedef struct b2clPolygonShape
{
    float2 m_centroid;
    float2 m_vertices[b2cl_maxPolygonVertices];
    float2 m_normals[b2cl_maxPolygonVertices];
    int m_type;
    float m_radius;
    int m_vertexCount;
    int m_bIsSensor;
    b2clFilter m_filter;
} b2clPolygonShape;

/// A transform contains translation and rotation. It is used to represent
/// the position and orientation of rigid frames.
typedef struct b2clTransform
{
    float2 p;
    float2 q;
} b2clTransform;

/// This describes the motion of a body/shape for TOI computation.
/// Shapes are defined with respect to the body origin, which may
/// no coincide with the center of mass. However, to support dynamics
/// we must interpolate the center of mass position.
typedef struct b2clSweep
{
    float2 localCenter; ///< local center of mass position
    float2 c0, c;       ///< center world positions
    float a0, a;        ///< world angles

    /// Fraction of the current time step in the range [0,1]
    /// c0 and a0 are the positions at alpha0.
    float alpha0;
    float dummy;
}  b2clSweep;

/// Used for computing contact manifolds.
typedef struct b2clClipVertex
{
    float2 v;
    b2clContactID id;
} b2clClipVertex;

typedef struct clb2Velocity
{
    float vx;
    float vy;
    float w;
}clb2Velocity;

typedef struct clb2Position
{
    float cx;
    float cy;
    float a;
}clb2Position;

typedef struct clb2Contact
{
    int color;
    int indexA;
    int indexB;
    float friction;
    float2 normal;
    float invMassA;
    float invIA;
    float invMassB;
    float invIB;
}clb2Contact;

typedef struct clb2Impulse
{
    float normalImpulse1;
    float tangentImpulse1;
    
    float normalImpulse2;
    float tangentImpulse2;
}clb2Impulse;

typedef struct clb2Points
{
    float2 rA1;
    float2 rB1;
    float normalMass1;
    float tangentMass1;
    
    float2 rA2;
    float2 rB2;
    float normalMass2;
    float tangentMass2;
    
    float velocityBias1;
    float velocityBias2;
}clb2Points;

typedef struct b2clFixtureStatic
{
    float m_friction;
    float m_restitution;
    int m_last_uid;
    int dummy; 
} b2clFixtureStatic;

#define MAX_CONNECTED_BODY_INDICES 8
typedef struct b2clBodyStatic
{
    float2 m_localCenter;   ///< local center of mass position
    float /*m_mass,*/ m_invMass;
    // Rotational inertia about the center of mass.
    float /*m_I,*/ m_invI;
    float m_linearDamping;
    float m_angularDamping;
    float m_gravityScale;
    float m_type;
    int m_connectedBodyIndices[MAX_CONNECTED_BODY_INDICES];
    int m_bIsBullet;
    int dummy;
} b2clBodyStatic;

typedef struct b2clBodyDynamic
{
    b2clSweep m_sweep;      // the swept motion for CCD

    float2 m_linearVelocity;
    float2 m_force;
    float m_angularVelocity;
    float m_torque;
    int m_last_uid ;
    int dummy ; 
} b2clBodyDynamic;

// Extract useful information of manifolds for position constraint solver
typedef struct clb2Manifold
{
    float2 localNormal;
    float2 localPoint;
    float2 localPoints1;
    float2 localPoints2;
    int pointCount;
    int type;
    float radiusA;
    float radiusB;
    float2 localCenterA;
    float2 localCenterB;
}clb2Manifold;

typedef struct{
    int type;
    int pointCount;
    float localPointX;
    float localPointY;
    float localNormalX;
    float localNormalY; 
    float point0X;
    float point0Y;
    float point1X;
    float point1Y; 
}clb2SDManifold;

typedef struct{
    int fixtureAIndex;
    int fixtureBIndex;
    int bodyAIndex ; 
    int bodyBIndex ; 
}clb2SDContact;

typedef struct{
    int bodyIndex ;
    float posX;
    float posY ; 
    float posAngle;
    float xfX;
    float xfY;
    float xfS;
    float xfC;
    float alpha;
    float velocityX;
    float velocityY;
    float velocityAngular; 
}clb2SDBody;

typedef struct clb2PositionSolverManifold
{
    float2 normal;
    float2 point;
    float separation;
}clb2PositionSolverManifold;

typedef struct clb2Rotation
{
    float s;
    float c;
}clb2Rotation;

typedef struct clb2Transform
{
    clb2Rotation rotation;
    float2 translation;
}clb2Transform;

typedef struct b2clMat22
{
    float ex[2];
    float ey[2];
}b2clMat22;

typedef struct b2clMat33
{
    float ex[3];
    float ey[3];
    float ez[3];
}b2clMat33;

enum b2clLimitState
{
    e_inactiveLimit,
    e_atLowerLimit,
    e_atUpperLimit,
    e_equalLimits
};

enum b2JointType
{
    e_unknownJoint,
    e_revoluteJoint,
    e_prismaticJoint,
    e_distanceJoint,
    e_pulleyJoint,
    e_mouseJoint,
    e_gearJoint,
    e_wheelJoint,
    e_weldJoint,
    e_frictionJoint,
    e_ropeJoint
};

typedef struct b2clDistanceJointDatastruct
{
    float frequencyHz;
    float dampingRatio;
    float bias;

    float localAnchorA[2];
    float localAnchorB[2];
    float gamma;
    float nlength;

    float u[2];
    float rA[2];
    float rB[2];
    float localCenterA[2];
    float localCenterB[2];
    float invMassA;
    float invMassB;
    float invIA;
    float invIB;
    float mass;
} b2clDistanceJointData;

typedef struct b2clRevoluteJointData
{
    float localAnchorA[2];
    float localAnchorB[2];

    int enableMotor;
    float maxMotorTorque;
    float motorSpeed;

    int enableLimit;
    float referenceAngle;
    float lowerAngle;
    float upperAngle;

    // Solver temp
    float rA[2];
    float rB[2];
    float localCenterA[2];
    float localCenterB[2];
    float invMassA;
    float invMassB;
    float invIA;
    float invIB;
    b2clMat33 mass;         // effective mass for point-to-point constraint.
    float motorMass;    // effective mass for motor/limit angular constraint.
    int limitState;
} b2clRevoluteJointData;

typedef struct b2clPrismaticJointData
{
    // Solver shared
    float localAnchorA[2];
    float localAnchorB[2];
    float localXAxisA[2];
    float localYAxisA[2];
    float referenceAngle;
    float lowerTranslation;
    float upperTranslation;
    float maxMotorForce;
    float motorSpeed;
    int enableLimit;
    int enableMotor;
    int limitState;

    // Solver temp
    float localCenterA[2];
    float localCenterB[2];
    float invMassA;
    float invMassB;
    float invIA;
    float invIB;
    float axis[2], perp[2];
    float s1, s2;
    float a1, a2;
    b2clMat33 K;
    float motorMass;
} b2clPrismaticJointData;

typedef struct b2clGearJointData
{
    int joint1;
    int joint2;
    int typeA;
    int typeB;

    float localAnchorA[2];
    float localAnchorB[2];
    float localAnchorC[2];
    float localAnchorD[2];

    float localAxisC[2];
    float localAxisD[2];

    float referenceAngleA;
    float referenceAngleB;

    float gearConstant;
    float ratio;

    // Solver temp
    float lcA[2], lcB[2], lcC[2], lcD[2];
    float mA, mB, mC, mD;
    float iA, iB, iC, iD;
    float JvAC[2], JvBD[2];
    float JwA, JwB, JwC, JwD;
    float mass;
} b2clGearJointData;

typedef struct b2clPulleyJointData
{
    float groundAnchorA[2];
    float groundAnchorB[2];
    float lengthA;
    float lengthB;
    float localAnchorA[2];
    float localAnchorB[2]; 
    float pulleyConstant; 
    float ratio; 
    float uA[2]; 
    float uB[2]; 
    float rA[2]; 
    float rB[2]; 
    float localCenterA[2];
    float localCenterB[2]; 
    float invMassA; 
    float invMassB; 
    float invIA; 
    float invIB;
    float mass; 
}b2clPulleyJointData; 

typedef struct b2clRopeJointData
{   
    float localAnchorA[2];
    float localAnchorB[2]; 
    float maxLength; 
    float nlength;
    float u[2]; 
    float rA[2]; 
    float rB[2]; 
    float localCenterA[2];
    float localCenterB[2]; 
    float invMassA; 
    float invMassB; 
    float invIA; 
    float invIB;
    float mass; 
    int limitState; 
} b2clRopeJointData; 

typedef struct b2clWheelJointData
{
    float frequencyHz;
    float dampingRatio;

    // Solver shared
    float localAnchorA[2];
    float localAnchorB[2];
    float localXAxisA[2];
    float localYAxisA[2];

    float maxMotorTorque;
    float motorSpeed;
    int enableMotor;

    // Solver temp
    float localCenterA[2];
    float localCenterB[2];
    float invMassA;
    float invMassB;
    float invIA;
    float invIB;

    float ax[2], ay[2];
    float sAx, sBx;
    float sAy, sBy;

    float mass;
    float motorMass;
    float springMass;

    float bias;
    float gamma;
} b2clWheelJointData;

typedef struct b2clWeldJointData
{
    float frequencyHz;
    float dampingRatio;
    float bias;

    // Solver shared
    float localAnchorA[2];
    float localAnchorB[2];
    float referenceAngle;
    float gamma;

    // Solver temp
    float rA[2];
    float rB[2];
    float localCenterA[2];
    float localCenterB[2];
    float invMassA;
    float invMassB;
    float invIA;
    float invIB;
    b2clMat33 mass;
} b2clWeldJointData;

typedef struct b2clMouseJointData
{
    float localAnchorB[2];
    float targetA[2];
    float frequencyHz;
    float dampingRatio;
    float beta;
    
    // Solver shared
    float maxForce;
    float gamma;

    // Solver temp
    float rB[2];
    float localCenterB[2];
    float invMassB;
    float invIB;
    b2clMat22 mass;
    float C[2];
} b2clMouseJointData;

typedef struct b2clFrictionJointData
{
    float localAnchorA[2];
    float localAnchorB[2];

    float maxForce; 
    float maxTorque; 

    // Solver temp
    float rA[2];
    float rB[2];
    float localCenterA[2];
    float localCenterB[2];
    float invMassA;
    float invMassB;
    float invIA;
    float invIB;
    b2clMat22 linearMass;
    float angularMass; 
} b2clFrictionJointData;

typedef struct clJoint
{
    int index;

    // impulse : 4 floats
    union a1{
        struct x1{
            float impulse[3];
        }x;
        struct y1{
            float scalarImpulse;
            float springImpulse;
        }y;
        struct z1{
            float linearImpulse[2];
            float angularImpulse;
        }z;
    }a;
    float motorImpulse;

    int color;
    int type;
    int collideConnected;

    int indexA, indexB, indexC, indexD;

    union b1{
        b2clDistanceJointData distanceJointData;
        b2clRevoluteJointData revoluteJointData;
        b2clPrismaticJointData prismaticJointData;
        b2clGearJointData gearJointData;
        b2clPulleyJointData pulleyJointData;
        b2clRopeJointData ropeJointData;
        b2clWheelJointData wheelJointData;
        b2clWeldJointData weldJointData;
        b2clMouseJointData mouseJointData;
        b2clFrictionJointData frictionJointData;
    }b;
} b2clJoint;

typedef struct
{
    int index;
    float nimpulse[4];
} b2clJointImpulseNode;

typedef struct
{
    int isCollide;
    float normal[2];
    float fraction;
    unsigned int shapeIndex;
} b2clRayCastOutput;

typedef struct
{
    float2 m_buffer[2];
    float2 m_vertices[b2cl_maxPolygonVertices];
    int m_count;
    float m_radius;
} b2clDistanceProxy;

typedef struct 
{
    float metric;       ///< length or area
    short count;
    unsigned char indexA[3];    ///< vertices on shape A
    unsigned char indexB[3];    ///< vertices on shape B
} b2clSimplexCache;

/// Input for b2Distance.
/// You have to option to use the shape radii
/// in the computation. Even 
typedef struct 
{
    b2clDistanceProxy proxyA;
    b2clDistanceProxy proxyB;
    b2clTransform transformA;
    b2clTransform transformB;
    bool useRadii;
} b2clDistanceInput;

/// Output for b2Distance.
typedef struct
{
    float2 pointA;      ///< closest point on shapeA
    float2 pointB;      ///< closest point on shapeB
    float ndistance;
    int iterations; ///< number of GJK iterations used
} b2clDistanceOutput;

typedef struct
{
    b2clDistanceProxy proxyA;
    b2clDistanceProxy proxyB;
    b2clSweep sweepA;
    b2clSweep sweepB;
    float tMax;     // defines sweep interval [0, tMax]
    float dummy;
} b2clTOIInput;

enum b2clTOIOutputState
{
    e_unknown,
    e_failed,
    e_overlapped,
    e_touching,
    e_separated
};

typedef struct
{
    int state;
    float t;
} b2clTOIOutput;

typedef struct
{
    float2 wA;      // support point in proxyA
    float2 wB;      // support point in proxyB
    float2 w;       // wB - wA
    float a;        // barycentric coordinate for closest point
    int indexA; // wA index
    int indexB; // wB index
} b2clSimplexVertex;

typedef struct 
{
    b2clSimplexVertex m_v1, m_v2, m_v3;
    int m_count;
} b2clSimplex;

//typedef struct{
//float v[30];
//} testData; 

//==============================================================================================
// Math functions
//==============================================================================================

/// Multiply two rotations: q * r
inline float2 b2clMul_TwoRotation(const float2 q, const float2 r)
{
    // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
    // [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]
    // s = qs * rc + qc * rs
    // c = qc * rc - qs * rs
    float2 qr;
    qr.x = q.x * r.y + q.y * r.x;
    qr.y = q.y * r.y - q.x * r.x;
    return qr;
}

/// Transpose multiply two rotations: qT * r
inline float2 b2clMulT_TwoRotation(const float2 q, const float2 r)
{
    // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
    // [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]
    // s = qc * rs - qs * rc
    // c = qc * rc + qs * rs
    float2 qr;
    qr.x = q.y * r.x - q.x * r.y;
    qr.y = q.y * r.y + q.x * r.x;
    return qr;
}

/// Rotate a vector
inline float2 b2clMul_Rotate(const float2 q, const float2 v)
{
    float2 result;
    result.x = q.y * v.x - q.x * v.y;
    result.y = q.x * v.x + q.y * v.y;

    return result;
}

/// Inverse rotate a vector
inline float2 b2clMulT_Rotate(const float2 q, const float2 v)
{
    float2 result;
    result.x = q.y * v.x + q.x * v.y;
    result.y = -q.x * v.x + q.y * v.y;

    return result;
}

/// Transform a vector
inline float2 b2clMul_Transform(const b2clTransform *T, const float2 v)
{
    float2 result;
    result.x = (T->q.y * v.x - T->q.x * v.y) + T->p.x;
    result.y = (T->q.x * v.x + T->q.y * v.y) + T->p.y;

    return result;
}

/// Invert transform a vector
inline float2 b2clMulT_Transform(const b2clTransform *T, const float2 v)
{
    float px = v.x - T->p.x;
    float py = v.y - T->p.y;
    float2 result;
    result.x = (T->q.y * px + T->q.x * py);
    result.y = (-T->q.x * px + T->q.y * py);

    return result;
}

// v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
//    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
inline b2clTransform b2clMul_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
    b2clTransform C;
    C.q = b2clMul_TwoRotation(A->q, B->q);
    C.p = b2clMul_TwoRotation(A->q, B->p) + A->p;
    return C;
}

// v2 = A.q' * (B.q * v1 + B.p - A.p)
//    = A.q' * B.q * v1 + A.q' * (B.p - A.p)
inline b2clTransform b2clMulT_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
    b2clTransform C;
    C.q = b2clMulT_TwoRotation(A->q, B->q);
    C.p = b2clMulT_TwoRotation(A->q, B->p - A->p);
    return C;
}

/// Perform the dot product on two vectors.
inline float b2clDot(const float2 a, const float2 b)
{
    return a.x * b.x + a.y * b.y;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float b2clCross_VV(const float2 a, const float2 b)
{
    return a.x * b.y - a.y * b.x;
}

/// Perform the cross product on a vector and a scalar. In 2D this produces
/// a vector.
inline float2 b2clCross_VS(const float2 a, float s)
{
    return (float2)(s * a.y, -s *a.x);
}

/// Perform the cross product on a scalar and a vector. In 2D this produces
/// a vector.
inline float2 b2clCross_SV(float s, const float2 a)
{
    return (float2)(-s * a.y, s * a.x);
}

inline float b2clClamp(float a, float low, float high)
{
    return max(low, min(a, high));
}

inline float2 b2clMin(const float2 a, const float2 b)
{
    return (float2)(min(a.x, b.x), min(a.y, b.y));
}

inline float2 b2clMax(const float2 a, const float2 b)
{
    return (float2)(max(a.x, b.x), max(a.y, b.y));
}

inline float b2clDistanceSquared(const float2 a, const float2 b)
{
    float2 c = a - b;
    return b2clDot(c, c);
}

inline float b2clDistance(const float2 a, const float2 b)
{
    float2 c = a - b;
    return sqrt(b2clDot(c, c));
}

inline float b2clLengthSquared(const float2 v)
{
    return b2clDot(v, v);
}

inline float b2clAbs(float a)
{
    return a > 0.0f ? a : -a;
}

/// Perform the dot product on two vectors.
inline float b2clDot3(const float3 a, const float3 b)
{
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float3 b2clCross3_VV(const float3 a, const float3 b)
{
    return (float3)(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float3 b2clMat33Solve(const b2clMat33 mat, const float3 b)
{
    float3 ex = (float3)(mat.ex[0], mat.ex[1], mat.ex[2]);
    float3 ey = (float3)(mat.ey[0], mat.ey[1], mat.ey[2]);
    float3 ez = (float3)(mat.ez[0], mat.ez[1], mat.ez[2]);

    float det = b2clDot3(ex, b2clCross3_VV(ey, ez));

    if (det != 0.0f)
    {
        det = 1.0f / det;
    }
    float3 x;
    x.x = det * b2clDot3(b, b2clCross3_VV(ey, ez));
    x.y = det * b2clDot3(ex, b2clCross3_VV(b, ez));
    x.z = det * b2clDot3(ex, b2clCross3_VV(ey, b));
    return x;
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float2 b2clMat33Solve22(const b2clMat33 mat, const float2 b)
{
    float2 ex = (float2)(mat.ex[0], mat.ex[1]);
    float2 ey = (float2)(mat.ey[0], mat.ey[1]);

    float det = ex.x * ey.y - ey.x * ex.y;
    if (det != 0.0f)
    {
        det = 1.0f / det;
    }
    float2 x;
    x.x = det * (ey.y * b.x - ey.x * b.y);
    x.y = det * (ex.x * b.y - ex.y * b.x);
    return x;
}

inline float2 b2clMat22Solve(const b2clMat22 mat, const float2 b)
{
    float2 ex = (float2)(mat.ex[0], mat.ex[1]);
    float2 ey = (float2)(mat.ey[0], mat.ey[1]);

    float det = ex.x * ey.y - ey.x * ex.y;
    if (det != 0.0f)
    {
        det = 1.0f / det;
    }
    float2 x;
    x.x = det * (ey.y * b.x - ey.x * b.y);
    x.y = det * (ex.x * b.y - ex.y * b.x);
    return x;
}

inline float2 b2clMat33Mul22(const b2clMat33 A, const float2 v)
{
    return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float2 b2clMat22Mul(const b2clMat22 A, const float2 v)
{
    return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline void b2clGetInverse22(const b2clMat33 in, b2clMat33* out)
{
    float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
    float det = a * d - b * c;
    if (det != 0.0f)
    {
        det = 1.0f / det;
    }

    out->ex[0] =  det * d;  out->ey[0] = -det * b; out->ex[2] = 0.0f;
    out->ex[1] = -det * c;  out->ey[1] =  det * a; out->ey[2] = 0.0f;
    out->ez[0] = 0.0f; out->ez[1] = 0.0f; out->ez[2] = 0.0f;
}

inline void b2clGetSymInverse33(const b2clMat33 in, b2clMat33* out)
{
    //float det = b2clDot(ex, b2clCross(ey, ez));
    float det = in.ex[0] * (in.ey[1] * in.ez[2] - in.ey[2] * in.ez[1]) 
        + in.ex[1] * (in.ey[2] * in.ez[0] - in.ey[0] * in.ez[2]) 
        + in.ex[2] * (in.ey[0] * in.ez[1] - in.ey[1] * in.ez[0]);

    if (det != 0.0f)
    {
        det = 1.0f / det;
    }

    float a11 = in.ex[0], a12 = in.ey[0], a13 = in.ez[0];
    float a22 = in.ey[1], a23 = in.ez[1];
    float a33 = in.ez[2];

    out->ex[0] = det * (a22 * a33 - a23 * a23);
    out->ex[1] = det * (a13 * a23 - a12 * a33);
    out->ex[2] = det * (a12 * a23 - a13 * a22);

    out->ey[0] = out->ex[1];
    out->ey[1] = det * (a11 * a33 - a13 * a13);
    out->ey[2] = det * (a13 * a12 - a11 * a23);

    out->ez[0] = out->ex[2];
    out->ez[1] = out->ey[2];
    out->ez[2] = det * (a11 * a22 - a12 * a12);
}

inline float2 b2clMat33MulV2(const b2clMat33 A, const float2 v)
{
    return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float3 b2clMat33MulV3(const b2clMat33 A, const float3 v)
{
    //return v.x * A.ex + v.y * A.ey + v.z * A.ez;
    return (float3)(A.ex[0] * v.x + A.ey[0] * v.y + A.ez[0] * v.z,
        A.ex[1] * v.x + A.ey[1] * v.y + A.ez[1] * v.z,
        A.ex[2] * v.x + A.ey[2] * v.y + A.ez[2] * v.z);
}

inline void b2clMat22GetInverse(const b2clMat22 in, b2clMat22* out)
{
    float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
    float det = a * d - b * c;
    if (det != 0.0f)
    {
        det = 1.0f / det;
    }
    out->ex[0] =  det * d;  out->ey[0] = -det * b;
    out->ex[1] = -det * c;  out->ey[1] =  det * a;
}

inline void b2clSweepNormalize(b2clSweep* sweep)
{
    float twoPi = 2.0f * b2_pi;
    float d =  twoPi * floor(sweep->a0 / twoPi);
    sweep->a0 -= d;
    sweep->a -= d;
}

inline void b2clSweepGetTransform(b2clSweep* sweep, b2clTransform* xf, float beta)
{
    xf->p = (1.0f - beta) * sweep->c0 + beta * sweep->c;
    float angle = (1.0f - beta) * sweep->a0 + beta * sweep->a;
    xf->q.x = sin(angle);
    xf->q.y = cos(angle);

    // Shift to origin
    xf->p -= b2clMul_Rotate(xf->q, sweep->localCenter);
}

inline void b2clSweepAdvance(b2clSweep* sweep, float alpha)
{
    float beta = (alpha - sweep->alpha0) / (1.0f - sweep->alpha0);
    sweep->c0 = (1.0f - beta) * sweep->c0 + beta * sweep->c;
    sweep->a0 = (1.0f - beta) * sweep->a0 + beta * sweep->a;
    sweep->alpha0 = alpha;
}
inline void b2clBodySweepAdvance (b2clBodyDynamic* body, b2clTransform* xf, float alpha) {
    b2clSweepAdvance(&(body->m_sweep), alpha); 
    body->m_sweep.c = body->m_sweep.c0;
    body->m_sweep.a = body->m_sweep.a0;
    xf->q.x = sin (body->m_sweep.a);
    xf->q.y = cos (body->m_sweep.a); 
    xf->p = body->m_sweep.c - b2clMul_Rotate(xf->q, body->m_sweep.localCenter);
}

inline void b2clDistanceProxySet(b2clDistanceProxy* proxy, const b2clPolygonShape* shape)
{
    proxy->m_count = shape->m_vertexCount;
    proxy->m_radius = shape->m_radius;
    for (int i = 0; i < shape->m_vertexCount; ++i)
    {
        proxy->m_vertices[i] = shape->m_vertices[i];
    }
}

inline int b2clDistanceProxyGetSupport(const b2clDistanceProxy* proxy, float2 d)
{
    int bestIndex = 0;
    float bestValue = b2clDot(proxy->m_vertices[0], d);
    for (int i = 1; i < proxy->m_count; ++i)
    {
        float value = b2clDot(proxy->m_vertices[i], d);
        if (value > bestValue)
        {
            bestIndex = i;
            bestValue = value;
        }
    }
    return bestIndex;
}

inline float2 b2clDistanceProxyGetVertex(const b2clDistanceProxy* proxy, int index)
{
    return proxy->m_vertices[index];
}

// Convert a vector into a unit vector. Returns the length.
inline float b2clNormalize(float2* v)
{
    float length = sqrt(b2clDot(*v, *v));
    if (length < b2_epsilon)
    {
        return 0.0f;
    }
    float invLength = 1.0f / length;
    (*v).x *= invLength;
    (*v).y *= invLength;

    return length;
}

/*
inline float cos_wrapper(float a)
{
    //float sina = sin(a);
    //return sqrt(1-sina*sina);

    //return sin(1.5707963268-a);

    return cos(a);
}
*/

//#include <Box2D/Common/OpenCL/b2CLTypeDefOCL.h>

__kernel void IntegratePosition(
                                __global clb2Velocity* velocities,
                                __global clb2Position* positions,
                                const float dt,
                                const int bodyCount
                                )
{
    int bodyIndex=get_global_id(0);
    
    if(bodyIndex>=bodyCount) return;
    
    clb2Position thisPosition=positions[bodyIndex];
    clb2Velocity thisVelocity=velocities[bodyIndex];
    
    float2 translation = (float2)(dt*thisVelocity.vx, dt*thisVelocity.vy);
    float translationLength=sqrt(dot(translation,translation));
    if(translationLength>b2_maxTranslation){
        thisVelocity.vx *= (b2_maxTranslation/translationLength);
		thisVelocity.vy *= (b2_maxTranslation/translationLength);
    }
    float rotation = dt*thisVelocity.w;
    float rotationMagnitude = fabs(rotation);
    if(rotationMagnitude>b2_maxRotation){
        thisVelocity.w *= (b2_maxRotation/rotationMagnitude);
    }
    
    thisPosition.cx += dt*thisVelocity.vx;
    thisPosition.cy += dt*thisVelocity.vy;
    thisPosition.a += dt*thisVelocity.w;
    
    positions[bodyIndex] = thisPosition;
    velocities[bodyIndex] = thisVelocity;
}

void computePositionSolverManifoldCircles(clb2Manifold* manifold,clb2PositionSolverManifold* positionSolverManifold,clb2Transform* xfA,clb2Transform* xfB,int index)
{
    float2 pointA=(float2)(manifold->localPoint.x*xfA->rotation.c - manifold->localPoint.y*xfA->rotation.s + xfA->translation.x, manifold->localPoint.x*xfA->rotation.s + manifold->localPoint.y*xfA->rotation.c + xfA->translation.y);
    float2 pointB=(float2)(manifold->localPoints1.x*xfB->rotation.c - manifold->localPoints1.y*xfB->rotation.s + xfB->translation.x, manifold->localPoints1.x*xfB->rotation.s + manifold->localPoints1.y*xfB->rotation.c + xfB->translation.y);
    
    float2 normal=pointB-pointA;
    positionSolverManifold->normal=normalize(normal);
    positionSolverManifold->point=0.5f*(pointA+pointB);
    positionSolverManifold->separation=length(normal) - manifold->radiusA - manifold->radiusB;
}

void computePositionSolverManifoldFaceA(clb2Manifold* manifold,clb2PositionSolverManifold* positionSolverManifold,clb2Transform* xfA,clb2Transform* xfB,int index)
{
    float2 planePoint=(float2)(manifold->localPoint.x*xfA->rotation.c - manifold->localPoint.y*xfA->rotation.s + xfA->translation.x, manifold->localPoint.x*xfA->rotation.s + manifold->localPoint.y*xfA->rotation.c + xfA->translation.y);
    float2 normal=(float2)(xfA->rotation.c*manifold->localNormal.x-xfA->rotation.s*manifold->localNormal.y,xfA->rotation.s*manifold->localNormal.x+xfA->rotation.c*manifold->localNormal.y);
    
    if(index==1){
        float2 clipPoint=(float2)(manifold->localPoints1.x*xfB->rotation.c - manifold->localPoints1.y*xfB->rotation.s + xfB->translation.x, manifold->localPoints1.x*xfB->rotation.s + manifold->localPoints1.y*xfB->rotation.c + xfB->translation.y);
        
        positionSolverManifold->normal=normal;
        positionSolverManifold->separation=dot(clipPoint-planePoint,normal)-manifold->radiusA-manifold->radiusB;
        positionSolverManifold->point=clipPoint;
    }else{
        float2 clipPoint=(float2)(manifold->localPoints2.x*xfB->rotation.c - manifold->localPoints2.y*xfB->rotation.s + xfB->translation.x, manifold->localPoints2.x*xfB->rotation.s + manifold->localPoints2.y*xfB->rotation.c + xfB->translation.y);
        
        positionSolverManifold->normal=normal;
        positionSolverManifold->separation=dot(clipPoint-planePoint,normal)-manifold->radiusA-manifold->radiusB;
        positionSolverManifold->point=clipPoint;
    }
}

void computePositionSolverManifoldFaceB(clb2Manifold* manifold,clb2PositionSolverManifold* positionSolverManifold,clb2Transform* xfA,clb2Transform* xfB,int index)
{
    float2 planePoint=(float2)(manifold->localPoint.x*xfB->rotation.c - manifold->localPoint.y*xfB->rotation.s + xfB->translation.x, manifold->localPoint.x*xfB->rotation.s + manifold->localPoint.y*xfB->rotation.c + xfB->translation.y);
    float2 normal=(float2)(xfB->rotation.c*manifold->localNormal.x-xfB->rotation.s*manifold->localNormal.y,xfB->rotation.s*manifold->localNormal.x+xfB->rotation.c*manifold->localNormal.y);
    
    if(index==1){
        float2 clipPoint=(float2)(manifold->localPoints1.x*xfA->rotation.c - manifold->localPoints1.y*xfA->rotation.s + xfA->translation.x, manifold->localPoints1.x*xfA->rotation.s + manifold->localPoints1.y*xfA->rotation.c + xfA->translation.y);
        
        positionSolverManifold->normal=-normal;
        positionSolverManifold->separation=dot(clipPoint-planePoint,normal)-manifold->radiusA-manifold->radiusB;
        positionSolverManifold->point=clipPoint;
    }else{
        float2 clipPoint=(float2)(manifold->localPoints2.x*xfA->rotation.c - manifold->localPoints2.y*xfA->rotation.s + xfA->translation.x, manifold->localPoints2.x*xfA->rotation.s + manifold->localPoints2.y*xfA->rotation.c + xfA->translation.y);
        
        positionSolverManifold->normal=-normal;
        positionSolverManifold->separation=dot(clipPoint-planePoint,normal)-manifold->radiusA-manifold->radiusB;
        positionSolverManifold->point=clipPoint;
    }
}

__kernel void SolvePositionConstraint(
                                      __global clb2Position* positions,
                                      __global clb2Manifold* manifolds,
                                      __global clb2Contact* contacts,
                                      const unsigned int offset,
                                      const unsigned int contactCount
                                      )
{
    unsigned int contactIndex=get_global_id(0)+offset;
    if(contactIndex>=offset+contactCount) return;
    clb2Contact thisContact=contacts[contactIndex];
    clb2Manifold thisManifold=manifolds[contactIndex];
    int indexA=thisContact.indexA;
    int indexB=thisContact.indexB;
    clb2Position thisPosA=positions[indexA];
    clb2Position thisPosB=positions[indexB];
    
    clb2PositionSolverManifold thisPositionManifold;
    
    clb2Transform xfA,xfB;
    
    float sina, cosa;
    sina = sincos(thisPosA.a, &cosa);
    xfA.rotation.s = sina;
    xfA.rotation.c = cosa;
    //xfA.rotation.s = native_sin(thisPosA.a);
    //xfA.rotation.c = native_cos(thisPosA.a);
    //xfA.rotation.c = cos_wrapper(thisPosA.a);
    
    sina = sincos(thisPosB.a, &cosa);
    xfB.rotation.s = sina;
    xfB.rotation.c = cosa;
    //xfB.rotation.s = native_sin(thisPosB.a);
    //xfB.rotation.c = native_cos(thisPosB.a);
    //xfB.rotation.c = cos_wrapper(thisPosB.a);
    
    xfA.translation=(float2)(thisPosA.cx,thisPosA.cy) - (float2)(xfA.rotation.c * thisManifold.localCenterA.x - xfA.rotation.s * thisManifold.localCenterA.y, xfA.rotation.s * thisManifold.localCenterA.x + xfA.rotation.c * thisManifold.localCenterA.y);
    xfB.translation=(float2)(thisPosB.cx,thisPosB.cy) - (float2)(xfB.rotation.c * thisManifold.localCenterB.x - xfB.rotation.s * thisManifold.localCenterB.y, xfB.rotation.s * thisManifold.localCenterB.x + xfB.rotation.c * thisManifold.localCenterB.y);  
    
    if(thisManifold.type==0)
        computePositionSolverManifoldCircles(&thisManifold,&thisPositionManifold,&xfA,&xfB,1);
    else if(thisManifold.type==1)
        computePositionSolverManifoldFaceA(&thisManifold,&thisPositionManifold,&xfA,&xfB,1);
    else if(thisManifold.type==2)
        computePositionSolverManifoldFaceB(&thisManifold,&thisPositionManifold,&xfA,&xfB,1);
    
    float2 dA=thisPositionManifold.point - (float2)(thisPosA.cx,thisPosA.cy);
    float2 dB=thisPositionManifold.point - (float2)(thisPosB.cx,thisPosB.cy);
    
    float C=clamp(b2_baumgarte*(thisPositionManifold.separation+b2_linearSlop),-b2_maxLinearCorrection,0.0f);
    
    float rnA=dA.x*thisPositionManifold.normal.y - dA.y*thisPositionManifold.normal.x;
    float rnB=dB.x*thisPositionManifold.normal.y - dB.y*thisPositionManifold.normal.x;
    
    float K=thisContact.invMassA + thisContact.invMassB + thisContact.invIA*rnA*rnA + thisContact.invIB*rnB*rnB;
    
    float2 P=max(-C/K,0.0f)*thisPositionManifold.normal;
 
    
    thisPosA.cx=thisPosA.cx-thisContact.invMassA*P.x;
    thisPosA.cy=thisPosA.cy-thisContact.invMassA*P.y;
    thisPosA.a = thisPosA.a-thisContact.invIA * (dA.x * P.y - dA.y * P.x); 
    
    thisPosB.cx = thisPosB.cx+thisContact.invMassB * P.x; 
    thisPosB.cy = thisPosB.cy+thisContact.invMassB * P.y; 
    thisPosB.a = thisPosB.a+thisContact.invIB * (dB.x * P.y - dB.y * P.x);
    
    if(thisManifold.pointCount==2){
        
        sina = sincos(thisPosA.a, &cosa);
        xfA.rotation.s = sina;
        xfA.rotation.c = cosa;
    	// xfA.rotation.s = native_sin(thisPosA.a);
    	// xfA.rotation.c = native_cos(thisPosA.a);
    	//xfA.rotation.c = cos_wrapper(thisPosA.a);
    	 
        sina = sincos(thisPosB.a, &cosa);
        xfB.rotation.s = sina;
        xfB.rotation.c = cosa;
    	// xfB.rotation.s = native_sin(thisPosB.a);
    	// xfB.rotation.c = native_cos(thisPosB.a);
		//xfB.rotation.c = cos_wrapper(thisPosB.a);
		 
        xfA.translation=(float2)(thisPosA.cx,thisPosA.cy) - (float2)(xfA.rotation.c * thisManifold.localCenterA.x - xfA.rotation.s * thisManifold.localCenterA.y, xfA.rotation.s * thisManifold.localCenterA.x + xfA.rotation.c * thisManifold.localCenterA.y);
        xfB.translation=(float2)(thisPosB.cx,thisPosB.cy) - (float2)(xfB.rotation.c * thisManifold.localCenterB.x - xfB.rotation.s * thisManifold.localCenterB.y, xfB.rotation.s * thisManifold.localCenterB.x + xfB.rotation.c * thisManifold.localCenterB.y); 
        
        if(thisManifold.type==0)
            computePositionSolverManifoldCircles(&thisManifold,&thisPositionManifold,&xfA,&xfB,2);
        else if(thisManifold.type==1)
            computePositionSolverManifoldFaceA(&thisManifold,&thisPositionManifold,&xfA,&xfB,2);
        else if(thisManifold.type==2)
            computePositionSolverManifoldFaceB(&thisManifold,&thisPositionManifold,&xfA,&xfB,2);
        
        dA=thisPositionManifold.point - (float2)(thisPosA.cx,thisPosA.cy);
        dB=thisPositionManifold.point - (float2)(thisPosB.cx,thisPosB.cy);
        
        C=clamp(b2_baumgarte*(thisPositionManifold.separation+b2_linearSlop),-b2_maxLinearCorrection,0.0f);
        
        rnA=dA.x*thisPositionManifold.normal.y - dA.y*thisPositionManifold.normal.x;
        rnB=dB.x*thisPositionManifold.normal.y - dB.y*thisPositionManifold.normal.x;
        
        K=thisContact.invMassA + thisContact.invMassB + thisContact.invIA*rnA*rnA + thisContact.invIB*rnB*rnB;
        
        P=max(-C/K,0.0f)*thisPositionManifold.normal;
        
		// float absy = P.y ; if (absy < 0) absy = 0 - absy ; 
		//if (absy > 0.1) P.x *= lv ; P.y *= lv ; 

        thisPosA.cx=thisPosA.cx-thisContact.invMassA*P.x;
        thisPosA.cy=thisPosA.cy-thisContact.invMassA*P.y;
        thisPosA.a = thisPosA.a-thisContact.invIA * (dA.x * P.y - dA.y * P.x); 
        
        thisPosB.cx = thisPosB.cx+thisContact.invMassB * P.x; 
        thisPosB.cy = thisPosB.cy+thisContact.invMassB * P.y; 
        thisPosB.a = thisPosB.a+thisContact.invIB * (dB.x * P.y - dB.y * P.x);
    }
    
    positions[indexA]=thisPosA;
    positions[indexB]=thisPosB;
}


__kernel void SolveSplitPositionConstraint(
                                      __global clb2Position* positions,
                                      __global clb2Manifold* manifolds,
                                      __global clb2Contact* contacts,
									  __global clb2Velocity* splitVelocities,
									  __global unsigned int* numContacts4EachBody, 
									  __global unsigned int* indexContact2BodySplitVelocity, 
                                      const unsigned int numContacts
                          
                                      )
{
    unsigned int contactIndex=get_global_id(0); 
    if(contactIndex>= numContacts) return;

	unsigned int indexContact2BodyA = indexContact2BodySplitVelocity[contactIndex*2+0];
	unsigned int indexContact2BodyB = indexContact2BodySplitVelocity[contactIndex*2+1]; 
	int maxContactNumPerBody = 20 ; 
    clb2Contact thisContact=contacts[contactIndex];
    clb2Manifold thisManifold=manifolds[contactIndex];
    int indexA=thisContact.indexA;
    int indexB=thisContact.indexB;
    clb2Position thisPosA=positions[indexA];
    clb2Position thisPosB=positions[indexB];
	int numBodyA = numContacts4EachBody [thisContact.indexA];
	int numBodyB = numContacts4EachBody [thisContact.indexB];

	clb2Velocity deltaPosA ;deltaPosA.vx = deltaPosA.vy = deltaPosA.w = 0 ;  
	clb2Velocity deltaPosB ; deltaPosB.vx = deltaPosB.vy = deltaPosB.w = 0 ; 
    
    clb2PositionSolverManifold thisPositionManifold;
    
    clb2Transform xfA,xfB;
    float sina, cosa;
    
    sina = sincos(thisPosA.a, &cosa);
    xfA.rotation.s = sina;
    xfA.rotation.c = cosa;
    //xfA.rotation.s = native_sin(thisPosA.a);
    //xfA.rotation.c = native_cos(thisPosA.a);
    //xfA.rotation.c = cos_wrapper(thisPosA.a);
    
    sina = sincos(thisPosB.a, &cosa);
    xfB.rotation.s = sina;
    xfB.rotation.c = cosa;
    //xfB.rotation.s = native_sin(thisPosB.a);
    //xfB.rotation.c = native_cos(thisPosB.a);
    //xfB.rotation.c = cos_wrapper(thisPosB.a);
    
    xfA.translation=(float2)(thisPosA.cx,thisPosA.cy) - (float2)(xfA.rotation.c * thisManifold.localCenterA.x - xfA.rotation.s * thisManifold.localCenterA.y, xfA.rotation.s * thisManifold.localCenterA.x + xfA.rotation.c * thisManifold.localCenterA.y);
    xfB.translation=(float2)(thisPosB.cx,thisPosB.cy) - (float2)(xfB.rotation.c * thisManifold.localCenterB.x - xfB.rotation.s * thisManifold.localCenterB.y, xfB.rotation.s * thisManifold.localCenterB.x + xfB.rotation.c * thisManifold.localCenterB.y);  
    
    if(thisManifold.type==0)
        computePositionSolverManifoldCircles(&thisManifold,&thisPositionManifold,&xfA,&xfB,1);
    else if(thisManifold.type==1)
        computePositionSolverManifoldFaceA(&thisManifold,&thisPositionManifold,&xfA,&xfB,1);
    else if(thisManifold.type==2)
        computePositionSolverManifoldFaceB(&thisManifold,&thisPositionManifold,&xfA,&xfB,1);
    
    float2 dA=thisPositionManifold.point - (float2)(thisPosA.cx,thisPosA.cy);
    float2 dB=thisPositionManifold.point - (float2)(thisPosB.cx,thisPosB.cy);
    
    float C=clamp(b2_baumgarte*(thisPositionManifold.separation+b2_linearSlop),-b2_maxLinearCorrection,0.0f);
    
    float rnA=dA.x*thisPositionManifold.normal.y - dA.y*thisPositionManifold.normal.x;
    float rnB=dB.x*thisPositionManifold.normal.y - dB.y*thisPositionManifold.normal.x;
    
    float K=thisContact.invMassA*numBodyA + thisContact.invMassB *numBodyB + thisContact.invIA*rnA*rnA*numBodyA + thisContact.invIB*rnB*rnB *numBodyB;
    
    float2 P=max(-C/K,0.0f)*thisPositionManifold.normal;

	//float lv = 1.0 ;
    //float absy = P.y ; if (absy < 0) absy = 0 - absy ; 
	//if (P.y > 0 && absy > 0.1) P.x *= lv ; P.y *= lv ;  
    
    thisPosA.cx=thisPosA.cx-thisContact.invMassA*P.x;
    thisPosA.cy=thisPosA.cy-thisContact.invMassA*P.y;
    thisPosA.a = thisPosA.a-thisContact.invIA * (dA.x * P.y - dA.y * P.x); 

	deltaPosA.vx -= thisContact.invMassA*P.x;
	deltaPosA.vy -= thisContact.invMassA*P.y;
	deltaPosA.w  -= thisContact.invIA * (dA.x * P.y - dA.y * P.x);

    
    thisPosB.cx = thisPosB.cx+thisContact.invMassB * P.x; 
    thisPosB.cy = thisPosB.cy+thisContact.invMassB * P.y; 
    thisPosB.a = thisPosB.a+thisContact.invIB * (dB.x * P.y - dB.y * P.x);

	deltaPosB.vx += thisContact.invMassB * P.x; 
	deltaPosB.vy += thisContact.invMassB * P.y;
	deltaPosB.w += thisContact.invIB * (dB.x * P.y - dB.y * P.x);
    
    if(thisManifold.pointCount==2){
        
		sina = sincos(thisPosA.a, &cosa);
    	xfA.rotation.s = sina;
    	xfA.rotation.c = cosa;
        //xfA.rotation.s = native_sin(thisPosA.a);
        //xfA.rotation.c = native_cos(thisPosA.a);
        //xfA.rotation.c = cos_wrapper(thisPosA.a);
        
		sina = sincos(thisPosB.a, &cosa);
    	xfB.rotation.s = sina;
    	xfB.rotation.c = cosa;
        //xfB.rotation.s = native_sin(thisPosB.a);
        //xfB.rotation.c = native_cos(thisPosB.a);
        //xfB.rotation.c = cos_wrapper(thisPosB.a);
        
        xfA.translation=(float2)(thisPosA.cx,thisPosA.cy) - (float2)(xfA.rotation.c * thisManifold.localCenterA.x - xfA.rotation.s * thisManifold.localCenterA.y, xfA.rotation.s * thisManifold.localCenterA.x + xfA.rotation.c * thisManifold.localCenterA.y);
        xfB.translation=(float2)(thisPosB.cx,thisPosB.cy) - (float2)(xfB.rotation.c * thisManifold.localCenterB.x - xfB.rotation.s * thisManifold.localCenterB.y, xfB.rotation.s * thisManifold.localCenterB.x + xfB.rotation.c * thisManifold.localCenterB.y); 
        
        if(thisManifold.type==0)
            computePositionSolverManifoldCircles(&thisManifold,&thisPositionManifold,&xfA,&xfB,2);
        else if(thisManifold.type==1)
            computePositionSolverManifoldFaceA(&thisManifold,&thisPositionManifold,&xfA,&xfB,2);
        else if(thisManifold.type==2)
            computePositionSolverManifoldFaceB(&thisManifold,&thisPositionManifold,&xfA,&xfB,2);
        
        dA=thisPositionManifold.point - (float2)(thisPosA.cx,thisPosA.cy);
        dB=thisPositionManifold.point - (float2)(thisPosB.cx,thisPosB.cy);
        
        C=clamp(b2_baumgarte*(thisPositionManifold.separation+b2_linearSlop),-b2_maxLinearCorrection,0.0f);
        
        rnA=dA.x*thisPositionManifold.normal.y - dA.y*thisPositionManifold.normal.x;
        rnB=dB.x*thisPositionManifold.normal.y - dB.y*thisPositionManifold.normal.x;
        
        K=thisContact.invMassA*numBodyA + thisContact.invMassB*numBodyB + thisContact.invIA*rnA*rnA*numBodyA + thisContact.invIB*rnB*rnB*numBodyB;
        
        P=max(-C/K,0.0f)*thisPositionManifold.normal;
        
		// float absy = P.y ; if (absy < 0) absy = 0 - absy ; 
		//if (absy > 0.1) P.x *= lv ; P.y *= lv ; 

        thisPosA.cx=thisPosA.cx-thisContact.invMassA*P.x;
        thisPosA.cy=thisPosA.cy-thisContact.invMassA*P.y;
        thisPosA.a = thisPosA.a-thisContact.invIA * (dA.x * P.y - dA.y * P.x); 


		deltaPosA.vx -= thisContact.invMassA*P.x;
		deltaPosA.vy -= thisContact.invMassA*P.y;
		deltaPosA.w  -= thisContact.invIA * (dA.x * P.y - dA.y * P.x);

        
        thisPosB.cx = thisPosB.cx+thisContact.invMassB * P.x; 
        thisPosB.cy = thisPosB.cy+thisContact.invMassB * P.y; 
        thisPosB.a = thisPosB.a+thisContact.invIB * (dB.x * P.y - dB.y * P.x);

		deltaPosB.vx += thisContact.invMassB * P.x; 
		deltaPosB.vy += thisContact.invMassB * P.y;
		deltaPosB.w += thisContact.invIB * (dB.x * P.y - dB.y * P.x);
    }
    
	if (numBodyA != 0) splitVelocities[thisContact.indexA * maxContactNumPerBody + indexContact2BodyA] = deltaPosA; 
	if (numBodyB != 0) splitVelocities [thisContact.indexB * maxContactNumPerBody + indexContact2BodyB] = deltaPosB ; 

    //positions[indexA]=thisPosA; 
    //positions[indexB]=thisPosB;
}



__kernel void SolvePositionConstraint_MergeSplittedMass(
									  __global clb2Position* positions, 
                                      __global clb2Velocity* splitVelocities,
                                      __global clb2Contact* contacts,
								 __global unsigned int* numContacts4EachBody,
								 __global unsigned int* indexContact2BodySplitVelocity,
								 const uint bodyCount
                                      )
{
    unsigned int bodyIndex = get_global_id(0);
	if (bodyIndex >= bodyCount) return ; 
	clb2Position thisBodyPosition = positions[bodyIndex];
	unsigned int numContacts4Body = numContacts4EachBody[bodyIndex]; 
	clb2Velocity  deltaMergedVelocity; deltaMergedVelocity.vx = deltaMergedVelocity.vy = deltaMergedVelocity.w = 0 ; 
	//__global clb2Velocity* pDeltaSplitVelocity  ; 
	clb2Velocity  thisSplitVelocity ; 

	int maxContactNumPerBody = 20 ; 
	for ( int i = 0 ; i < numContacts4Body; i ++ ) {
		thisSplitVelocity = splitVelocities[bodyIndex*maxContactNumPerBody+i] ; 
		deltaMergedVelocity.vx += thisSplitVelocity.vx ; deltaMergedVelocity.vy += thisSplitVelocity.vy ; deltaMergedVelocity.w += thisSplitVelocity.w ;
	} 

	thisBodyPosition.cx += deltaMergedVelocity.vx ; 
	thisBodyPosition.cy += deltaMergedVelocity.vy ;
	thisBodyPosition.a += deltaMergedVelocity.w ;
	positions[bodyIndex] = thisBodyPosition; 
}

__kernel void SolveDistanceJointPositionConstraint(
									__global clb2Position* positions,
									__global b2clJoint* jointList,
									const unsigned int offset,
									const unsigned int colorLength
									// __global testData* testBuffer
									)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolveRevoluteJointPositionConstraint
//
// Compute positions of bodies which are constrained by a Revolute joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolveRevoluteJointPositionConstraint(
                                    __global clb2Position* positions,
									__global b2clJoint* jointList,
									const unsigned int offset,
									const unsigned int colorLength
									// __global testData* testBuffer
									)
{
	unsigned int jointIndex = get_global_id(0) + offset;

    if(jointIndex >= offset + colorLength) 
		return;

	b2clJoint thisJoint = jointList[jointIndex]; 

	clb2Position positionA = positions[thisJoint.indexA];
	clb2Position positionB = positions[thisJoint.indexB];

	float2 cA = (float2)(positionA.cx, positionA.cy);
	float aA = positionA.a;
	float2 cB = (float2)(positionB.cx, positionB.cy);
	float aB = positionB.a;

	float sina, cosa;
	
	sina = sincos(aA, &cosa);
	float2 qA = (float2)(sina,  cosa);
	sina = sincos(aB, &cosa);
	float2 qB = (float2)(sina,  cosa);
	//float2 qA = (float2)(sin(aA),  cos(aA));
	//float2 qB = (float2)(sin(aB), cos(aB));
	//float2 qA = (float2)(sin(aA),  cos_wrapper(aA));
	//float2 qB = (float2)(sin(aB), cos_wrapper(aB));

	float angularError = 0.0f;
	float positionError = 0.0f;

	bool fixedRotation = (thisJoint.b.revoluteJointData.invIA + thisJoint.b.revoluteJointData.invIB == 0.0f);

	// Solve angular limit constraint.
	if (thisJoint.b.revoluteJointData.enableLimit && thisJoint.b.revoluteJointData.limitState != e_inactiveLimit && fixedRotation == false)
	{
		float angle = aB - aA - thisJoint.b.revoluteJointData.referenceAngle;
		float limitImpulse = 0.0f;

		if (thisJoint.b.revoluteJointData.limitState == e_equalLimits)
		{
			// Prevent large angular corrections
			float C = b2clClamp(angle - thisJoint.b.revoluteJointData.lowerAngle, -b2_maxAngularCorrection, b2_maxAngularCorrection);
			limitImpulse = -thisJoint.b.revoluteJointData.motorMass * C;
			angularError = b2clAbs(C);
		}
		else if (thisJoint.b.revoluteJointData.limitState == e_atLowerLimit)
		{
			float C = angle - thisJoint.b.revoluteJointData.lowerAngle;
			angularError = -C;

			// Prevent large angular corrections and allow some slop.
			C = b2clClamp(C + b2_angularSlop, -b2_maxAngularCorrection, 0.0f);
			limitImpulse = -thisJoint.b.revoluteJointData.motorMass * C;
		}
		else if (thisJoint.b.revoluteJointData.limitState == e_atUpperLimit)
		{
			float C = angle - thisJoint.b.revoluteJointData.upperAngle;
			angularError = C;

			// Prevent large angular corrections and allow some slop.
			C = b2clClamp(C - b2_angularSlop, 0.0f, b2_maxAngularCorrection);
			limitImpulse = -thisJoint.b.revoluteJointData.motorMass * C;
		}

		aA -= thisJoint.b.revoluteJointData.invIA * limitImpulse;
		aB += thisJoint.b.revoluteJointData.invIB * limitImpulse;
	}

	// Solve point-to-point constraint.
	{
		sina = sincos(aA, &cosa);
		qA = (float2)(sina,  cosa);
		sina = sincos(aB, &cosa);
		qB = (float2)(sina,  cosa);
		//qA = (float2)(sin(aA), cos(aA));
		//qB = (float2)(sin(aB), cos(aB));
		//qA = (float2)(sin(aA), cos_wrapper(aA));
		//qB = (float2)(sin(aB), cos_wrapper(aB));
		float2 rA = b2clMul_Rotate(qA, (float2)(thisJoint.b.revoluteJointData.localAnchorA[0] - thisJoint.b.revoluteJointData.localCenterA[0], thisJoint.b.revoluteJointData.localAnchorA[1] - thisJoint.b.revoluteJointData.localCenterA[1]));
		float2 rB = b2clMul_Rotate(qB, (float2)(thisJoint.b.revoluteJointData.localAnchorB[0] - thisJoint.b.revoluteJointData.localCenterB[0], thisJoint.b.revoluteJointData.localAnchorB[1] - thisJoint.b.revoluteJointData.localCenterB[1]));

		float2 C = cB + rB - cA - rA;
		float length = sqrt(b2clDot(C, C)); 
		positionError = length;

		float mA = thisJoint.b.revoluteJointData.invMassA, mB = thisJoint.b.revoluteJointData.invMassB;
		float iA = thisJoint.b.revoluteJointData.invIA, iB = thisJoint.b.revoluteJointData.invIB;

		b2clMat22 K;
		K.ex[0] = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
		K.ex[1] = -iA * rA.x * rA.y - iB * rB.x * rB.y;
		K.ey[0] = K.ex[1];
		K.ey[1] = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;

		float2 impulse = -b2clMat22Solve(K, C);

		cA -= mA * impulse;
		aA -= iA * b2clCross_VV(rA, impulse);

		cB += mB * impulse;
		aB += iB * b2clCross_VV(rB, impulse);
	}

	positionA.cx = cA.x;
	positionA.cy = cA.y;
	positionA.a = aA;
	positionB.cx = cB.x;
	positionB.cy = cB.y;
	positionB.a = aB;
	positions[thisJoint.indexA] = positionA;
	positions[thisJoint.indexB] = positionB;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolvePrismaticJointPositionConstraint
//
// Compute positions of bodies which are constrained by a Prismatic joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolvePrismaticJointPositionConstraint(
                                    __global clb2Position* positions,
									__global b2clJoint* jointList,
									const unsigned int offset,
									const unsigned int colorLength
									// __global testData* testBuffer
									)
{
	unsigned int jointIndex = get_global_id(0) + offset;

    if(jointIndex >= offset + colorLength) 
		return;

	b2clJoint thisJoint = jointList[jointIndex]; 

	clb2Position positionA = positions[thisJoint.indexA];
	clb2Position positionB = positions[thisJoint.indexB];

	float2 m_localAnchorA = (float2) (thisJoint.b.prismaticJointData.localAnchorA[0] , thisJoint.b.prismaticJointData.localAnchorA[1]);
	float2 m_localAnchorB = (float2) (thisJoint.b.prismaticJointData.localAnchorB[0] , thisJoint.b.prismaticJointData.localAnchorB[1]);
	float2 m_localCenterA = (float2) (thisJoint.b.prismaticJointData.localCenterA[0] , thisJoint.b.prismaticJointData.localCenterA[1]);
	float2 m_localCenterB = (float2) (thisJoint.b.prismaticJointData.localCenterB[0] , thisJoint.b.prismaticJointData.localCenterB[1]);
	float2 m_localXAxisA = (float2) (thisJoint.b.prismaticJointData.localXAxisA[0] , thisJoint.b.prismaticJointData.localXAxisA[1]);
	float2 m_localYAxisA = (float2) (thisJoint.b.prismaticJointData.localYAxisA[0] , thisJoint.b.prismaticJointData.localYAxisA[1]);

	float2 cA = (float2)(positionA.cx, positionA.cy);
	float aA = positionA.a;
	float2 cB = (float2)(positionB.cx, positionB.cy);
	float aB = positionB.a;

	float sina, cosa;
	sina = sincos(aA, &cosa);
	float2 qA = (float2)(sina,  cosa);
	sina = sincos(aB, &cosa);
	float2 qB = (float2)(sina,  cosa);
	//float2 qA = (float2)(sin(aA), cos(aA));
	//float2 qB = (float2)(sin(aB), cos(aB));
	//float2 qA = (float2)(sin(aA), cos_wrapper(aA));
	//float2 qB = (float2)(sin(aB), cos_wrapper(aB));

	float mA = thisJoint.b.prismaticJointData.invMassA, mB = thisJoint.b.prismaticJointData.invMassB;
	float iA = thisJoint.b.prismaticJointData.invIA, iB = thisJoint.b.prismaticJointData.invIB;

	// Compute fresh Jacobians
	float2 rA = b2clMul_Rotate(qA, m_localAnchorA - m_localCenterA);
	float2 rB = b2clMul_Rotate(qB, m_localAnchorB - m_localCenterB);
	float2 d = cB + rB - cA - rA;

	float2 axis = b2clMul_Rotate(qA, m_localXAxisA);
	float a1 = b2clCross_VV(d + rA, axis);
	float a2 = b2clCross_VV(rB, axis);
	float2 perp = b2clMul_Rotate(qA, m_localYAxisA);

	float s1 = b2clCross_VV(d + rA, perp);
	float s2 = b2clCross_VV(rB, perp);

	float3 impulse;
	float2 C1;
	C1.x = b2clDot(perp, d);
	C1.y = aB - aA - thisJoint.b.prismaticJointData.referenceAngle;

	float linearError = b2clAbs(C1.x);
	float angularError = b2clAbs(C1.y);

	bool active = false;
	float C2 = 0.0f;
	if (thisJoint.b.prismaticJointData.enableLimit)
	{
		float translation = b2clDot(axis, d);
		if (b2clAbs(thisJoint.b.prismaticJointData.upperTranslation - thisJoint.b.prismaticJointData.lowerTranslation) < 2.0f * b2_linearSlop)
		{
			// Prevent large angular corrections
			C2 = b2clClamp(translation, -b2_maxLinearCorrection, b2_maxLinearCorrection);
			linearError = max(linearError, b2clAbs(translation));
			active = true;
		}
		else if (translation <= thisJoint.b.prismaticJointData.lowerTranslation)
		{
			// Prevent large linear corrections and allow some slop.
			C2 = b2clClamp(translation - thisJoint.b.prismaticJointData.lowerTranslation + b2_linearSlop, -b2_maxLinearCorrection, 0.0f);
			linearError = max(linearError, thisJoint.b.prismaticJointData.lowerTranslation - translation);
			active = true;
		}
		else if (translation >= thisJoint.b.prismaticJointData.upperTranslation)
		{
			// Prevent large linear corrections and allow some slop.
			C2 = b2clClamp(translation - thisJoint.b.prismaticJointData.upperTranslation - b2_linearSlop, 0.0f, b2_maxLinearCorrection);
			linearError = max(linearError, translation - thisJoint.b.prismaticJointData.upperTranslation);
			active = true;
		}
	}

	if (active)
	{
		float k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
		float k12 = iA * s1 + iB * s2;
		float k13 = iA * s1 * a1 + iB * s2 * a2;
		float k22 = iA + iB;
		if (k22 == 0.0f)
		{
			// For fixed rotation
			k22 = 1.0f;
		}
		float k23 = iA * a1 + iB * a2;
		float k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;

		b2clMat33 K;
		K.ex[0] = k11;
		K.ex[1] = k12;
		K.ex[2] = k13;
		K.ey[0] = k12;
		K.ey[1] = k22;
		K.ey[2] = k23;
		K.ez[0] = k13;
		K.ez[1] = k23;
		K.ez[2] = k33;

		float3 C = (float3)(C1.x, C1.y, C2);

		impulse = b2clMat33Solve(K, -C);
	}
	else
	{
		float k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
		float k12 = iA * s1 + iB * s2;
		float k22 = iA + iB;
		if (k22 == 0.0f)
		{
			k22 = 1.0f;
		}

		b2clMat22 K;
		K.ex[0] = k11;
		K.ex[1] = k12;
		K.ey[0] = k12;
		K.ey[1] = k22;

		float2 impulse1 = b2clMat22Solve(K, -C1);
		impulse.x = impulse1.x;
		impulse.y = impulse1.y;
		impulse.z = 0.0f;
	}

	float2 P = impulse.x * perp + impulse.z * axis;
	float LA = impulse.x * s1 + impulse.y + impulse.z * a1;
	float LB = impulse.x * s2 + impulse.y + impulse.z * a2;

	cA -= mA * P;
	aA -= iA * LA;
	cB += mB * P;
	aB += iB * LB;

	positionA.cx = cA.x;
	positionA.cy = cA.y;
	positionA.a = aA;
	positionB.cx = cB.x;
	positionB.cy = cB.y;
	positionB.a = aB;
	positions[thisJoint.indexA] = positionA;
	positions[thisJoint.indexB] = positionB;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolveGearJointPositionConstraint
//
// Compute positions of bodies which are constrained by a Gear joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolveGearJointPositionConstraint(
                                    __global clb2Position* positions,
									__global b2clJoint* jointList,
									const unsigned int offset,
									const unsigned int colorLength
									// __global testData* testBuffer
									)
{
	unsigned int jointIndex = get_global_id(0) + offset;

    if(jointIndex >= offset + colorLength) 
		return;

	b2clJoint thisJoint = jointList[jointIndex]; 

	clb2Position positionA = positions[thisJoint.indexA];
	clb2Position positionB = positions[thisJoint.indexB];
	clb2Position positionC = positions[thisJoint.indexC];
	clb2Position positionD = positions[thisJoint.indexD];

	float2 cA = (float2)(positionA.cx, positionA.cy);
	float aA = positionA.a;
	float2 cB = (float2)(positionB.cx, positionB.cy);
	float aB = positionB.a;
	float2 cC = (float2)(positionC.cx, positionC.cy);
	float aC = positionC.a;
	float2 cD = (float2)(positionD.cx, positionD.cy);
	float aD = positionD.a;

    float sina, cosa;
	sina = sincos(aA, &cosa);
	float2 qA = (float2)(sina,  cosa);
	sina = sincos(aB, &cosa);
	float2 qB = (float2)(sina,  cosa);
	sina = sincos(aC, &cosa);
	float2 qC = (float2)(sina,  cosa);
	sina = sincos(aD, &cosa);
	float2 qD = (float2)(sina,  cosa);

	//float2 qA = (float2)(sin(aA), cos(aA));
	//float2 qB = (float2)(sin(aB), cos(aB));
	//float2 qC = (float2)(sin(aC), cos(aC));
	//float2 qD = (float2)(sin(aD), cos(aD));

	//float2 qA = (float2)(sin(aA), cos_wrapper(aA));
	//float2 qB = (float2)(sin(aB), cos_wrapper(aB));
	//float2 qC = (float2)(sin(aC), cos_wrapper(aC));
	//float2 qD = (float2)(sin(aD), cos_wrapper(aD));

	float2 m_localAnchorA = (float2) (thisJoint.b.gearJointData.localAnchorA[0] , thisJoint.b.gearJointData.localAnchorA[1]);
	float2 m_localAnchorB = (float2) (thisJoint.b.gearJointData.localAnchorB[0] , thisJoint.b.gearJointData.localAnchorB[1]);
	float2 m_localAnchorC = (float2) (thisJoint.b.gearJointData.localAnchorC[0] , thisJoint.b.gearJointData.localAnchorC[1]);
	float2 m_localAnchorD = (float2) (thisJoint.b.gearJointData.localAnchorD[0] , thisJoint.b.gearJointData.localAnchorD[1]);
	float2 m_localAxisC = (float2) (thisJoint.b.gearJointData.localAxisC[0] , thisJoint.b.gearJointData.localAxisC[1]);
	float2 m_localAxisD = (float2) (thisJoint.b.gearJointData.localAxisD[0] , thisJoint.b.gearJointData.localAxisD[1]);
	float2 m_lcA = (float2) (thisJoint.b.gearJointData.lcA[0] , thisJoint.b.gearJointData.lcA[1]);
	float2 m_lcB = (float2) (thisJoint.b.gearJointData.lcB[0] , thisJoint.b.gearJointData.lcB[1]);
	float2 m_lcC = (float2) (thisJoint.b.gearJointData.lcC[0] , thisJoint.b.gearJointData.lcC[1]);
	float2 m_lcD = (float2) (thisJoint.b.gearJointData.lcD[0] , thisJoint.b.gearJointData.lcD[1]);

	float linearError = 0.0f;

	float coordinateA, coordinateB;

	float2 JvAC, JvBD;
	float JwA, JwB, JwC, JwD;
	float mass = 0.0f;
	
	if (thisJoint.b.gearJointData.typeA == e_revoluteJoint)
	{
		JvAC = (float2)(0.0f, 0.0f);
		JwA = 1.0f;
		JwC = 1.0f;
		mass += thisJoint.b.gearJointData.iA + thisJoint.b.gearJointData.iC;

		coordinateA = aA - aC - thisJoint.b.gearJointData.referenceAngleA;
	}
	else
	{
		float2 u = b2clMul_Rotate(qC, m_localAxisC);
		float2 rC = b2clMul_Rotate(qC, m_localAnchorC - m_lcC);
		float2 rA = b2clMul_Rotate(qA, m_localAnchorA - m_lcA);
		JvAC = u;
		JwC = b2clCross_VV(rC, u);
		JwA = b2clCross_VV(rA, u);
		mass += thisJoint.b.gearJointData.mC + thisJoint.b.gearJointData.mA + thisJoint.b.gearJointData.iC * JwC * JwC + thisJoint.b.gearJointData.iA * JwA * JwA;

		float2 pC = m_localAnchorC - m_lcC;
		float2 pA = b2clMulT_Rotate(qC, rA + (cA - cC));
		coordinateA = b2clDot(pA - pC, m_localAxisC);
	}

	if (thisJoint.b.gearJointData.typeB == e_revoluteJoint)
	{
		JvBD = (float2)(0.0f, 0.0f);
		JwB = thisJoint.b.gearJointData.ratio;
		JwD = thisJoint.b.gearJointData.ratio;
		mass += thisJoint.b.gearJointData.ratio * thisJoint.b.gearJointData.ratio * (thisJoint.b.gearJointData.iB + thisJoint.b.gearJointData.iD);

		coordinateB = aB - aD - thisJoint.b.gearJointData.referenceAngleB;
	}
	else
	{
		float2 u = b2clMul_Rotate(qD, m_localAxisD);
		float2 rD = b2clMul_Rotate(qD, m_localAnchorD - m_lcD);
		float2 rB = b2clMul_Rotate(qB, m_localAnchorB - m_lcB);
		JvBD = thisJoint.b.gearJointData.ratio * u;
		JwD = thisJoint.b.gearJointData.ratio * b2clCross_VV(rD, u);
		JwB = thisJoint.b.gearJointData.ratio * b2clCross_VV(rB, u);
		mass += thisJoint.b.gearJointData.ratio * thisJoint.b.gearJointData.ratio * (thisJoint.b.gearJointData.mD + thisJoint.b.gearJointData.mB) + thisJoint.b.gearJointData.iD * JwD * JwD + thisJoint.b.gearJointData.iB * JwB * JwB;

		float2 pD = m_localAnchorD - m_lcD;
		float2 pB = b2clMulT_Rotate(qD, rB + (cB - cD));
		coordinateB = b2clDot(pB - pD, m_localAxisD);
	}
	
	float C = (coordinateA + thisJoint.b.gearJointData.ratio * coordinateB) - thisJoint.b.gearJointData.gearConstant;

	float impulse = 0.0f;
	if (mass > 0.0f)
	{
		impulse = -C / mass;
	}

	cA += thisJoint.b.gearJointData.mA * impulse * JvAC;
	aA += thisJoint.b.gearJointData.iA * impulse * JwA;
	cB += thisJoint.b.gearJointData.mB * impulse * JvBD;
	aB += thisJoint.b.gearJointData.iB * impulse * JwB;
	cC -= thisJoint.b.gearJointData.mC * impulse * JvAC;
	aC -= thisJoint.b.gearJointData.iC * impulse * JwC;
	cD -= thisJoint.b.gearJointData.mD * impulse * JvBD;
	aD -= thisJoint.b.gearJointData.iD * impulse * JwD;

	positionA.cx = cA.x;
	positionA.cy = cA.y;
	positionA.a = aA;
	positionB.cx = cB.x;
	positionB.cy = cB.y;
	positionB.a = aB;
	positionC.cx = cC.x;
	positionC.cy = cC.y;
	positionC.a = aC;
	positionD.cx = cD.x;
	positionD.cy = cD.y;
	positionD.a = aD;

	positions[thisJoint.indexA] = positionA;
	positions[thisJoint.indexB] = positionB;
	positions[thisJoint.indexC] = positionC;
	positions[thisJoint.indexD] = positionD;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolvePulleyJointPositionConstraint
//
// Compute positions of bodies which are constrained by a Pulley joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolvePulleyJointPositionConstraint(
                                    __global clb2Position* positions,
									__global b2clJoint* jointList,
									const unsigned int offset,
									const unsigned int colorLength
									// __global testData* testBuffer
									)
{
	unsigned int jointIndex = get_global_id(0) + offset;
    if(jointIndex >= offset + colorLength) 
		return;
	b2clJoint thisJoint = jointList[jointIndex]; 
	clb2Position positionA = positions[thisJoint.indexA];
	clb2Position positionB = positions[thisJoint.indexB];

	
	float2 cA = (float2)(positionA.cx, positionA.cy);	float aA = positionA.a;
	float2 cB = (float2)(positionB.cx, positionB.cy);	float aB = positionB.a;

	float sina, cosa;
	sina = sincos(aA, &cosa);
	float2 qA = (float2)(sina,  cosa);
	sina = sincos(aB, &cosa);
	float2 qB = (float2)(sina,  cosa);
	//float2 qA = (float2)(sin(aA), cos(aA));
	//float2 qB = (float2)(sin(aB), cos(aB));
	//float2 qA = (float2)(sin(aA), cos_wrapper(aA));
	//float2 qB = (float2)(sin(aB), cos_wrapper(aB));

	float2 m_localAnchorA = (float2) (thisJoint.b.pulleyJointData.localAnchorA[0] , thisJoint.b.pulleyJointData.localAnchorA[1]);
	float2 m_localAnchorB = (float2) (thisJoint.b.pulleyJointData.localAnchorB[0] , thisJoint.b.pulleyJointData.localAnchorB[1]);
	float2 m_localCenterA = (float2) (thisJoint.b.pulleyJointData.localCenterA[0] , thisJoint.b.pulleyJointData.localCenterA[1]);
	float2 m_localCenterB = (float2) (thisJoint.b.pulleyJointData.localCenterB[0] , thisJoint.b.pulleyJointData.localCenterB[1]);
	float2 m_groundAnchorA = (float2) (thisJoint.b.pulleyJointData.groundAnchorA[0], thisJoint.b.pulleyJointData.groundAnchorA[1]);
	float2 m_groundAnchorB = (float2) (thisJoint.b.pulleyJointData.groundAnchorB[0], thisJoint.b.pulleyJointData.groundAnchorB[1]);
	
	float2 rA = b2clMul_Rotate (qA, m_localAnchorA - m_localCenterA); 
	float2 rB = b2clMul_Rotate (qB, m_localAnchorB - m_localCenterB);
	
	float2 uA = cA + rA - m_groundAnchorA ; 
	float2 uB = cB + rB - m_groundAnchorB ; 
		 
	
	float lengthA = uA.x * uA.x + uA.y * uA.y ; lengthA = sqrt (lengthA);
	float lengthB = uB.x * uB.x + uB.y * uB.y ; lengthB = sqrt (lengthB);

	
	if (lengthA > 10.0f * b2_linearSlop){
		uA *= 1.0f /lengthA ; 
	} 
	else {
		uA.x = uA.y = 0 ; 
	}
	if (lengthB > 10.0f * b2_linearSlop){
		uB *= 1.0f / lengthB ; 
	}
	else {
		uB.x = uB.y = 0 ; 
	}
	float ruA = b2clCross_VV (rA, uA);
	float ruB = b2clCross_VV (rB, uB);
	float mA = thisJoint.b.pulleyJointData.invMassA + thisJoint.b.pulleyJointData.invIA * ruA * ruA ; 
	float mB = thisJoint.b.pulleyJointData.invMassB + thisJoint.b.pulleyJointData.invIB * ruB * ruB ; 

	float mass = mA + thisJoint.b.pulleyJointData.ratio * thisJoint.b.pulleyJointData.ratio * mB ; 
	if (mass > 0.0f){
		mass = 1.0f /mass ; 
	}
	float C = thisJoint.b.pulleyJointData.pulleyConstant - lengthA - thisJoint.b.pulleyJointData.ratio * lengthB ; 
	float linearError = b2clAbs(C);
	float impulse = -mass * C ; 
		
	//float2 PA = (float2)(-impulse * uA.x , -impulse * uA.y ) ; 
	//float2 PB = (float2)(-thisJoint.b.pulleyJointData.ratio * impulse * uB.x , -thisJoint.b.pulleyJointData.ratio * impulse * uB.y) ;

	float2 PA =  uA * (0-impulse) ; 
	float2 PB =  uB * (0 - impulse* thisJoint.b.pulleyJointData.ratio); 

	cA +=  PA * thisJoint.b.pulleyJointData.invMassA ; 
	aA += thisJoint.b.pulleyJointData.invIA * b2clCross_VV (rA, PA);
	cB += thisJoint.b.pulleyJointData.invMassB * PB ; 
	aB += thisJoint.b.pulleyJointData.invIB * b2clCross_VV (rB, PB);
	
	positionA.cx = cA.x;	positionA.cy = cA.y; positionA.a = aA;
	positionB.cx = cB.x;	positionB.cy = cB.y; positionB.a = aB;
	positions[thisJoint.indexA] = positionA;	positions[thisJoint.indexB] = positionB;
	 
	 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolveRopeJointPositionConstraint
//
// Compute positions of bodies which are constrained by a Rope joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolveRopeJointPositionConstraint(
                                    __global clb2Position* positions,
									__global b2clJoint* jointList,
									const unsigned int offset,
									const unsigned int colorLength
									// __global testData* testBuffer
									)
{
	unsigned int jointIndex = get_global_id(0) + offset;
    if(jointIndex >= offset + colorLength) 
		return;
	b2clJoint thisJoint = jointList[jointIndex]; 
	clb2Position positionA = positions[thisJoint.indexA];
	clb2Position positionB = positions[thisJoint.indexB];

	
	float2 cA = (float2)(positionA.cx, positionA.cy);	float aA = positionA.a;
	float2 cB = (float2)(positionB.cx, positionB.cy);	float aB = positionB.a;

	float sina, cosa;
	sina = sincos(aA, &cosa);
	float2 qA = (float2)(sina,  cosa);
	sina = sincos(aB, &cosa);
	float2 qB = (float2)(sina,  cosa);
	//float2 qA = (float2)(sin(aA), cos(aA));
	//float2 qB = (float2)(sin(aB), cos(aB));
	//float2 qA = (float2)(sin(aA), cos_wrapper(aA));
	//float2 qB = (float2)(sin(aB), cos_wrapper(aB));

	float2 m_localAnchorA = (float2) (thisJoint.b.ropeJointData.localAnchorA[0] , thisJoint.b.ropeJointData.localAnchorA[1]);
	float2 m_localAnchorB = (float2) (thisJoint.b.ropeJointData.localAnchorB[0] , thisJoint.b.ropeJointData.localAnchorB[1]);
	float2 m_localCenterA = (float2) (thisJoint.b.ropeJointData.localCenterA[0] , thisJoint.b.ropeJointData.localCenterA[1]);
	float2 m_localCenterB = (float2) (thisJoint.b.ropeJointData.localCenterB[0] , thisJoint.b.ropeJointData.localCenterB[1]);

	
	float2 rA = b2clMul_Rotate (qA, m_localAnchorA - m_localCenterA); 
	float2 rB = b2clMul_Rotate (qB, m_localAnchorB - m_localCenterB);
    float2 u = cB +rB - cA - rA ; 
	float length = sqrt(b2clDot(u,u)); 
	float C = length - thisJoint.b.ropeJointData.maxLength ; 
	 C=clamp(C, 0.0f,  b2_maxLinearCorrection);
	float impulse = -thisJoint.b.ropeJointData.mass * C ; 
	float2 P = u * impulse ; 

	

	cA -=  P * thisJoint.b.ropeJointData.invMassA ; 
	aA -= thisJoint.b.ropeJointData.invIA * b2clCross_VV (rA, P);
	cB += thisJoint.b.ropeJointData.invMassB * P ; 
	aB += thisJoint.b.ropeJointData.invIB * b2clCross_VV (rB, P);
	
	positionA.cx = cA.x;	positionA.cy = cA.y; positionA.a = aA;
	positionB.cx = cB.x;	positionB.cy = cB.y; positionB.a = aB;
	positions[thisJoint.indexA] = positionA;	positions[thisJoint.indexB] = positionB;
	 
	 
}





__kernel void TestKernel(
                                      __global clb2Position* positions,
                                      __global clb2Manifold* manifolds,
                                      __global clb2Contact* contacts,
                                      const unsigned int offset,
                                      const unsigned int contactCount
                                      )
{
    unsigned int contactIndex=get_global_id(0)+offset;
    if(contactIndex>=offset+contactCount) return;
    clb2Contact thisContact=contacts[contactIndex];
    clb2Manifold thisManifold=manifolds[contactIndex];
    int indexA=thisContact.indexA;
    int indexB=thisContact.indexB;
    clb2Position thisPosA=positions[indexA];
    clb2Position thisPosB=positions[indexB];
    
    clb2PositionSolverManifold thisPositionManifold;
    
    clb2Transform xfA,xfB;

	float sina, cosa;
	
	sina = sincos(thisPosA.a, &cosa);
	xfA.rotation.s = sina;
	xfA.rotation.c = cosa;
    //xfA.rotation.s = native_sin(thisPosA.a);
    //xfA.rotation.c = native_cos(thisPosA.a);
    //xfA.rotation.c = cos_wrapper(thisPosA.a);
     
	sina = sincos(thisPosB.a, &cosa);
	xfB.rotation.s = sina;
	xfB.rotation.c = cosa;
    //xfB.rotation.s = native_sin(thisPosB.a);
    //xfB.rotation.c = native_cos(thisPosB.a);
    //xfB.rotation.c = cos_wrapper(thisPosB.a);


    xfA.translation=(float2)(thisPosA.cx,thisPosA.cy) - (float2)(xfA.rotation.c * thisManifold.localCenterA.x - xfA.rotation.s * thisManifold.localCenterA.y, xfA.rotation.s * thisManifold.localCenterA.x + xfA.rotation.c * thisManifold.localCenterA.y);
    xfB.translation=(float2)(thisPosB.cx,thisPosB.cy) - (float2)(xfB.rotation.c * thisManifold.localCenterB.x - xfB.rotation.s * thisManifold.localCenterB.y, xfB.rotation.s * thisManifold.localCenterB.x + xfB.rotation.c * thisManifold.localCenterB.y);  
    
    if(thisManifold.type==0)
        computePositionSolverManifoldCircles(&thisManifold,&thisPositionManifold,&xfA,&xfB,1);
    else if(thisManifold.type==1)
        computePositionSolverManifoldFaceA(&thisManifold,&thisPositionManifold,&xfA,&xfB,1);
    else if(thisManifold.type==2)
        computePositionSolverManifoldFaceB(&thisManifold,&thisPositionManifold,&xfA,&xfB,1);
    
    float2 dA=thisPositionManifold.point - (float2)(thisPosA.cx,thisPosA.cy);
    float2 dB=thisPositionManifold.point - (float2)(thisPosB.cx,thisPosB.cy);
    
    float C=clamp(b2_baumgarte*(thisPositionManifold.separation+b2_linearSlop),-b2_maxLinearCorrection,0.0f);
    
    float rnA=dA.x*thisPositionManifold.normal.y - dA.y*thisPositionManifold.normal.x;
    float rnB=dB.x*thisPositionManifold.normal.y - dB.y*thisPositionManifold.normal.x;
    
    float K=thisContact.invMassA + thisContact.invMassB + thisContact.invIA*rnA*rnA + thisContact.invIB*rnB*rnB;
    
    float2 P=max(-C/K,0.0f)*thisPositionManifold.normal;
    
    thisPosA.cx=thisPosA.cx-thisContact.invMassA*P.x;
    thisPosA.cy=thisPosA.cy-thisContact.invMassA*P.y;
    thisPosA.a = thisPosA.a-thisContact.invIA * (dA.x * P.y - dA.y * P.x); 
    
    thisPosB.cx = thisPosB.cx+thisContact.invMassB * P.x; 
    thisPosB.cy = thisPosB.cy+thisContact.invMassB * P.y; 
    thisPosB.a = thisPosB.a+thisContact.invIB * (dB.x * P.y - dB.y * P.x);
    
    if(thisManifold.pointCount==2){
        
		sina = sincos(thisPosA.a, &cosa);
		xfA.rotation.s = sina;
		xfA.rotation.c = cosa;
    	//xfA.rotation.s = native_sin(thisPosA.a);
    	//xfA.rotation.c = native_cos(thisPosA.a);
    	//xfA.rotation.c = cos_wrapper(thisPosA.a);
    	
		sina = sincos(thisPosB.a, &cosa);
		xfB.rotation.s = sina;
		xfB.rotation.c = cosa;
    	//xfB.rotation.s = native_sin(thisPosB.a);
    	//xfB.rotation.c = native_cos(thisPosB.a);
    	//xfB.rotation.c = cos_wrapper(thisPosB.a);
    	
        xfA.translation=(float2)(thisPosA.cx,thisPosA.cy) - (float2)(xfA.rotation.c * thisManifold.localCenterA.x - xfA.rotation.s * thisManifold.localCenterA.y, xfA.rotation.s * thisManifold.localCenterA.x + xfA.rotation.c * thisManifold.localCenterA.y);
        xfB.translation=(float2)(thisPosB.cx,thisPosB.cy) - (float2)(xfB.rotation.c * thisManifold.localCenterB.x - xfB.rotation.s * thisManifold.localCenterB.y, xfB.rotation.s * thisManifold.localCenterB.x + xfB.rotation.c * thisManifold.localCenterB.y); 
        
        if(thisManifold.type==0)
            computePositionSolverManifoldCircles(&thisManifold,&thisPositionManifold,&xfA,&xfB,2);
        else if(thisManifold.type==1)
            computePositionSolverManifoldFaceA(&thisManifold,&thisPositionManifold,&xfA,&xfB,2);
        else if(thisManifold.type==2)
            computePositionSolverManifoldFaceB(&thisManifold,&thisPositionManifold,&xfA,&xfB,2);
        
        dA=thisPositionManifold.point - (float2)(thisPosA.cx,thisPosA.cy);
        dB=thisPositionManifold.point - (float2)(thisPosB.cx,thisPosB.cy);
        
        C=clamp(b2_baumgarte*(thisPositionManifold.separation+b2_linearSlop),-b2_maxLinearCorrection,0.0f);
        
        rnA=dA.x*thisPositionManifold.normal.y - dA.y*thisPositionManifold.normal.x;
        rnB=dB.x*thisPositionManifold.normal.y - dB.y*thisPositionManifold.normal.x;
        
        K=thisContact.invMassA + thisContact.invMassB + thisContact.invIA*rnA*rnA + thisContact.invIB*rnB*rnB;
        
        P=max(-C/K,0.0f)*thisPositionManifold.normal;
        
        thisPosA.cx=thisPosA.cx-thisContact.invMassA*P.x;
        thisPosA.cy=thisPosA.cy-thisContact.invMassA*P.y;
        thisPosA.a = thisPosA.a-thisContact.invIA * (dA.x * P.y - dA.y * P.x); 
        
        thisPosB.cx = thisPosB.cx+thisContact.invMassB * P.x; 
        thisPosB.cy = thisPosB.cy+thisContact.invMassB * P.y; 
        thisPosB.a = thisPosB.a+thisContact.invIB * (dB.x * P.y - dB.y * P.x);
    }
    
    positions[indexA]=thisPosA;
    positions[indexB]=thisPosB;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolveWheelJointPositionConstraint
//
// Compute positions of bodies which are constrained by a Wheel joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolveWheelJointPositionConstraint(
                                    __global clb2Position* positions,
									__global b2clJoint* jointList,
									const unsigned int offset,
									const unsigned int colorLength
									// __global testData* testBuffer
									)
{
	unsigned int jointIndex = get_global_id(0) + offset;

    if(jointIndex >= offset + colorLength) 
		return;

	b2clJoint thisJoint = jointList[jointIndex]; 

	clb2Position positionA = positions[thisJoint.indexA];
	clb2Position positionB = positions[thisJoint.indexB];

	float2 cA = (float2)(positionA.cx, positionA.cy);
	float aA = positionA.a;
	float2 cB = (float2)(positionB.cx, positionB.cy);
	float aB = positionB.a;

	float sina, cosa;

	sina = sincos(aA, &cosa);
	float2 qA = (float2)(sina, cosa);
	sina = sincos(aB, &cosa);
	float2 qB = (float2)(sina, cosa);
	//float2 qA = (float2)(sin(aA), cos(aA));
	//float2 qB = (float2)(sin(aB), cos(aB));
	//float2 qA = (float2)(sin(aA), cos_wrapper(aA));
	//float2 qB = (float2)(sin(aB), cos_wrapper(aB));

	float2 rA = b2clMul_Rotate(qA, (float2)(thisJoint.b.wheelJointData.localAnchorA[0] - thisJoint.b.wheelJointData.localCenterA[0], thisJoint.b.wheelJointData.localAnchorA[1] - thisJoint.b.wheelJointData.localCenterA[1]));
	float2 rB = b2clMul_Rotate(qB, (float2)(thisJoint.b.wheelJointData.localAnchorB[0] - thisJoint.b.wheelJointData.localCenterB[0], thisJoint.b.wheelJointData.localAnchorB[1] - thisJoint.b.wheelJointData.localCenterB[1]));
	float2 d = (cB - cA) + rB - rA;

	float2 m_localYAxisA = (float2)(thisJoint.b.wheelJointData.localYAxisA[0], thisJoint.b.wheelJointData.localYAxisA[1]);

	float2 ay = b2clMul_Rotate(qA, m_localYAxisA);

	float sAy = b2clCross_VV(d + rA, ay);
	float sBy = b2clCross_VV(rB, ay);

	float C = b2clDot(d, ay);

	float k = thisJoint.b.wheelJointData.invMassA + thisJoint.b.wheelJointData.invMassB + thisJoint.b.wheelJointData.invIA * thisJoint.b.wheelJointData.sAy * thisJoint.b.wheelJointData.sAy + thisJoint.b.wheelJointData.invIB * thisJoint.b.wheelJointData.sBy * thisJoint.b.wheelJointData.sBy;

	float impulse;
	if (k != 0.0f)
	{
		impulse = - C / k;
	}
	else
	{
		impulse = 0.0f;
	}

	float2 P = impulse * ay;
	float LA = impulse * sAy;
	float LB = impulse * sBy;

	cA -= thisJoint.b.wheelJointData.invMassA * P;
	aA -= thisJoint.b.wheelJointData.invIA * LA;
	cB += thisJoint.b.wheelJointData.invMassB * P;
	aB += thisJoint.b.wheelJointData.invIB * LB;

	positionA.cx = cA.x;
	positionA.cy = cA.y;
	positionA.a = aA;
	positionB.cx = cB.x;
	positionB.cy = cB.y;
	positionB.a = aB;
	positions[thisJoint.indexA] = positionA;
	positions[thisJoint.indexB] = positionB;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolveWeldJointPositionConstraint
//
// Compute positions of bodies which are constrained by a Weld joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolveWeldJointPositionConstraint(
                                    __global clb2Position* positions,
									__global b2clJoint* jointList,
									const unsigned int offset,
									const unsigned int colorLength
									// __global testData* testBuffer
									)
{
	unsigned int jointIndex = get_global_id(0) + offset;

    if(jointIndex >= offset + colorLength) 
		return;

	b2clJoint thisJoint = jointList[jointIndex]; 
	
	clb2Position positionA = positions[thisJoint.indexA];
	clb2Position positionB = positions[thisJoint.indexB];

	float2 cA = (float2)(positionA.cx, positionA.cy);
	float aA = positionA.a;
	float2 cB = (float2)(positionB.cx, positionB.cy);
	float aB = positionB.a;

	float sina, cosa;

	sina = sincos(aA, &cosa);
	float2 qA = (float2)(sina, cosa);
	sina = sincos(aB, &cosa);
	float2 qB = (float2)(sina, cosa);

	//float2 qA = (float2)(sin(aA), cos(aA));
	//float2 qB = (float2)(sin(aB), cos(aB));
	//float2 qA = (float2)(sin(aA), cos_wrapper(aA));
	//float2 qB = (float2)(sin(aB), cos_wrapper(aB));

	float2 rA = b2clMul_Rotate(qA, (float2)(thisJoint.b.weldJointData.localAnchorA[0] - thisJoint.b.weldJointData.localCenterA[0], thisJoint.b.weldJointData.localAnchorA[1] - thisJoint.b.weldJointData.localCenterA[1]));
	float2 rB = b2clMul_Rotate(qB, (float2)(thisJoint.b.weldJointData.localAnchorB[0] - thisJoint.b.weldJointData.localCenterB[0], thisJoint.b.weldJointData.localAnchorB[1] - thisJoint.b.weldJointData.localCenterB[1]));

	float mA = thisJoint.b.weldJointData.invMassA, mB = thisJoint.b.weldJointData.invMassB;
	float iA = thisJoint.b.weldJointData.invIA, iB = thisJoint.b.weldJointData.invIB;

	// TODO: positionError, angularError

	b2clMat33 K;
	K.ex[0] = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;
	K.ey[0] = -rA.y * rA.x * iA - rB.y * rB.x * iB;
	K.ez[0] = -rA.y * iA - rB.y * iB;
	K.ex[1] = K.ey[0];
	K.ey[1] = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;
	K.ez[1] = rA.x * iA + rB.x * iB;
	K.ex[2] = K.ez[0];
	K.ey[2] = K.ez[1];
	K.ez[2] = iA + iB;

	if (thisJoint.b.weldJointData.frequencyHz > 0.0f)
	{
		float2 C1 =  cB + rB - cA - rA;

		float2 P = -b2clMat33Solve22(K, C1);

		cA -= mA * P;
		aA -= iA * b2clCross_VV(rA, P);

		cB += mB * P;
		aB += iB * b2clCross_VV(rB, P);
	}
	else
	{
		float2 C1 =  cB + rB - cA - rA;
		float C2 = aB - aA - thisJoint.b.weldJointData.referenceAngle;

		float3 C = (float3)(C1.x, C1.y, C2);
	
		float3 impulse = -b2clMat33Solve(K, C);
		float2 P = (float2)(impulse.x, impulse.y);

		cA -= mA * P;
		aA -= iA * (b2clCross_VV(rA, P) + impulse.z);

		cB += mB * P;
		aB += iB * (b2clCross_VV(rB, P) + impulse.z);
	}

	positionA.cx = cA.x;
	positionA.cy = cA.y;
	positionA.a = aA;
	positionB.cx = cB.x;
	positionB.cy = cB.y;
	positionB.a = aB;
	positions[thisJoint.indexA] = positionA;
	positions[thisJoint.indexB] = positionB;
	
}

__kernel void SolveMouseJointPositionConstraint(
                                    __global clb2Position* positions,
									__global b2clJoint* jointList,
									const unsigned int offset,
									const unsigned int colorLength
									// __global testData* testBuffer
									)
{
	unsigned int jointIndex = get_global_id(0) + offset;

    if(jointIndex >= offset + colorLength) 
		return;
}

__kernel void SolveFrictionJointPositionConstraint(
                                    __global clb2Position* positions,
									__global b2clJoint* jointList,
									const unsigned int offset,
									const unsigned int colorLength
									// __global testData* testBuffer
									)
{
	unsigned int jointIndex = get_global_id(0) + offset;

    if(jointIndex >= offset + colorLength) 
		return;
}

__kernel void SolveSDVelocity(
                                 __global clb2Velocity* velocities,
                                 __global clb2Contact* contacts,
								 __global clb2Impulse* impulses, 
                                 __global clb2Points* points,
								 const __global b2clBodyStatic* bodyStaticListBuffer,
								 int sdContactNum,
								 unsigned int colorOffset,
								 unsigned int colorLength
                                 
								 )

{
	int contactIndex = get_global_id(0);
	if (contactIndex >= colorLength) return ; 
	contactIndex = contactIndex + colorOffset; 
	if (contactIndex >= sdContactNum) return ; 


    clb2Contact thisContact = contacts[contactIndex];
    clb2Impulse thisImpulse = impulses[contactIndex];
    clb2Points thisPoints = points[contactIndex];
    clb2Velocity thisVelA = velocities[thisContact.indexA];
    clb2Velocity thisVelB = velocities[thisContact.indexB];

	

    // Calculate the tangent impulse for the first contact point
    float2 dv;
    dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB1.y-thisVelA.vx+thisVelA.w * thisPoints.rA1.y;
    dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB1.x-thisVelA.vy-thisVelA.w * thisPoints.rA1.x;
    
    float vp = dv.x*thisContact.normal.y-dv.y*thisContact.normal.x;
    float lambda = thisPoints.tangentMass1 * (-vp);
    
    float maxFriction = thisContact.friction * thisImpulse.normalImpulse1;
    float newImpulse=clamp(thisImpulse.tangentImpulse1+lambda,-maxFriction,maxFriction);
    lambda=newImpulse-thisImpulse.tangentImpulse1;
    thisImpulse.tangentImpulse1=newImpulse;


    
    float2 P; 
    P.x = lambda*thisContact.normal.y;
    P.y = -lambda*thisContact.normal.x;
    
    thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
    thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 
    thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA1.x * P.y - thisPoints.rA1.y * P.x); 
    
    thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
    thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
    thisVelB.w= thisVelB.w+thisContact.invIB * (thisPoints.rB1.x * P.y - thisPoints.rB1.y * P.x);
 
    // Calculate the tangent impulse for the second contact point if there is the second contact point
    if(thisPoints.normalMass2>=0)
	{
        dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB2.y-thisVelA.vx+thisVelA.w * thisPoints.rA2.y;
        dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB2.x-thisVelA.vy-thisVelA.w * thisPoints.rA2.x;
        
        vp = dv.x*thisContact.normal.y-dv.y*thisContact.normal.x;
        lambda = thisPoints.tangentMass2 * (-vp);
        
        maxFriction = thisContact.friction * thisImpulse.normalImpulse2;
        newImpulse=clamp(thisImpulse.tangentImpulse2+lambda,-maxFriction,maxFriction);
        lambda=newImpulse-thisImpulse.tangentImpulse2;
        thisImpulse.tangentImpulse2=newImpulse;
        
        P.x = lambda*thisContact.normal.y;
        P.y = -lambda*thisContact.normal.x;
        
        thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
        thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 
        thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA2.x * P.y - thisPoints.rA2.y * P.x); 
        
        thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
        thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
        thisVelB.w= thisVelB.w+thisContact.invIB * (thisPoints.rB2.x * P.y - thisPoints.rB2.y * P.x);
		
    }
    
    // Calculate the normal impulse for the first contact point
    dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB1.y-thisVelA.vx+thisVelA.w * thisPoints.rA1.y;
    dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB1.x-thisVelA.vy-thisVelA.w * thisPoints.rA1.x;
   

	

    vp = dv.x*thisContact.normal.x+dv.y*thisContact.normal.y;
	
	
    lambda = -thisPoints.normalMass1 * (vp-thisPoints.velocityBias1);

	 
    newImpulse=fmax(thisImpulse.normalImpulse1+lambda,0);
    lambda=newImpulse-thisImpulse.normalImpulse1;
	   
    thisImpulse.normalImpulse1=newImpulse;
    
    P.x = lambda*thisContact.normal.x;
    P.y = lambda*thisContact.normal.y;    
	



    thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
    thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 
    thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA1.x * P.y - thisPoints.rA1.y * P.x); 
 
    
    thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
    thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
    thisVelB.w= thisVelB.w+thisContact.invIB * (thisPoints.rB1.x * P.y - thisPoints.rB1.y * P.x);
	thisVelB.w = 0; 

    
    // Calculate the normal impulse for the second contact point if there is the second contact point
    if(thisPoints.normalMass2>=0)
	{
        dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB2.y-thisVelA.vx+thisVelA.w * thisPoints.rA2.y;
        dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB2.x-thisVelA.vy-thisVelA.w * thisPoints.rA2.x;

        vp = dv.x*thisContact.normal.x+dv.y*thisContact.normal.y;
        lambda = -thisPoints.normalMass2 * (vp-thisPoints.velocityBias2);
    
        newImpulse=fmax(thisImpulse.normalImpulse2+lambda,0);
        lambda=newImpulse-thisImpulse.normalImpulse2;
        thisImpulse.normalImpulse2=newImpulse;
        
        P.x = lambda*thisContact.normal.x;
        P.y = lambda*thisContact.normal.y;
        
        thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
        thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 
        thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA2.x * P.y - thisPoints.rA2.y * P.x); 

        
        thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
        thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
        thisVelB.w = thisVelB.w+thisContact.invIB * (thisPoints.rB2.x * P.y - thisPoints.rB2.y * P.x);
		

		 thisVelB.w = 0; 
		 
    }
    	
   
    // Copy the results back to the buffers
    impulses[contactIndex] = thisImpulse;
	velocities[thisContact.indexA] = thisVelA;
	velocities[thisContact.indexB] = thisVelB;
	//if ( bodyStaticListBuffer[thisContact.indexA].m_type == 2)   velocities[thisContact.indexA]=thisVelA;
	//if ( bodyStaticListBuffer[thisContact.indexA].m_type == 2)   velocities[thisContact.indexA]=thisVelB;
}


__kernel void SolveSDPosition(
                                      __global clb2Position* positions,
                                      __global clb2Manifold* manifolds,
                                      __global clb2Contact* contacts,
								 const __global b2clBodyStatic* bodyStaticListBuffer,
								 int sdContactNum, 
								 unsigned int colorOffset, 
								 unsigned int colorLength
                                      )
{
	int contactIndex = get_global_id(0);
	if (contactIndex >= colorLength) return ; 
	contactIndex = contactIndex + colorOffset ; 
	if (contactIndex >= sdContactNum) return ; 

    clb2Contact thisContact=contacts[contactIndex];
    clb2Manifold thisManifold=manifolds[contactIndex];
    int indexA=thisContact.indexA;
    int indexB=thisContact.indexB;
    clb2Position thisPosA=positions[indexA];
    clb2Position thisPosB=positions[indexB];

    
    clb2PositionSolverManifold thisPositionManifold;
    
    clb2Transform xfA,xfB;
    float sina, cosa;
    
    sina = sincos(thisPosA.a, &cosa);
    xfA.rotation.s = sina;
    xfA.rotation.c = cosa;
    //xfA.rotation.s = native_sin(thisPosA.a);
    //xfA.rotation.c = native_cos(thisPosA.a);
    //xfA.rotation.c = cos_wrapper(thisPosA.a);
    
    sina = sincos(thisPosB.a, &cosa);
    xfB.rotation.s = sina;
    xfB.rotation.c = cosa;
    //xfB.rotation.s = native_sin(thisPosB.a);
    //xfB.rotation.c = native_cos(thisPosB.a);
    //xfB.rotation.c = cos_wrapper(thisPosB.a);
    
    xfA.translation=(float2)(thisPosA.cx,thisPosA.cy) - (float2)(xfA.rotation.c * thisManifold.localCenterA.x - xfA.rotation.s * thisManifold.localCenterA.y, xfA.rotation.s * thisManifold.localCenterA.x + xfA.rotation.c * thisManifold.localCenterA.y);
    xfB.translation=(float2)(thisPosB.cx,thisPosB.cy) - (float2)(xfB.rotation.c * thisManifold.localCenterB.x - xfB.rotation.s * thisManifold.localCenterB.y, xfB.rotation.s * thisManifold.localCenterB.x + xfB.rotation.c * thisManifold.localCenterB.y);  
    
    if(thisManifold.type==0)
        computePositionSolverManifoldCircles(&thisManifold,&thisPositionManifold,&xfA,&xfB,1);
    else if(thisManifold.type==1)
        computePositionSolverManifoldFaceA(&thisManifold,&thisPositionManifold,&xfA,&xfB,1);
    else if(thisManifold.type==2)
        computePositionSolverManifoldFaceB(&thisManifold,&thisPositionManifold,&xfA,&xfB,1);
    
    float2 dA=thisPositionManifold.point - (float2)(thisPosA.cx,thisPosA.cy);
    float2 dB=thisPositionManifold.point - (float2)(thisPosB.cx,thisPosB.cy);
    
    float C=clamp(b2_baumgarte*(thisPositionManifold.separation+b2_linearSlop),-b2_maxLinearCorrection,0.0f);
    
    float rnA=dA.x*thisPositionManifold.normal.y - dA.y*thisPositionManifold.normal.x;
    float rnB=dB.x*thisPositionManifold.normal.y - dB.y*thisPositionManifold.normal.x;
    
    float K=thisContact.invMassA + thisContact.invMassB + thisContact.invIA*rnA*rnA + thisContact.invIB*rnB*rnB;
    
    float2 P=max(-C/K,0.0f)*thisPositionManifold.normal;
 
    
    thisPosA.cx=thisPosA.cx-thisContact.invMassA*P.x;
    thisPosA.cy=thisPosA.cy-thisContact.invMassA*P.y;
    thisPosA.a = thisPosA.a-thisContact.invIA * (dA.x * P.y - dA.y * P.x); 
    
    thisPosB.cx = thisPosB.cx+thisContact.invMassB * P.x; 
    thisPosB.cy = thisPosB.cy+thisContact.invMassB * P.y; 
    thisPosB.a = thisPosB.a+thisContact.invIB * (dB.x * P.y - dB.y * P.x);
    
    if(thisManifold.pointCount==2){
        
 	    sina = sincos(thisPosA.a, &cosa);
    	xfA.rotation.s = sina;
    	xfA.rotation.c = cosa;
        //xfA.rotation.s = native_sin(thisPosA.a);
        //xfA.rotation.c = native_cos(thisPosA.a);
        //xfA.rotation.c = cos_wrapper(thisPosA.a);
        
 	    sina = sincos(thisPosB.a, &cosa);
    	xfB.rotation.s = sina;
    	xfB.rotation.c = cosa;
        //xfB.rotation.s = native_sin(thisPosB.a);
        //xfB.rotation.c = native_cos(thisPosB.a);
        //xfB.rotation.c = cos_wrapper(thisPosB.a);
        
        xfA.translation=(float2)(thisPosA.cx,thisPosA.cy) - (float2)(xfA.rotation.c * thisManifold.localCenterA.x - xfA.rotation.s * thisManifold.localCenterA.y, xfA.rotation.s * thisManifold.localCenterA.x + xfA.rotation.c * thisManifold.localCenterA.y);
        xfB.translation=(float2)(thisPosB.cx,thisPosB.cy) - (float2)(xfB.rotation.c * thisManifold.localCenterB.x - xfB.rotation.s * thisManifold.localCenterB.y, xfB.rotation.s * thisManifold.localCenterB.x + xfB.rotation.c * thisManifold.localCenterB.y); 
        
        if(thisManifold.type==0)
            computePositionSolverManifoldCircles(&thisManifold,&thisPositionManifold,&xfA,&xfB,2);
        else if(thisManifold.type==1)
            computePositionSolverManifoldFaceA(&thisManifold,&thisPositionManifold,&xfA,&xfB,2);
        else if(thisManifold.type==2)
            computePositionSolverManifoldFaceB(&thisManifold,&thisPositionManifold,&xfA,&xfB,2);
        
        dA=thisPositionManifold.point - (float2)(thisPosA.cx,thisPosA.cy);
        dB=thisPositionManifold.point - (float2)(thisPosB.cx,thisPosB.cy);
        
        C=clamp(b2_baumgarte*(thisPositionManifold.separation+b2_linearSlop),-b2_maxLinearCorrection,0.0f);
        
        rnA=dA.x*thisPositionManifold.normal.y - dA.y*thisPositionManifold.normal.x;
        rnB=dB.x*thisPositionManifold.normal.y - dB.y*thisPositionManifold.normal.x;
        
        K=thisContact.invMassA + thisContact.invMassB + thisContact.invIA*rnA*rnA + thisContact.invIB*rnB*rnB;
        
        P=max(-C/K,0.0f)*thisPositionManifold.normal;
        

        thisPosA.cx=thisPosA.cx-thisContact.invMassA*P.x;
        thisPosA.cy=thisPosA.cy-thisContact.invMassA*P.y;
        thisPosA.a = thisPosA.a-thisContact.invIA * (dA.x * P.y - dA.y * P.x); 
        
        thisPosB.cx = thisPosB.cx+thisContact.invMassB * P.x; 
        thisPosB.cy = thisPosB.cy+thisContact.invMassB * P.y; 
        thisPosB.a = thisPosB.a+thisContact.invIB * (dB.x * P.y - dB.y * P.x);
		
    }
	


	positions[indexA] = thisPosA ; 
	positions[indexB] = thisPosB ; 
   // if ( bodyStaticListBuffer[indexA].m_type == 2)   positions[indexA]=thisPosA;
   // if ( bodyStaticListBuffer[indexB].m_type == 2)  positions[indexB]=thisPosB;
}

inline float b2clMixFr(float friction1, float friction2)
{
	return sqrt(friction1 * friction2);
}
inline float b2clMixRes(float restitution1, float restitution2)
{
	return restitution1 > restitution2 ? restitution1 : restitution2;
}
__kernel void CollectStaticDynamicPairKernel (
                                 __global clb2Contact* contacts, // output
                                 __global clb2Points* points, // output
                                 __global clb2Manifold* manifoldBuffer, // output
								__global clb2Impulse* impulses, 
								 const __global clb2Velocity* velocities,
						         const __global clb2Position* positions,
						         const __global b2clFixtureStatic* fixtureStaticListBuffer,
								const __global b2clBodyStatic* bodyStaticListBuffer,
								const __global b2clPolygonShape* polyGlobal,
								const __global b2clTransform* xfGlobal,
								const __global clb2SDContact* contactDataBuffer,
								const __global clb2SDManifold* manifoldDataBuffer,
								const unsigned int contactCount

) 
{
	unsigned int contactIndex = get_global_id(0) ;
	if (contactIndex >= contactCount) return ; 
    clb2Contact thisContact;
    clb2Points currentPoints;
    clb2Manifold currentManifolds;

	int mfElmSize = 10 ; 
	int contactElmSize = 4 ; 

	int4 currentIndices; 

	clb2SDContact sdcontact = contactDataBuffer[contactIndex];
	
	
   // currentIndices.x = contactDataBuffer[contactIndex*contactElmSize+0]; currentIndices.y = contactDataBuffer[contactIndex*contactElmSize+1];currentIndices.z = contactDataBuffer[contactIndex*contactElmSize+2];currentIndices.w = contactDataBuffer[contactIndex*contactElmSize+3];
   currentIndices.x = sdcontact.fixtureAIndex; currentIndices.y = sdcontact.fixtureBIndex;
   currentIndices.z = sdcontact.bodyAIndex   ; currentIndices.w = sdcontact.bodyBIndex;
	float frictionA = fixtureStaticListBuffer[currentIndices.x].m_friction;
	float frictionB = fixtureStaticListBuffer[currentIndices.y].m_friction;
	thisContact.friction = b2clMixFr(frictionA, frictionB);

	b2clBodyStatic bodyStaticA = bodyStaticListBuffer[currentIndices.z];
	b2clBodyStatic bodyStaticB = bodyStaticListBuffer[currentIndices.w];
	thisContact.invMassA = bodyStaticA.m_invMass;
	thisContact.invMassB = bodyStaticB.m_invMass;
	thisContact.invIA = bodyStaticA.m_invI;
	thisContact.invIB = bodyStaticB.m_invI;
	thisContact.indexA = currentIndices.z;
	thisContact.indexB = currentIndices.w;

	

	//float manifold[20];
	//for (int i = 0 ; i < mfElmSize ; i ++ ) {manifold[i] = manifoldDataBuffer[contactIndex*mfElmSize+i]; }
	clb2SDManifold manifold = manifoldDataBuffer[contactIndex]; 

	b2clTransform xfA = xfGlobal[currentIndices.z];
	b2clTransform xfB = xfGlobal[currentIndices.w];
	float radiusA = polyGlobal[currentIndices.x].m_radius;
	float radiusB = polyGlobal[currentIndices.y].m_radius;
    float2 worldManifoldPoints[b2cl_maxManifoldPoints];
	float2 normal;
	int type = manifold.type ; 
	switch ( type)
	{
	case 0:
		{
			normal = (float2)(1.0, 0.0);
			//float2 pointA = b2clMul_Transform(&xfA,  (float2) (manifold[2], manifold[3]));
			//float2 pointB = b2clMul_Transform(&xfB, (float2) (manifold[6], manifold[7]));
			float2 pointA = b2clMul_Transform(&xfA,  (float2) (manifold.localPointX, manifold.localPointY));
			float2 pointB = b2clMul_Transform(&xfB, (float2) (manifold.point0X, manifold.point0Y));		
			if (b2clDistanceSquared(pointA, pointB) > b2_epsilon * b2_epsilon)
			{
				normal = normalize(pointB - pointA);
			}

			float2 cA = pointA + radiusA * normal;
			float2 cB = pointB - radiusB * normal;
			worldManifoldPoints[0] = 0.5f * (cA + cB);
		}
		break;
	case 1:
		{
			//normal = b2clMul_Rotate(xfA.q, (float2) (manifold[4], manifold[5])    );
			//float2 planePoint = b2clMul_Transform(&xfA, (float2) (manifold[2], manifold[3])  );
			normal = b2clMul_Rotate(xfA.q, (float2) (manifold.localNormalX, manifold.localNormalY)    );
			float2 planePoint = b2clMul_Transform(&xfA, (float2) (manifold.localPointX, manifold.localPointY)  );		
			//for (int i = 0; i < manifold[1]; ++i)
			for (int i = 0 ; i < manifold.pointCount; ++i )
			{
				//float2 clipPoint = b2clMul_Transform(&xfB, (float2) (manifold[6+2*i], manifold[7+2*i])    );
				float2 clipPoint ; 
				if (i == 0) clipPoint = b2clMul_Transform(&xfB, (float2) (manifold.point0X, manifold.point0Y)    );
				else clipPoint = b2clMul_Transform(&xfB, (float2) (manifold.point1X, manifold.point1Y)    );
					
				float2 cA = clipPoint + (radiusA - b2clDot(clipPoint - planePoint, normal)) * normal;
				float2 cB = clipPoint - radiusB * normal;
				worldManifoldPoints[i] = 0.5f * (cA + cB);
				//worldManifoldPoints[i] = clipPoint;
			}
			break;
		}
	case 2:
		{
			//normal = b2clMul_Rotate(xfB.q, (float2) (manifold[4], manifold[5])   );
			//float2 planePoint = b2clMul_Transform(&xfB, (float2) (manifold[2], manifold[3])     );
			normal = b2clMul_Rotate(xfB.q, (float2) (manifold.localNormalX, manifold.localNormalY)   );
			float2 planePoint = b2clMul_Transform(&xfB, (float2) (manifold.localPointX, manifold.localPointY)     );

			//for (int i = 0; i < manifold[1]; ++i)
			for (int i = 0; i < manifold.pointCount; ++i)
			{
			//	float2 clipPoint = b2clMul_Transform(&xfA, (float2) (manifold[6+2*i], manifold[7+2*i])       );
				float2 clipPoint ; 
				if (i == 0) clipPoint = b2clMul_Transform(&xfB, (float2) (manifold.point0X, manifold.point0Y)    );
				else clipPoint = b2clMul_Transform(&xfB, (float2) (manifold.point1X, manifold.point1Y)    );
				float2 cB = clipPoint + (radiusB - b2clDot(clipPoint - planePoint, normal)) * normal;
				float2 cA = clipPoint - radiusA * normal;
				worldManifoldPoints[i] = 0.5f * (cA + cB);
			}

			// Ensure normal points from A to B.
			normal = -normal;
			break;
		}
	}



	thisContact.normal = normal;

	clb2Position positionA = positions[currentIndices.z];
	clb2Position positionB = positions[currentIndices.w];
	currentPoints.rA1 = worldManifoldPoints[0] - (float2)(positionA.cx, positionA.cy);
	currentPoints.rB1 = worldManifoldPoints[0] - (float2)(positionB.cx, positionB.cy);

	float rnA = b2clCross_VV(currentPoints.rA1, normal);
	float rnB = b2clCross_VV(currentPoints.rB1, normal);
	float kNormal = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rnA * rnA + thisContact.invIB * rnB * rnB;
	currentPoints.normalMass1 = kNormal > 0.0f ? 1.0f / kNormal : 0.0f;

	float2 tangent = b2clCross_VS(normal, 1.0f);
	float rtA = b2clCross_VV(currentPoints.rA1, tangent);
	float rtB = b2clCross_VV(currentPoints.rB1, tangent);
	float kTangent = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rtA * rtA + thisContact.invIB * rtB * rtB;
	currentPoints.tangentMass1 = kTangent > 0.0f ? 1.0f /  kTangent : 0.0f;

	// Setup a velocity bias for restitution.
	clb2Velocity velocityA = velocities[currentIndices.z];
	clb2Velocity velocityB = velocities[currentIndices.w];
	float2 vA = (float2)(velocityA.vx, velocityA.vy);
	float2 vB = (float2)(velocityB.vx, velocityB.vy);
	float wA = velocityA.w;
	float wB = velocityB.w;
	float restitutionA = fixtureStaticListBuffer[currentIndices.x].m_restitution;
	float restitutionB = fixtureStaticListBuffer[currentIndices.y].m_restitution;
	float mixedrestitution = b2clMixRes(restitutionA, restitutionB);
	currentPoints.velocityBias1 = 0.0f;
	float vRel = b2clDot(normal, vB + b2clCross_SV(wB, currentPoints.rB1) - vA - b2clCross_SV(wA, currentPoints.rA1));
	if (vRel < -b2cl_velocityThreshold)
	{
		currentPoints.velocityBias1 = -mixedrestitution * vRel;
	}
  //  currentManifolds.localNormal = (float2) (manifold[4], manifold[5]);
  //  currentManifolds.localPoint = (float2) (manifold[2], manifold[3]);
  //  currentManifolds.type=manifold[0];
  //  currentManifolds.pointCount=manifold[1];
 //   currentManifolds.localPoints1=(float2) (manifold[6], manifold[7]);
    currentManifolds.localNormal = (float2) (manifold.localNormalX, manifold.localNormalY);
    currentManifolds.localPoint = (float2) (manifold.localPointX, manifold.localPointY);
    currentManifolds.type=manifold.type;
    currentManifolds.pointCount=manifold.pointCount;
    currentManifolds.localPoints1=(float2) (manifold.point0X, manifold.point0Y);
    currentManifolds.radiusA=radiusA;
    currentManifolds.radiusB=radiusB;
    currentManifolds.localCenterA=bodyStaticA.m_localCenter;
    currentManifolds.localCenterB=bodyStaticB.m_localCenter;
	//if (manifold[1]>1)
	if (manifold.pointCount>1)
	{
		currentPoints.rA2 = worldManifoldPoints[1] - (float2)(positionA.cx, positionA.cy);
		currentPoints.rB2 = worldManifoldPoints[1] - (float2)(positionB.cx, positionB.cy);

		float rnA = b2clCross_VV(currentPoints.rA2, normal);
		float rnB = b2clCross_VV(currentPoints.rB2, normal);
		float kNormal = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rnA * rnA + thisContact.invIB * rnB * rnB;
		currentPoints.normalMass2 = kNormal > 0.0f ? 1.0f / kNormal : 0.0f;

		float2 tangent = b2clCross_VS(normal, 1.0f);
		float rtA = b2clCross_VV(currentPoints.rA2, tangent);
		float rtB = b2clCross_VV(currentPoints.rB2, tangent);
		float kTangent = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rtA * rtA + thisContact.invIB * rtB * rtB;
		currentPoints.tangentMass2 = kTangent > 0.0f ? 1.0f /  kTangent : 0.0f;

		currentPoints.velocityBias2 = 0.0f;
		float vRel = b2clDot(normal, vB + b2clCross_SV(wB, currentPoints.rB2) - vA - b2clCross_SV(wA, currentPoints.rA2));
		if (vRel < -b2cl_velocityThreshold)
		{
			currentPoints.velocityBias2 = -mixedrestitution * vRel;
		}

		//currentManifolds.localPoints2=(float2) (manifold[8], manifold[9]);
		currentManifolds.localPoints2=(float2) (manifold.point1X, manifold.point1Y);
	}
	else
	{
		currentPoints.rA2 = -1;
		currentPoints.rB2 = -1;
		currentPoints.normalMass2 = -1;
		currentPoints.tangentMass2 = -1;
		currentPoints.velocityBias2 = -1;
	}



 //clb2Impulse thisImpulse = impulses[contactIndex];
 clb2Impulse thisImpulse;
 thisImpulse.tangentImpulse1=thisImpulse.normalImpulse1 =  thisImpulse.tangentImpulse2=thisImpulse.normalImpulse2 = 0 ;
 impulses[contactIndex] = thisImpulse ; 


// printf ("thisContactIndexA: %d, thisContact.indexB: %d \n", thisContact.indexA, thisContact.indexB); 

	contacts[contactIndex] = thisContact;

	points[contactIndex].rA1 = currentPoints.rA1;
	points[contactIndex].rB1 = currentPoints.rB1;
	points[contactIndex].normalMass1 = currentPoints.normalMass1;
	points[contactIndex].tangentMass1 = currentPoints.tangentMass1;
	points[contactIndex].velocityBias1 = currentPoints.velocityBias1;

	points[contactIndex].rA2 = currentPoints.rA2;
	points[contactIndex].rB2 = currentPoints.rB2;
	points[contactIndex].normalMass2 = currentPoints.normalMass2;
	points[contactIndex].tangentMass2 = currentPoints.tangentMass2;
	points[contactIndex].velocityBias2 = currentPoints.velocityBias2;
	
	 
    manifoldBuffer[contactIndex] = currentManifolds;

	
}

__kernel void InitStaticDynamicBodyKernel (
	__global clb2Position* positions,
	__global b2clTransform* xfGlobal,
	const __global clb2SDBody* sdBodyData,
	int bodyNum
)
{


	int index = get_global_id(0);
	if (index >= bodyNum) return ; 

	int bodyElmSize = 12 ; 
	//float value[20] ; 
	//memcpy ( value, &(sdBodyData[index*8], sizeof(float)*8);
	//for (int i = 0 ; i < bodyElmSize ; i ++) {value[i] = sdBodyData[index*bodyElmSize+i]; }
	clb2SDBody value = sdBodyData[index]; 
	//int bodyIndex = (int)value[0] ;
	int bodyIndex = value.bodyIndex ;  
	clb2Position pos ; 
	b2clTransform t ; 


	//pos.cx = value[1] ; 
    //pos.cy = value[2] ; 
	//pos.a = value[3] ;
	//t.p= (float2) (value[4], value[5]);
	//t.q = (float2) (value[6],value[7]) ; 

	pos.cx = value.posX; pos.cy = value.posY ; pos.a = value.posAngle;
	t.p= (float2) (value.xfX, value.xfY);
	t.q = (float2) (value.xfS, value.xfC); 


	clb2Position prevPos = positions[bodyIndex]; 
	positions[bodyIndex] = pos ; 
	xfGlobal[bodyIndex] = t ; 

}

__kernel void syncSDBody (
                                __global clb2Velocity* velocities,
                                __global clb2Position* positions,
								__global b2clTransform* xfGlobal, 
								__global b2clBodyDynamic* bodyDynamicListBuffer,
								const __global b2clBodyStatic* bodyStaticListBuffer,
								__global clb2SDBody* bodyDataArray, 
								const float stepdt, 
								int bodyNum 
)
{
    int arrayIndex=get_global_id(0);
    
    if(arrayIndex>=bodyNum) return;
	int bodyElmSize = 12 ; 

   // int bodyIndex = bodyDataArray[arrayIndex* bodyElmSize+0]; 


   clb2SDBody sdbody = bodyDataArray[arrayIndex] ; 
   int bodyIndex = sdbody.bodyIndex; 

	//float dt = bodyDataArray[arrayIndex*bodyElmSize+8]*stepdt; 
	float dt = sdbody.alpha * stepdt ; 
// Integrate position. 

    clb2Position thisPosition=positions[bodyIndex];
    clb2Velocity thisVelocity=velocities[bodyIndex];
    
    float2 translation = (float2)(dt*thisVelocity.vx, dt*thisVelocity.vy);
    float translationLength=sqrt(dot(translation,translation));
    if(translationLength>b2_maxTranslation){
        thisVelocity.vx *= (b2_maxTranslation/translationLength);
		thisVelocity.vy *= (b2_maxTranslation/translationLength);
    }
    float rotation = dt*thisVelocity.w;
    float rotationMagnitude = fabs(rotation);

    if(rotationMagnitude>b2_maxRotation){
        thisVelocity.w *= (b2_maxRotation/rotationMagnitude);
    }
    
    thisPosition.cx += dt*thisVelocity.vx;
	thisPosition.cy += dt*thisVelocity.vy;
    thisPosition.a += dt*thisVelocity.w;
    
	

    positions[bodyIndex] = thisPosition;
    velocities[bodyIndex] = thisVelocity;


// Syncronize

	b2clBodyStatic bs = bodyStaticListBuffer[bodyIndex];
	__global b2clBodyDynamic* bd = bodyDynamicListBuffer + bodyIndex;

	float2 c;
	c.x = thisPosition.cx;
	c.y = thisPosition.cy;
	float a = thisPosition.a;

	// synchronize xf for each body
	float2 p, q;
	q.x = sin(a);
	q.y = cos(a);
	p = c - b2clMul_Rotate(q, bs.m_localCenter);
	xfGlobal[bodyIndex].p = p;
	xfGlobal[bodyIndex].q = q;

	bd->m_sweep.c = c;
	bd->m_sweep.a = a;

	//float value[20] ; 
	//value[1] = c.x; value[2] = c.y ; value[3] = a ; value[4] = p.x ; value[5] = p.y ; value[6] = q.x; value[7] = q.y ; 
	//value[9] = thisVelocity.vx ; 	value[10] = thisVelocity.vy ; value[11] = thisVelocity.w ; 

	sdbody.posX = c.x ; sdbody.posY = c.y ; sdbody.posAngle = a ; sdbody.xfX = p.x ; sdbody.xfY = p.y ; sdbody.xfS = q.x ; sdbody.xfC = q.y ; 
	sdbody.velocityX = thisVelocity.vx; sdbody.velocityY = thisVelocity.vy; sdbody.velocityAngular = thisVelocity.w ; 
	bodyDataArray[arrayIndex] = sdbody ; 

  //  for (int i = 1 ; i < bodyElmSize ; i ++) {
//		bodyDataArray[arrayIndex*bodyElmSize+i] = value[i] ; 
//	}


}/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/



/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/


#pragma OPENCL EXTENSION cl_amd_printf : enable

/// The maximum number of contact points between two convex shapes. Do
/// not change this value.
#define b2cl_maxManifoldPoints	2

/// The maximum number of vertices on a convex polygon. You cannot increase
/// this too much because b2BlockAllocator has a maximum object size.
#define b2cl_maxPolygonVertices	8

/// A velocity threshold for elastic collisions. Any collision with a relative linear
/// velocity below this threshold will be treated as inelastic.
//#define b2cl_velocityThreshold		0.01f
#define b2cl_velocityThreshold		1.0f

/// This is used to fatten AABBs in the dynamic tree. This is used to predict
/// the future position based on the current displacement.
/// This is a dimensionless multiplier.
#define b2cl_aabbMultiplier		2.0f

#define	b2_maxFloat	FLT_MAX
#define	b2_epsilon FLT_EPSILON
#define b2_pi 3.14159265359f
#define b2_maxTranslation 2.0f
#define b2_maxRotation 0.5f*b2_pi
#define b2_baumgarte 0.2f
#define b2_linearSlop 0.005f
#define b2_angularSlop			(2.0f / 180.0f * b2_pi)
#define b2_polygonRadius		(2.0f * b2_linearSlop)
#define b2_maxLinearCorrection 0.2f
#define b2_maxAngularCorrection		(8.0f / 180.0f * b2_pi)

#ifndef MAXFLOAT
#define MAXFLOAT      3.402823466e+38F
#endif


/// The features that intersect to form the contact point
/// This must be 4 bytes or less.
typedef struct b2clContactFeature
{
	uchar indexA;		///< Feature index on shapeA
	uchar indexB;		///< Feature index on shapeB
	uchar typeA;		///< The feature type on shapeA
	uchar typeB;		///< The feature type on shapeB
} b2clContactFeature;

/// Contact ids to facilitate warm starting.
typedef union b2clContactID
{
	b2clContactFeature cf;
	uint key;					///< Used to quickly compare contact ids.
} b2clContactID;

/// A manifold point is a contact point belonging to a contact
/// manifold. It holds details related to the geometry and dynamics
/// of the contact points.
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleB
/// -e_faceA: the local center of cirlceB or the clip point of polygonB
/// -e_faceB: the clip point of polygonA
/// This structure is stored across time steps, so we keep it small.
/// Note: the impulses are used for internal caching and may not
/// provide reliable contact forces, especially for high speed collisions.
typedef struct b2clManifoldPoint
{
	float2 localPoint;		///< usage depends on manifold type
	float normalImpulse;	///< the non-penetration impulse
	float tangentImpulse;	///< the friction impulse
	b2clContactID id;			///< uniquely identifies a contact point between two shapes
	float dummy; // for alignment
} b2clManifoldPoint;

/// A manifold for two touching convex shapes.
/// Box2D supports multiple types of contact:
/// - clip point versus plane with radius
/// - point versus point with radius (circles)
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleA
/// -e_faceA: the center of faceA
/// -e_faceB: the center of faceB
/// Similarly the local normal usage:
/// -e_circles: not used
/// -e_faceA: the normal on polygonA
/// -e_faceB: the normal on polygonB
/// We store contacts in this way so that position correction can
/// account for movement, which is critical for continuous physics.
/// All contact scenarios must be expressed in one of these types.
/// This structure is stored across time steps, so we keep it small.
typedef struct b2clManifold
{
	float2 localNormal;								///< not use for Type::e_points
	float2 localPoint;								///< usage depends on manifold type
	b2clManifoldPoint points[b2cl_maxManifoldPoints];	///< the points of contact
	int type;
	int pointCount;								///< the number of manifold points
	//float2 test;
} b2clManifold;

typedef struct b2clFilter
{
	unsigned short categoryBits;
	unsigned short maskBits;
	short groupIndex;
	short dummy;
} b2clFilter;

/// A convex polygon. It is assumed that the interior of the polygon is to
/// the left of each edge.
/// Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.
/// In most cases you should not need many vertices for a convex polygon.
//////////////
/// We reuse b2clPolygonShape for b2clCircleShape
/// We may have to change this later
typedef struct b2clPolygonShape
{
	float2 m_centroid;
	float2 m_vertices[b2cl_maxPolygonVertices];
	float2 m_normals[b2cl_maxPolygonVertices];
	int m_type;
	float m_radius;
	int m_vertexCount;
	int m_bIsSensor;
	b2clFilter m_filter;
} b2clPolygonShape;

/// A transform contains translation and rotation. It is used to represent
/// the position and orientation of rigid frames.
typedef struct b2clTransform
{
	float2 p;
	float2 q;
} b2clTransform;

/// This describes the motion of a body/shape for TOI computation.
/// Shapes are defined with respect to the body origin, which may
/// no coincide with the center of mass. However, to support dynamics
/// we must interpolate the center of mass position.
typedef struct b2clSweep
{
	float2 localCenter;	///< local center of mass position
	float2 c0, c;		///< center world positions
	float a0, a;		///< world angles

	/// Fraction of the current time step in the range [0,1]
	/// c0 and a0 are the positions at alpha0.
	float alpha0;
	float dummy;
}  b2clSweep;

/// Used for computing contact manifolds.
typedef struct b2clClipVertex
{
	float2 v;
	b2clContactID id;
} b2clClipVertex;

typedef struct clb2Velocity
{
    float vx;
    float vy;
    float w;
}clb2Velocity;

typedef struct clb2Position
{
    float cx;
    float cy;
    float a;
}clb2Position;

typedef struct clb2Contact
{
    int color;
    int indexA;
    int indexB;
    float friction;
    float2 normal;
    float invMassA;
    float invIA;
    float invMassB;
    float invIB;
}clb2Contact;

typedef struct clb2Impulse
{
    float normalImpulse1;
    float tangentImpulse1;
    
    float normalImpulse2;
    float tangentImpulse2;
}clb2Impulse;

typedef struct clb2Points
{
    float2 rA1;
    float2 rB1;
    float normalMass1;
    float tangentMass1;
    
    float2 rA2;
    float2 rB2;
    float normalMass2;
    float tangentMass2;
    
    float velocityBias1;
    float velocityBias2;
}clb2Points;

typedef struct b2clFixtureStatic
{
	float m_friction;
	float m_restitution;
	int m_last_uid;
	int dummy; 
} b2clFixtureStatic;

#define MAX_CONNECTED_BODY_INDICES 8
typedef struct b2clBodyStatic
{
	float2 m_localCenter;	///< local center of mass position
	float /*m_mass,*/ m_invMass;
	// Rotational inertia about the center of mass.
	float /*m_I,*/ m_invI;
	float m_linearDamping;
	float m_angularDamping;
	float m_gravityScale;
	float m_type;
	int m_connectedBodyIndices[MAX_CONNECTED_BODY_INDICES];
	int m_bIsBullet;
	int dummy;
} b2clBodyStatic;

typedef struct b2clBodyDynamic
{
	b2clSweep m_sweep;		// the swept motion for CCD

	float2 m_linearVelocity;
	float2 m_force;
	float m_angularVelocity;
	float m_torque;
	int m_last_uid ;
	int dummy ; 
} b2clBodyDynamic;

// Extract useful information of manifolds for position constraint solver
typedef struct clb2Manifold
{
    float2 localNormal;
    float2 localPoint;
    float2 localPoints1;
    float2 localPoints2;
    int pointCount;
    int type;
    float radiusA;
    float radiusB;
    float2 localCenterA;
    float2 localCenterB;
}clb2Manifold;

typedef struct{
    int type;
	int pointCount;
	float localPointX;
	float localPointY;
	float localNormalX;
	float localNormalY; 
	float point0X;
	float point0Y;
	float point1X;
	float point1Y; 
}clb2SDManifold;

typedef struct{
	int fixtureAIndex;
	int fixtureBIndex;
	int bodyAIndex ; 
	int bodyBIndex ; 
}clb2SDContact;

typedef struct{
	int bodyIndex ;
	float posX;
	float posY ; 
	float posAngle;
	float xfX;
	float xfY;
	float xfS;
	float xfC;
	float alpha;
	float velocityX;
	float velocityY;
	float velocityAngular; 
}clb2SDBody;

typedef struct clb2PositionSolverManifold
{
    float2 normal;
    float2 point;
    float separation;
}clb2PositionSolverManifold;

typedef struct clb2Rotation
{
    float s;
    float c;
}clb2Rotation;

typedef struct clb2Transform
{
    clb2Rotation rotation;
    float2 translation;
}clb2Transform;

typedef struct b2clMat22
{
	float ex[2];
	float ey[2];
}b2clMat22;

typedef struct b2clMat33
{
	float ex[3];
	float ey[3];
	float ez[3];
}b2clMat33;

enum b2clLimitState
{
	e_inactiveLimit,
	e_atLowerLimit,
	e_atUpperLimit,
	e_equalLimits
};

enum b2JointType
{
	e_unknownJoint,
	e_revoluteJoint,
	e_prismaticJoint,
	e_distanceJoint,
	e_pulleyJoint,
	e_mouseJoint,
	e_gearJoint,
	e_wheelJoint,
    e_weldJoint,
	e_frictionJoint,
	e_ropeJoint
};

typedef struct b2clDistanceJointDatastruct
{
	float frequencyHz;
	float dampingRatio;
	float bias;

	float localAnchorA[2];
	float localAnchorB[2];
	float gamma;
	float nlength;

	float u[2];
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	float mass;
} b2clDistanceJointData;

typedef struct b2clRevoluteJointData
{
	float localAnchorA[2];
	float localAnchorB[2];

	int enableMotor;
	float maxMotorTorque;
	float motorSpeed;

	int enableLimit;
	float referenceAngle;
	float lowerAngle;
	float upperAngle;

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat33 mass;			// effective mass for point-to-point constraint.
	float motorMass;	// effective mass for motor/limit angular constraint.
	int limitState;
} b2clRevoluteJointData;

typedef struct b2clPrismaticJointData
{
	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float localXAxisA[2];
	float localYAxisA[2];
	float referenceAngle;
	float lowerTranslation;
	float upperTranslation;
	float maxMotorForce;
	float motorSpeed;
	int enableLimit;
	int enableMotor;
	int limitState;

	// Solver temp
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	float axis[2], perp[2];
	float s1, s2;
	float a1, a2;
	b2clMat33 K;
	float motorMass;
} b2clPrismaticJointData;

typedef struct b2clGearJointData
{
	int joint1;
	int joint2;
	int typeA;
	int typeB;

	float localAnchorA[2];
	float localAnchorB[2];
	float localAnchorC[2];
	float localAnchorD[2];

	float localAxisC[2];
	float localAxisD[2];

	float referenceAngleA;
	float referenceAngleB;

	float gearConstant;
	float ratio;

	// Solver temp
	float lcA[2], lcB[2], lcC[2], lcD[2];
	float mA, mB, mC, mD;
	float iA, iB, iC, iD;
	float JvAC[2], JvBD[2];
	float JwA, JwB, JwC, JwD;
	float mass;
} b2clGearJointData;

typedef struct b2clPulleyJointData
{
	float groundAnchorA[2];
	float groundAnchorB[2];
	float lengthA;
	float lengthB;
	float localAnchorA[2];
	float localAnchorB[2]; 
	float pulleyConstant; 
	float ratio; 
	float uA[2]; 
	float uB[2]; 
	float rA[2]; 
	float rB[2]; 
	float localCenterA[2];
	float localCenterB[2]; 
	float invMassA; 
	float invMassB; 
	float invIA; 
	float invIB;
	float mass; 
}b2clPulleyJointData; 

typedef struct b2clRopeJointData
{	
	float localAnchorA[2];
	float localAnchorB[2]; 
	float maxLength; 
	float nlength;
	float u[2]; 
	float rA[2]; 
	float rB[2]; 
	float localCenterA[2];
	float localCenterB[2]; 
	float invMassA; 
	float invMassB; 
	float invIA; 
	float invIB;
	float mass; 
	int limitState; 
} b2clRopeJointData; 

typedef struct b2clWheelJointData
{
	float frequencyHz;
	float dampingRatio;

	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float localXAxisA[2];
	float localYAxisA[2];

	float maxMotorTorque;
	float motorSpeed;
	int enableMotor;

	// Solver temp
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;

	float ax[2], ay[2];
	float sAx, sBx;
	float sAy, sBy;

	float mass;
	float motorMass;
	float springMass;

	float bias;
	float gamma;
} b2clWheelJointData;

typedef struct b2clWeldJointData
{
	float frequencyHz;
	float dampingRatio;
	float bias;

	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float referenceAngle;
	float gamma;

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat33 mass;
} b2clWeldJointData;

typedef struct b2clMouseJointData
{
	float localAnchorB[2];
	float targetA[2];
	float frequencyHz;
	float dampingRatio;
	float beta;
	
	// Solver shared
	float maxForce;
	float gamma;

	// Solver temp
	float rB[2];
	float localCenterB[2];
	float invMassB;
	float invIB;
	b2clMat22 mass;
	float C[2];
} b2clMouseJointData;

typedef struct b2clFrictionJointData
{
	float localAnchorA[2];
	float localAnchorB[2];

	float maxForce; 
	float maxTorque; 

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat22 linearMass;
	float angularMass; 
} b2clFrictionJointData;

typedef struct clJoint
{
	int index;

	// impulse : 4 floats
	union a1{
		struct x1{
			float impulse[3];
		}x;
		struct y1{
			float scalarImpulse;
			float springImpulse;
		}y;
		struct z1{
			float linearImpulse[2];
			float angularImpulse;
		}z;
	}a;
	float motorImpulse;

	int color;
	int type;
	int collideConnected;

	int indexA, indexB, indexC, indexD;

	union b1{
		b2clDistanceJointData distanceJointData;
		b2clRevoluteJointData revoluteJointData;
		b2clPrismaticJointData prismaticJointData;
		b2clGearJointData gearJointData;
		b2clPulleyJointData pulleyJointData;
		b2clRopeJointData ropeJointData;
		b2clWheelJointData wheelJointData;
		b2clWeldJointData weldJointData;
		b2clMouseJointData mouseJointData;
		b2clFrictionJointData frictionJointData;
	}b;
} b2clJoint;

typedef struct
{
	int index;
    float nimpulse[4];
} b2clJointImpulseNode;

typedef struct
{
	int isCollide;
	float normal[2];
	float fraction;
	unsigned int shapeIndex;
} b2clRayCastOutput;

typedef struct
{
	float2 m_buffer[2];
	float2 m_vertices[b2cl_maxPolygonVertices];
	int m_count;
	float m_radius;
} b2clDistanceProxy;

typedef struct 
{
	float metric;		///< length or area
	short count;
	unsigned char indexA[3];	///< vertices on shape A
	unsigned char indexB[3];	///< vertices on shape B
} b2clSimplexCache;

/// Input for b2Distance.
/// You have to option to use the shape radii
/// in the computation. Even 
typedef struct 
{
	b2clDistanceProxy proxyA;
	b2clDistanceProxy proxyB;
	b2clTransform transformA;
	b2clTransform transformB;
	bool useRadii;
} b2clDistanceInput;

/// Output for b2Distance.
typedef struct
{
	float2 pointA;		///< closest point on shapeA
	float2 pointB;		///< closest point on shapeB
	float ndistance;
	int iterations;	///< number of GJK iterations used
} b2clDistanceOutput;

typedef struct
{
	b2clDistanceProxy proxyA;
	b2clDistanceProxy proxyB;
	b2clSweep sweepA;
	b2clSweep sweepB;
	float tMax;		// defines sweep interval [0, tMax]
	float dummy;
} b2clTOIInput;

enum b2clTOIOutputState
{
	e_unknown,
	e_failed,
	e_overlapped,
	e_touching,
	e_separated
};

typedef struct
{
	int state;
	float t;
} b2clTOIOutput;

typedef struct
{
	float2 wA;		// support point in proxyA
	float2 wB;		// support point in proxyB
	float2 w;		// wB - wA
	float a;		// barycentric coordinate for closest point
	int indexA;	// wA index
	int indexB;	// wB index
} b2clSimplexVertex;

typedef struct 
{
	b2clSimplexVertex m_v1, m_v2, m_v3;
	int m_count;
} b2clSimplex;

//typedef struct{
//float v[30];
//} testData; 

//==============================================================================================
// Math functions
//==============================================================================================

/// Multiply two rotations: q * r
inline float2 b2clMul_TwoRotation(const float2 q, const float2 r)
{
	// [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
	// [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]
	// s = qs * rc + qc * rs
	// c = qc * rc - qs * rs
	float2 qr;
	qr.x = q.x * r.y + q.y * r.x;
	qr.y = q.y * r.y - q.x * r.x;
	return qr;
}

/// Transpose multiply two rotations: qT * r
inline float2 b2clMulT_TwoRotation(const float2 q, const float2 r)
{
	// [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
	// [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]
	// s = qc * rs - qs * rc
	// c = qc * rc + qs * rs
	float2 qr;
	qr.x = q.y * r.x - q.x * r.y;
	qr.y = q.y * r.y + q.x * r.x;
	return qr;
}

/// Rotate a vector
inline float2 b2clMul_Rotate(const float2 q, const float2 v)
{
	float2 result;
	result.x = q.y * v.x - q.x * v.y;
	result.y = q.x * v.x + q.y * v.y;

	return result;
}

/// Inverse rotate a vector
inline float2 b2clMulT_Rotate(const float2 q, const float2 v)
{
	float2 result;
	result.x = q.y * v.x + q.x * v.y;
	result.y = -q.x * v.x + q.y * v.y;

	return result;
}

/// Transform a vector
inline float2 b2clMul_Transform(const b2clTransform *T, const float2 v)
{
	float2 result;
	result.x = (T->q.y * v.x - T->q.x * v.y) + T->p.x;
	result.y = (T->q.x * v.x + T->q.y * v.y) + T->p.y;

	return result;
}

/// Invert transform a vector
inline float2 b2clMulT_Transform(const b2clTransform *T, const float2 v)
{
	float px = v.x - T->p.x;
	float py = v.y - T->p.y;
	float2 result;
	result.x = (T->q.y * px + T->q.x * py);
	result.y = (-T->q.x * px + T->q.y * py);

	return result;
}

// v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
//    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
inline b2clTransform b2clMul_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
	b2clTransform C;
	C.q = b2clMul_TwoRotation(A->q, B->q);
	C.p = b2clMul_TwoRotation(A->q, B->p) + A->p;
	return C;
}

// v2 = A.q' * (B.q * v1 + B.p - A.p)
//    = A.q' * B.q * v1 + A.q' * (B.p - A.p)
inline b2clTransform b2clMulT_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
	b2clTransform C;
	C.q = b2clMulT_TwoRotation(A->q, B->q);
	C.p = b2clMulT_TwoRotation(A->q, B->p - A->p);
	return C;
}

/// Perform the dot product on two vectors.
inline float b2clDot(const float2 a, const float2 b)
{
	return a.x * b.x + a.y * b.y;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float b2clCross_VV(const float2 a, const float2 b)
{
	return a.x * b.y - a.y * b.x;
}

/// Perform the cross product on a vector and a scalar. In 2D this produces
/// a vector.
inline float2 b2clCross_VS(const float2 a, float s)
{
	return (float2)(s * a.y, -s *a.x);
}

/// Perform the cross product on a scalar and a vector. In 2D this produces
/// a vector.
inline float2 b2clCross_SV(float s, const float2 a)
{
	return (float2)(-s * a.y, s * a.x);
}

inline float b2clClamp(float a, float low, float high)
{
	return max(low, min(a, high));
}

inline float2 b2clMin(const float2 a, const float2 b)
{
	return (float2)(min(a.x, b.x), min(a.y, b.y));
}

inline float2 b2clMax(const float2 a, const float2 b)
{
	return (float2)(max(a.x, b.x), max(a.y, b.y));
}

inline float b2clDistanceSquared(const float2 a, const float2 b)
{
	float2 c = a - b;
	return b2clDot(c, c);
}

inline float b2clDistance(const float2 a, const float2 b)
{
	float2 c = a - b;
	return sqrt(b2clDot(c, c));
}

inline float b2clLengthSquared(const float2 v)
{
	return b2clDot(v, v);
}

inline float b2clAbs(float a)
{
	return a > 0.0f ? a : -a;
}

/// Perform the dot product on two vectors.
inline float b2clDot3(const float3 a, const float3 b)
{
	return a.x * b.x + a.y * b.y + a.z * b.z;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float3 b2clCross3_VV(const float3 a, const float3 b)
{
	return (float3)(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float3 b2clMat33Solve(const b2clMat33 mat, const float3 b)
{
	float3 ex = (float3)(mat.ex[0], mat.ex[1], mat.ex[2]);
	float3 ey = (float3)(mat.ey[0], mat.ey[1], mat.ey[2]);
	float3 ez = (float3)(mat.ez[0], mat.ez[1], mat.ez[2]);

	float det = b2clDot3(ex, b2clCross3_VV(ey, ez));

	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float3 x;
	x.x = det * b2clDot3(b, b2clCross3_VV(ey, ez));
	x.y = det * b2clDot3(ex, b2clCross3_VV(b, ez));
	x.z = det * b2clDot3(ex, b2clCross3_VV(ey, b));
	return x;
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float2 b2clMat33Solve22(const b2clMat33 mat, const float2 b)
{
	float2 ex = (float2)(mat.ex[0], mat.ex[1]);
	float2 ey = (float2)(mat.ey[0], mat.ey[1]);

	float det = ex.x * ey.y - ey.x * ex.y;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float2 x;
	x.x = det * (ey.y * b.x - ey.x * b.y);
	x.y = det * (ex.x * b.y - ex.y * b.x);
	return x;
}

inline float2 b2clMat22Solve(const b2clMat22 mat, const float2 b)
{
	float2 ex = (float2)(mat.ex[0], mat.ex[1]);
	float2 ey = (float2)(mat.ey[0], mat.ey[1]);

	float det = ex.x * ey.y - ey.x * ex.y;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float2 x;
	x.x = det * (ey.y * b.x - ey.x * b.y);
	x.y = det * (ex.x * b.y - ex.y * b.x);
	return x;
}

inline float2 b2clMat33Mul22(const b2clMat33 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float2 b2clMat22Mul(const b2clMat22 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline void b2clGetInverse22(const b2clMat33 in, b2clMat33* out)
{
	float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
	float det = a * d - b * c;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}

	out->ex[0] =  det * d;	out->ey[0] = -det * b; out->ex[2] = 0.0f;
	out->ex[1] = -det * c;	out->ey[1] =  det * a; out->ey[2] = 0.0f;
	out->ez[0] = 0.0f; out->ez[1] = 0.0f; out->ez[2] = 0.0f;
}

inline void b2clGetSymInverse33(const b2clMat33 in, b2clMat33* out)
{
	//float det = b2clDot(ex, b2clCross(ey, ez));
	float det = in.ex[0] * (in.ey[1] * in.ez[2] - in.ey[2] * in.ez[1]) 
		+ in.ex[1] * (in.ey[2] * in.ez[0] - in.ey[0] * in.ez[2]) 
		+ in.ex[2] * (in.ey[0] * in.ez[1] - in.ey[1] * in.ez[0]);

	if (det != 0.0f)
	{
		det = 1.0f / det;
	}

	float a11 = in.ex[0], a12 = in.ey[0], a13 = in.ez[0];
	float a22 = in.ey[1], a23 = in.ez[1];
	float a33 = in.ez[2];

	out->ex[0] = det * (a22 * a33 - a23 * a23);
	out->ex[1] = det * (a13 * a23 - a12 * a33);
	out->ex[2] = det * (a12 * a23 - a13 * a22);

	out->ey[0] = out->ex[1];
	out->ey[1] = det * (a11 * a33 - a13 * a13);
	out->ey[2] = det * (a13 * a12 - a11 * a23);

	out->ez[0] = out->ex[2];
	out->ez[1] = out->ey[2];
	out->ez[2] = det * (a11 * a22 - a12 * a12);
}

inline float2 b2clMat33MulV2(const b2clMat33 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float3 b2clMat33MulV3(const b2clMat33 A, const float3 v)
{
	//return v.x * A.ex + v.y * A.ey + v.z * A.ez;
	return (float3)(A.ex[0] * v.x + A.ey[0] * v.y + A.ez[0] * v.z,
		A.ex[1] * v.x + A.ey[1] * v.y + A.ez[1] * v.z,
		A.ex[2] * v.x + A.ey[2] * v.y + A.ez[2] * v.z);
}

inline void b2clMat22GetInverse(const b2clMat22 in, b2clMat22* out)
{
	float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
	float det = a * d - b * c;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	out->ex[0] =  det * d;	out->ey[0] = -det * b;
	out->ex[1] = -det * c;	out->ey[1] =  det * a;
}

inline void b2clSweepNormalize(b2clSweep* sweep)
{
	float twoPi = 2.0f * b2_pi;
	float d =  twoPi * floor(sweep->a0 / twoPi);
	sweep->a0 -= d;
	sweep->a -= d;
}

inline void b2clSweepGetTransform(b2clSweep* sweep, b2clTransform* xf, float beta)
{
	xf->p = (1.0f - beta) * sweep->c0 + beta * sweep->c;
	float angle = (1.0f - beta) * sweep->a0 + beta * sweep->a;
	xf->q.x = sin(angle);
	xf->q.y = cos(angle);

	// Shift to origin
	xf->p -= b2clMul_Rotate(xf->q, sweep->localCenter);
}

inline void b2clSweepAdvance(b2clSweep* sweep, float alpha)
{
	float beta = (alpha - sweep->alpha0) / (1.0f - sweep->alpha0);
	sweep->c0 = (1.0f - beta) * sweep->c0 + beta * sweep->c;
	sweep->a0 = (1.0f - beta) * sweep->a0 + beta * sweep->a;
	sweep->alpha0 = alpha;
}
inline void b2clBodySweepAdvance (b2clBodyDynamic* body, b2clTransform* xf, float alpha) {
	b2clSweepAdvance(&(body->m_sweep), alpha); 
	body->m_sweep.c = body->m_sweep.c0;
	body->m_sweep.a = body->m_sweep.a0;
    xf->q.x = sin (body->m_sweep.a);
	xf->q.y = cos (body->m_sweep.a); 
	xf->p = body->m_sweep.c - b2clMul_Rotate(xf->q, body->m_sweep.localCenter);
}

inline void b2clDistanceProxySet(b2clDistanceProxy* proxy, const b2clPolygonShape* shape)
{
	proxy->m_count = shape->m_vertexCount;
	proxy->m_radius = shape->m_radius;
	for (int i = 0; i < shape->m_vertexCount; ++i)
	{
		proxy->m_vertices[i] = shape->m_vertices[i];
	}
}

inline int b2clDistanceProxyGetSupport(const b2clDistanceProxy* proxy, float2 d)
{
	int bestIndex = 0;
	float bestValue = b2clDot(proxy->m_vertices[0], d);
	for (int i = 1; i < proxy->m_count; ++i)
	{
		float value = b2clDot(proxy->m_vertices[i], d);
		if (value > bestValue)
		{
			bestIndex = i;
			bestValue = value;
		}
	}
	return bestIndex;
}

inline float2 b2clDistanceProxyGetVertex(const b2clDistanceProxy* proxy, int index)
{
	return proxy->m_vertices[index];
}

// Convert a vector into a unit vector. Returns the length.
inline float b2clNormalize(float2* v)
{
	float length = sqrt(b2clDot(*v, *v));
	if (length < b2_epsilon)
	{
		return 0.0f;
	}
	float invLength = 1.0f / length;
	(*v).x *= invLength;
	(*v).y *= invLength;

	return length;
}

/*
inline float cos_wrapper(float a)
{
	//float sina = sin(a);
	//return sqrt(1-sina*sina);

	//return sin(1.5707963268-a);

	return cos(a);
}
*/

//#include <Box2D/Common/OpenCL/b2CLTypeDefOCL.h>
//#include <Box2D/Common/OpenCL/b2CLNarrowPhase.cl>
#if 0
uint FloatFlip(float fl)
{
	uint f = as_uint(fl);
	uint mask = -(int)(f >> 31) | 0x80000000;
	return f ^ mask;
}

float IFloatFlip(uint f)
{
	uint mask = ((f >> 31) - 1) | 0x80000000;
	uint fl = f ^ mask;
	return as_float(fl);
}

enum SeparationType
{
	e_points,
	e_faceA,
	e_faceB
};

typedef struct
{
	const b2clDistanceProxy* m_proxyA;
	const b2clDistanceProxy* m_proxyB;
	b2clSweep m_sweepA, m_sweepB;
	int m_type;
	float2 m_localPoint;
	float2 m_axis;
} b2clSeparationFunction;

float b2clSeparationFunctionInitialize(b2clSeparationFunction* sf, const b2clSimplexCache* cache,
	const b2clDistanceProxy* proxyA, const b2clSweep* sweepA,
	const b2clDistanceProxy* proxyB, const b2clSweep* sweepB,
	float t1)
{
	sf->m_proxyA = proxyA;
	sf->m_proxyB = proxyB;
	int count = cache->count;

	sf->m_sweepA = *sweepA;
	sf->m_sweepB = *sweepB;

	b2clTransform xfA, xfB;
	b2clSweepGetTransform(&sf->m_sweepA, &xfA, t1);
	b2clSweepGetTransform(&sf->m_sweepB, &xfB, t1);

	//printf ("cache->indexA: %d cache->indexB: %d \n ", cache->indexA[0], cache->indexA[1]);
	//printf ("cache->indexA: %d \n ", );
	if (count == 1)
	{
		sf->m_type = e_points;
		float2 localPointA = b2clDistanceProxyGetVertex(sf->m_proxyA, cache->indexA[0]);
		float2 localPointB = b2clDistanceProxyGetVertex(sf->m_proxyB, cache->indexB[0]);
		float2 pointA = b2clMul_Transform(&xfA, localPointA);
		float2 pointB = b2clMul_Transform(&xfB, localPointB);
		sf->m_axis = pointB - pointA;
		float s = b2clNormalize(&sf->m_axis);
		return s;
	}
	else if (cache->indexA[0] == cache->indexA[1])
	{
		// Two points on B and one on A.
		sf->m_type = e_faceB;
		float2 localPointB1 = b2clDistanceProxyGetVertex(proxyB, cache->indexB[0]);
		float2 localPointB2 = b2clDistanceProxyGetVertex(proxyB, cache->indexB[1]);

		sf->m_axis = b2clCross_VS(localPointB2 - localPointB1, 1.0f);
		sf->m_axis = normalize(sf->m_axis);
		float2 normal = b2clMul_Rotate(xfB.q, sf->m_axis);

		sf->m_localPoint = 0.5f * (localPointB1 + localPointB2);
		float2 pointB = b2clMul_Transform(&xfB, sf->m_localPoint);

		float2 localPointA = b2clDistanceProxyGetVertex(proxyA, cache->indexA[0]);
		float2 pointA = b2clMul_Transform(&xfA, localPointA);

		float s = b2clDot(pointA - pointB, normal);
		if (s < 0.0f)
		{
			sf->m_axis = -sf->m_axis;
			s = -s;
		}
		return s;
	}
	else
	{
		// Two points on A and one or two points on B.
		sf->m_type = e_faceA;
		float2 localPointA1 = b2clDistanceProxyGetVertex(sf->m_proxyA, cache->indexA[0]);
		float2 localPointA2 = b2clDistanceProxyGetVertex(sf->m_proxyA, cache->indexA[1]);
			
		sf->m_axis = b2clCross_VS(localPointA2 - localPointA1, 1.0f);
		sf->m_axis = normalize(sf->m_axis);
		float2 normal = b2clMul_Rotate(xfA.q, sf->m_axis);

		sf->m_localPoint = 0.5f * (localPointA1 + localPointA2);
		float2 pointA = b2clMul_Transform(&xfA, sf->m_localPoint);

		float2 localPointB = b2clDistanceProxyGetVertex(sf->m_proxyB, cache->indexB[0]);
		float2 pointB = b2clMul_Transform(&xfB, localPointB);

		float s = b2clDot(pointB - pointA, normal);
		if (s < 0.0f)
		{
			sf->m_axis = -sf->m_axis;
			s = -s;
		}
		return s;
	}
}

float b2clSeparationFunctionFindMinSeparation(b2clSeparationFunction* sf, int* indexA, int* indexB, float t, int numLoops)
{
	b2clTransform xfA, xfB;
	
	b2clSweepGetTransform(&sf->m_sweepA, &xfA, t);
	b2clSweepGetTransform(&sf->m_sweepB, &xfB, t);

	
	switch (sf->m_type)
	{
	case e_points:
		{
			float2 axisA = b2clMulT_Rotate(xfA.q,  sf->m_axis);
			float2 axisB = b2clMulT_Rotate(xfB.q, -sf->m_axis);

			*indexA = b2clDistanceProxyGetSupport(sf->m_proxyA, axisA);
			*indexB = b2clDistanceProxyGetSupport(sf->m_proxyB, axisB);

			float2 localPointA = b2clDistanceProxyGetVertex(sf->m_proxyA, *indexA);
			float2 localPointB = b2clDistanceProxyGetVertex(sf->m_proxyB, *indexB);
				
			float2 pointA = b2clMul_Transform(&xfA, localPointA);
			float2 pointB = b2clMul_Transform(&xfB, localPointB);

			float separation = b2clDot(pointB - pointA, sf->m_axis);
			return separation;
		}

	case e_faceA:
		{
		   // if (numLoops == 36) {
		//		printf ("got in numLoops == 36 \n"); 
		//	}
		 //   if (numLoops == 36) return ; 
			float2 normal = b2clMul_Rotate(xfA.q, sf->m_axis);
			float2 pointA = b2clMul_Transform(&xfA, sf->m_localPoint);

			float2 axisB = b2clMulT_Rotate(xfB.q, -normal);
				
			*indexA = -1;
			*indexB = b2clDistanceProxyGetSupport(sf->m_proxyB, axisB);

			float2 localPointB = b2clDistanceProxyGetVertex(sf->m_proxyB, *indexB);
			float2 pointB = b2clMul_Transform(&xfB, localPointB);

			float separation = b2clDot(pointB - pointA, normal);
			return separation;
		}

	case e_faceB:
		{
		    
			float2 normal = b2clMul_Rotate(xfB.q, sf->m_axis);
		//	if (numLoops == 36) {
		//	printf ("sf->m_localPoint for 36: %f \n", sf->m_localPoint.y); 
		//	}
		//	if (numLoops == 36) return ; 
			float2 pointB = b2clMul_Transform(&xfB, sf->m_localPoint);
			
			float2 axisA = b2clMulT_Rotate(xfA.q, -normal);

			*indexB = -1;
			*indexA = b2clDistanceProxyGetSupport(sf->m_proxyA, axisA);

			float2 localPointA = b2clDistanceProxyGetVertex(sf->m_proxyA, *indexA);
			float2 pointA = b2clMul_Transform(&xfA, localPointA);

			float separation = b2clDot(pointA - pointB, normal);
			return separation;
		}

	default:
		*indexA = -1;
		*indexB = -1;
		return 0.0f;
	}
}

float b2clSeparationFunctionEvaluate(b2clSeparationFunction* sf, int indexA, int indexB, float t)
{
	b2clTransform xfA, xfB;
	b2clSweepGetTransform(&sf->m_sweepA, &xfA, t);
	b2clSweepGetTransform(&sf->m_sweepB, &xfB, t);

	switch (sf->m_type)
	{
	case e_points:
		{
			float2 axisA = b2clMulT_Rotate(xfA.q,  sf->m_axis);
			float2 axisB = b2clMulT_Rotate(xfB.q, -sf->m_axis);

			float2 localPointA = b2clDistanceProxyGetVertex(sf->m_proxyA, indexA);
			float2 localPointB = b2clDistanceProxyGetVertex(sf->m_proxyB, indexB);

			float2 pointA = b2clMul_Transform(&xfA, localPointA);
			float2 pointB = b2clMul_Transform(&xfB, localPointB);
			float separation = b2clDot(pointB - pointA, sf->m_axis);

			return separation;
		}

	case e_faceA:
		{
			float2 normal = b2clMul_Rotate(xfA.q, sf->m_axis);
			float2 pointA = b2clMul_Transform(&xfA, sf->m_localPoint);

			float2 axisB = b2clMulT_Rotate(xfB.q, -normal);

			float2 localPointB = b2clDistanceProxyGetVertex(sf->m_proxyB, indexB);
			float2 pointB = b2clMul_Transform(&xfB, localPointB);

			float separation = b2clDot(pointB - pointA, normal);
			return separation;
		}

	case e_faceB:
		{
			float2 normal = b2clMul_Rotate(xfB.q, sf->m_axis);
			float2 pointB = b2clMul_Transform(&xfB, sf->m_localPoint);

			float2 axisA = b2clMulT_Rotate(xfA.q, -normal);

			float2 localPointA = b2clDistanceProxyGetVertex(sf->m_proxyA, indexA);
			float2 pointA = b2clMul_Transform(&xfA, localPointA);

			float separation = b2clDot(pointA - pointB, normal);
			return separation;
		}

	default:
		return 0.0f;
	}
}

float SimplexGetMetric(b2clSimplex* simplex)
{
	switch (simplex->m_count)
	{
	case 0:
		return 0.0;

	case 1:
		return 0.0f;

	case 2:
		return b2clDistance(simplex->m_v1.w, simplex->m_v2.w);

	case 3:
		return b2clCross_VV(simplex->m_v2.w - simplex->m_v1.w, simplex->m_v3.w - simplex->m_v1.w);

	default:
		return 0.0f;
	}
}

void SimplexReadCache(b2clSimplex* simplex, const b2clSimplexCache* cache,
					const b2clDistanceProxy* proxyA, const b2clTransform* transformA,
					const b2clDistanceProxy* proxyB, const b2clTransform* transformB)
{
		
	// Copy data from cache.
	simplex->m_count = cache->count;
	b2clSimplexVertex* vertices = &simplex->m_v1;
	for (int i = 0; i < simplex->m_count; ++i)
	{
		b2clSimplexVertex* v = vertices + i;
		v->indexA = cache->indexA[i];
		v->indexB = cache->indexB[i];
		float2 wALocal = proxyA->m_vertices[v->indexA];
		float2 wBLocal = proxyB->m_vertices[v->indexB];
		v->wA = b2clMul_Transform(transformA, wALocal);
		v->wB = b2clMul_Transform(transformB, wBLocal);
		v->w = v->wB - v->wA;
		v->a = 0.0f;
	}

	// Compute the new simplex metric, if it is substantially different than
	// old metric then flush the simplex.
	if (simplex->m_count > 1)
	{
		float metric1 = cache->metric;
		float metric2 = SimplexGetMetric(simplex);
		if (metric2 < 0.5f * metric1 || 2.0f * metric1 < metric2 || metric2 < b2_epsilon)
		{
			// Reset the simplex.
			simplex->m_count = 0;
		}
	}

	// If the cache is empty or invalid ...
	if (simplex->m_count == 0)
	{
		b2clSimplexVertex* v = vertices + 0;
		v->indexA = 0;
		v->indexB = 0;
		float2 wALocal = proxyA->m_vertices[0];
		float2 wBLocal = proxyB->m_vertices[0];
		v->wA = b2clMul_Transform(transformA, wALocal);
		v->wB = b2clMul_Transform(transformB, wBLocal);
		v->w = v->wB - v->wA;
		simplex->m_count = 1;
	}
}

void SimplexWriteCache(b2clSimplex* simplex, b2clSimplexCache* cache)
{
	cache->metric = SimplexGetMetric(simplex);
	cache->count = (short)(simplex->m_count);
	const b2clSimplexVertex* vertices = &simplex->m_v1;
	for (int i = 0; i < simplex->m_count; ++i)
	{
		cache->indexA[i] = (unsigned char)(vertices[i].indexA);
		cache->indexB[i] = (unsigned char)(vertices[i].indexB);
	}
}

float2 SimplexGetSearchDirection(b2clSimplex* simplex)
{
	switch (simplex->m_count)
	{
	case 1:
		return -simplex->m_v1.w;

	case 2:
		{
			float2 e12 = simplex->m_v2.w - simplex->m_v1.w;
			float sgn = b2clCross_VV(e12, -simplex->m_v1.w);
			if (sgn > 0.0f)
			{
				// Origin is left of e12.
				return b2clCross_SV(1.0f, e12);
			}
			else
			{
				// Origin is right of e12.
				return b2clCross_VS(e12, 1.0f);
			}
		}

	default:
		return (float2)(0.0f, 0.0f);
	}
}

float2 SimplexGetClosestPoint(b2clSimplex* simplex)
{
	switch (simplex->m_count)
	{
	case 0:
		return (float2)(0.0f, 0.0f);

	case 1:
		return simplex->m_v1.w;

	case 2:
		return simplex->m_v1.a * simplex->m_v1.w + simplex->m_v2.a * simplex->m_v2.w;

	case 3:
		return (float2)(0.0f, 0.0f);

	default:
		return (float2)(0.0f, 0.0f);
	}
}

void SimplexGetWitnessPoints(b2clSimplex* simplex, float2* pA, float2* pB)
{
	switch (simplex->m_count)
	{
	case 0:
		break;

	case 1:
		*pA = simplex->m_v1.wA;
		*pB = simplex->m_v1.wB;
		break;

	case 2:
		*pA = simplex->m_v1.a * simplex->m_v1.wA + simplex->m_v2.a * simplex->m_v2.wA;
		*pB = simplex->m_v1.a * simplex->m_v1.wB + simplex->m_v2.a * simplex->m_v2.wB;
		break;

	case 3:
		*pA = simplex->m_v1.a * simplex->m_v1.wA + simplex->m_v2.a * simplex->m_v2.wA + simplex->m_v3.a * simplex->m_v3.wA;
		*pB = *pA;
		break;

	default:
		break;
	}
}

void SimplexSolve2(b2clSimplex* simplex)
{
	float2 w1 = simplex->m_v1.w;
	float2 w2 = simplex->m_v2.w;
	float2 e12 = w2 - w1;

	// w1 region
	float d12_2 = -b2clDot(w1, e12);
	if (d12_2 <= 0.0f)
	{
		// a2 <= 0, so we clamp it to 0
		simplex->m_v1.a = 1.0f;
		simplex->m_count = 1;
		return;
	}

	// w2 region
	float d12_1 = b2clDot(w2, e12);
	if (d12_1 <= 0.0f)
	{
		// a1 <= 0, so we clamp it to 0
		simplex->m_v2.a = 1.0f;
		simplex->m_count = 1;
		simplex->m_v1 = simplex->m_v2;
		return;
	}

	// Must be in e12 region.
	float inv_d12 = 1.0f / (d12_1 + d12_2);
	simplex->m_v1.a = d12_1 * inv_d12;
	simplex->m_v2.a = d12_2 * inv_d12;
	simplex->m_count = 2;
}

void SimplexSolve3(b2clSimplex* simplex)
{
	float2 w1 = simplex->m_v1.w;
	float2 w2 = simplex->m_v2.w;
	float2 w3 = simplex->m_v3.w;

	// Edge12
	// [1      1     ][a1] = [1]
	// [w1.e12 w2.e12][a2] = [0]
	// a3 = 0
	float2 e12 = w2 - w1;
	float w1e12 = b2clDot(w1, e12);
	float w2e12 = b2clDot(w2, e12);
	float d12_1 = w2e12;
	float d12_2 = -w1e12;

	// Edge13
	// [1      1     ][a1] = [1]
	// [w1.e13 w3.e13][a3] = [0]
	// a2 = 0
	float2 e13 = w3 - w1;
	float w1e13 = b2clDot(w1, e13);
	float w3e13 = b2clDot(w3, e13);
	float d13_1 = w3e13;
	float d13_2 = -w1e13;

	// Edge23
	// [1      1     ][a2] = [1]
	// [w2.e23 w3.e23][a3] = [0]
	// a1 = 0
	float2 e23 = w3 - w2;
	float w2e23 = b2clDot(w2, e23);
	float w3e23 = b2clDot(w3, e23);
	float d23_1 = w3e23;
	float d23_2 = -w2e23;
	
	// Triangle123
	float n123 = b2clCross_VV(e12, e13);

	float d123_1 = n123 * b2clCross_VV(w2, w3);
	float d123_2 = n123 * b2clCross_VV(w3, w1);
	float d123_3 = n123 * b2clCross_VV(w1, w2);

	// w1 region
	if (d12_2 <= 0.0f && d13_2 <= 0.0f)
	{
		simplex->m_v1.a = 1.0f;
		simplex->m_count = 1;
		return;
	}

	// e12
	if (d12_1 > 0.0f && d12_2 > 0.0f && d123_3 <= 0.0f)
	{
		float inv_d12 = 1.0f / (d12_1 + d12_2);
		simplex->m_v1.a = d12_1 * inv_d12;
		simplex->m_v2.a = d12_2 * inv_d12;
		simplex->m_count = 2;
		return;
	}

	// e13
	if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f)
	{
		float inv_d13 = 1.0f / (d13_1 + d13_2);
		simplex->m_v1.a = d13_1 * inv_d13;
		simplex->m_v3.a = d13_2 * inv_d13;
		simplex->m_count = 2;
		simplex->m_v2 = simplex->m_v3;
		return;
	}

	// w2 region
	if (d12_1 <= 0.0f && d23_2 <= 0.0f)
	{
		simplex->m_v2.a = 1.0f;
		simplex->m_count = 1;
		simplex->m_v1 = simplex->m_v2;
		return;
	}

	// w3 region
	if (d13_1 <= 0.0f && d23_1 <= 0.0f)
	{
		simplex->m_v3.a = 1.0f;
		simplex->m_count = 1;
		simplex->m_v1 = simplex->m_v3;
		return;
	}

	// e23
	if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f)
	{
		float inv_d23 = 1.0f / (d23_1 + d23_2);
		simplex->m_v2.a = d23_1 * inv_d23;
		simplex->m_v3.a = d23_2 * inv_d23;
		simplex->m_count = 2;
		simplex->m_v1 = simplex->m_v3;
		return;
	}

	// Must be in triangle123
	float inv_d123 = 1.0f / (d123_1 + d123_2 + d123_3);
	simplex->m_v1.a = d123_1 * inv_d123;
	simplex->m_v2.a = d123_2 * inv_d123;
	simplex->m_v3.a = d123_3 * inv_d123;
	simplex->m_count = 3;
}

// Compute the closest points between two shapes. Supports any combination of:
// b2CircleShape, b2PolygonShape, b2EdgeShape. The simplex cache is input/output.
// On the first call set b2SimplexCache.count to zero.
void b2clShapeDistance(b2clDistanceOutput* output, b2clSimplexCache* cache, const b2clDistanceInput* input)
{

    
	const b2clDistanceProxy* proxyA = &input->proxyA;
	const b2clDistanceProxy* proxyB = &input->proxyB;

	b2clTransform transformA = input->transformA;
	b2clTransform transformB = input->transformB;

	// Initialize the simplex.
	b2clSimplex simplex;
	SimplexReadCache(&simplex, cache, proxyA, &transformA, proxyB, &transformB);

	// Get simplex vertices as an array.
	b2clSimplexVertex* vertices = &simplex.m_v1;
	const int k_maxIters = 20;

	// These store the vertices of the last simplex so that we
	// can check for duplicates and prevent cycling.
	int saveA[3], saveB[3];
	int saveCount = 0;

	float2 closestPoint = SimplexGetClosestPoint(&simplex);
	float distanceSqr1 = b2clLengthSquared(closestPoint);
	float distanceSqr2 = distanceSqr1;

	// Main iteration loop.
	int iter = 0;
	while (iter < k_maxIters)
	{
		// Copy simplex so we can identify duplicates.
		saveCount = simplex.m_count;
		for (int i = 0; i < saveCount; ++i)
		{
			saveA[i] = vertices[i].indexA;
			saveB[i] = vertices[i].indexB;
		}

		switch (simplex.m_count)
		{
		case 1:
			break;

		case 2:
			SimplexSolve2(&simplex);
			break;

		case 3:
			SimplexSolve3(&simplex);
			break;

		default:
			break;
		}

		// If we have 3 points, then the origin is in the corresponding triangle.
		if (simplex.m_count == 3)
		{
			break;
		}

		// Compute closest point.
		float2 p = SimplexGetClosestPoint(&simplex);
		distanceSqr2 = b2clLengthSquared(p);

		// Ensure progress
		if (distanceSqr2 >= distanceSqr1)
		{
			//break;
		}
		distanceSqr1 = distanceSqr2;

		// Get search direction.
		float2 d = SimplexGetSearchDirection(&simplex);

		// Ensure the search direction is numerically fit.
		if (b2clLengthSquared(d) < b2_epsilon * b2_epsilon)
		{
			// The origin is probably contained by a line segment
			// or triangle. Thus the shapes are overlapped.

			// We can't return zero here even though there may be overlap.
			// In case the simplex is a point, segment, or triangle it is difficult
			// to determine if the origin is contained in the CSO or very close to it.
			break;
		}

		// Compute a tentative new simplex vertex using support points.
		b2clSimplexVertex* vertex = vertices + simplex.m_count;
		vertex->indexA = b2clDistanceProxyGetSupport(proxyA, b2clMulT_Rotate(transformA.q, -d));
		vertex->wA = b2clMul_Transform(&transformA, (b2clDistanceProxyGetVertex(proxyA, vertex->indexA)));

		//float2 wBLocal;
		vertex->indexB = b2clDistanceProxyGetSupport(proxyB, b2clMulT_Rotate(transformB.q, d));
		vertex->wB = b2clMul_Transform(&transformB, (b2clDistanceProxyGetVertex(proxyB, vertex->indexB)));
		vertex->w = vertex->wB - vertex->wA;

		// Iteration count is equated to the number of support point calls.
		++iter;

		// Check for duplicate support points. This is the main termination criteria.
		bool duplicate = false;
		for (int i = 0; i < saveCount; ++i)
		{
			if (vertex->indexA == saveA[i] && vertex->indexB == saveB[i])
			{
				duplicate = true;
				break;
			}
		}

		// If we found a duplicate support point we must exit to avoid cycling.
		if (duplicate)
		{
			break;
		}

		// New vertex is ok and needed.
		++simplex.m_count;
	}
	
	// Prepare output.
	SimplexGetWitnessPoints(&simplex, &output->pointA, &output->pointB);
	//float dis = b2clDistance(output->pointA, output->pointB);
	output->ndistance = b2clDistance(output->pointA, output->pointB);
	output->iterations = iter;
	
	// Cache the simplex.
	SimplexWriteCache(&simplex, cache);
	
	// Apply radii if requested.
	if (input->useRadii)
	{
		float rA = proxyA->m_radius;
		float rB = proxyB->m_radius;

		if (output->ndistance > rA + rB && output->ndistance > b2_epsilon)
		{
			// Shapes are still no overlapped.
			// Move the witness points to the outer surface.
			output->ndistance -= rA + rB;
			float2 normal = normalize(output->pointB - output->pointA);
			output->pointA += rA * normal;
			output->pointB -= rB * normal;
		}
		else
		{
			// Shapes are overlapped when radii are considered.
			// Move the witness points to the middle.
			float2 p = 0.5f * (output->pointA + output->pointB);
			output->pointA = p;
			output->pointB = p;
			output->ndistance = 0.0f;
		}
	}
}

void b2clTimeOfImpact(b2clTOIOutput* output, const b2clTOIInput* input, int numLoops)
{
	output->state = e_unknown;
	output->t = input->tMax;

	b2clDistanceProxy proxyA = input->proxyA;
	b2clDistanceProxy proxyB = input->proxyB;

	b2clSweep sweepA = input->sweepA;
	b2clSweep sweepB = input->sweepB;

	// Large rotations can make the root finder fail, so we normalize the
	// sweep angles.
	b2clSweepNormalize(&sweepA);
	b2clSweepNormalize(&sweepB);

	float tMax = input->tMax;

	float totalRadius = proxyA.m_radius + proxyB.m_radius;
	float target = max(b2_linearSlop, totalRadius - 3.0f * b2_linearSlop);
	float tolerance = 0.25f * b2_linearSlop;

	float t1 = 0.0f;
	const int k_maxIterations = 20;	// TODO_ERIN b2Settings
	int iter = 0;

	// Prepare input for distance query.
	b2clSimplexCache cache;
	cache.count = 0;
	b2clDistanceInput distanceInput;
	distanceInput.proxyA = proxyA;
	distanceInput.proxyB = proxyB;
	distanceInput.useRadii = false;


	

	// The outer loop progressively attempts to compute new separating axes.
	// This loop terminates when an axis is repeated (no progress is made).
	//for(;;)
	//Warning: I can not use for(;;). Otherwise, clBuildProgram will return error! 
	for (int i = 0 ; i < 100 ; i ++ )
	//while(1)
	//for (;;)
	{
		b2clTransform xfA, xfB;
		b2clSweepGetTransform(&sweepA, &xfA, t1);
		b2clSweepGetTransform(&sweepB, &xfB, t1);

		// Get the distance between shapes. We can also use the results
		// to get a separating axis.
		distanceInput.transformA = xfA;
		distanceInput.transformB = xfB;
		b2clDistanceOutput distanceOutput;

		b2clShapeDistance(&distanceOutput, &cache, &distanceInput);

		// If the shapes are overlapped, we give up on continuous collision.
		if (distanceOutput.ndistance <= 0.0f)
		{
			// Failure!
			output->state = e_overlapped;
			output->t = 0.0f;
			break;
		}

		if (distanceOutput.ndistance < target + tolerance)
		{
			// Victory!
			output->state = e_touching;
			output->t = t1;
			break;
		}

		// Initialize the separating axis.
		b2clSeparationFunction fcn;
		b2clSeparationFunctionInitialize(&fcn, &cache, &proxyA, &sweepA, &proxyB, &sweepB, t1);

		// Compute the TOI on the separating axis. We do this by successively
		// resolving the deepest point. This loop is bounded by the number of vertices.
		bool done = false;
		float t2 = tMax;
		int pushBackIter = 0;
		
		for (;;)
		{
			// Find the deepest point at t2. Store the witness point indices.
			int indexA, indexB;
			//if (numLoops == 36 && ) return ; 
			float s2 = b2clSeparationFunctionFindMinSeparation(&fcn, &indexA, &indexB, t2, numLoops);

			// Is the final configuration separated?
			if (s2 > target + tolerance)
			{
				// Victory!
				output->state = e_separated;
				output->t = tMax;
				done = true;
				break;
			}

			// Has the separation reached tolerance?
			if (s2 > target - tolerance)
			{
				// Advance the sweeps
				t1 = t2;
				break;
			}

			// Compute the initial separation of the witness points.
			float s1 = b2clSeparationFunctionEvaluate(&fcn, indexA, indexB, t1);

			// Check for initial overlap. This might happen if the root finder
			// runs out of iterations.
			if (s1 < target - tolerance)
			{
				output->state = e_failed;
				output->t = t1;
				done = true;
				break;
			}

			// Check for touching
			if (s1 <= target + tolerance)
			{
				// Victory! t1 should hold the TOI (could be 0.0).
				output->state = e_touching;
				output->t = t1;
				done = true;
				break;
			}

			// Compute 1D root of: f(x) - target = 0
			int rootIterCount = 0;
			float a1 = t1, a2 = t2;
			for (;;)
			{
				// Use a mix of the secant rule and bisection.
				float t;
				if (rootIterCount & 1)
				{
					// Secant rule to improve convergence.
					t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);
				}
				else
				{
					// Bisection to guarantee progress.
					t = 0.5f * (a1 + a2);
				}

				float s = b2clSeparationFunctionEvaluate(&fcn, indexA, indexB, t);

				if (b2clAbs(s - target) < tolerance)
				{
					// t2 holds a tentative value for t1
					t2 = t;
					break;
				}

				// Ensure we continue to bracket the root.
				if (s > target)
				{
					a1 = t;
					s1 = s;
				}
				else
				{
					a2 = t;
					s2 = s;
				}

				++rootIterCount;

				if (rootIterCount == 50)
				{
					break;
				}
			}

			++pushBackIter;

			if (pushBackIter == b2cl_maxPolygonVertices)
			{
				break;
			}
		}

		++iter;

		if (done)
		{
			break;
		}

		if (iter == k_maxIterations)
		{
			// Root finder got stuck. Semi-victory.
			output->state = e_failed;
			output->t = t1;
			break;
		}
	}
	//printf ("output.t: %f \n", output->t); 
}

__kernel void b2clComputeTOI(const __global int4* globalIndices,
	int numContacts,
	const __global b2clBodyStatic* bodyStaticListBuffer,
	const __global b2clBodyDynamic* bodyDynamicListBuffer,
	const __global b2clPolygonShape* polyGlobal,
	__global unsigned int* contactTOIs,
	__global int* contactIndices,
	int resetAlpha0,
	__global int* toiTimesBuffer,
	int numLoops 
	)
{

 
	int i = get_global_id(0);

	if (i >= numContacts)
		return;

	float alpha = 1.0f;

	contactIndices[i] = i;
	contactTOIs[i] = FloatFlip(alpha);

	// TODO: Disabled contact checking
	/*
	// Is this contact disabled?
	if (c->IsEnabled() == false)
	{
		continue;
	}
	*/

	
	int4 currentIndices = globalIndices[i];

	b2clBodyStatic bA = bodyStaticListBuffer[currentIndices.z];
	b2clBodyStatic bB = bodyStaticListBuffer[currentIndices.w];

	b2clPolygonShape shapeA = polyGlobal[currentIndices.x];
	b2clPolygonShape shapeB = polyGlobal[currentIndices.y];

	// Is there a sensor?
	if (shapeA.m_bIsSensor || shapeB.m_bIsSensor)
		return;
   if (toiTimesBuffer[i] > 8 ) return ; 
	int typeA = bA.m_type;
	int typeB = bB.m_type;

	//printf ("Contact id: %d, TypeA: %d TypeB: %d \n", i, typeA, typeB);
	
	// Is at least one body active (awake and dynamic or kinematic)?
	if (typeA == 0 && typeB == 0) // 0 : b2_staticBody
	{
		return;
	}
	 
	bool collideA = bA.m_bIsBullet || typeA != 2; // 2 : b2_dynamicBody
	bool collideB = bB.m_bIsBullet || typeB != 2; // 2 : b2_dynamicBody

	// Are these two non-bullet dynamic bodies?
	if (collideA == false && collideB == false)
	{
		return;
	}

	b2clBodyDynamic bdA = bodyDynamicListBuffer[currentIndices.z];
	b2clBodyDynamic bdB = bodyDynamicListBuffer[currentIndices.w];

	//printf ("Contact id: %d: Index A: %d , Index B: %d \n", i , currentIndices.z , currentIndices.w); 

	if (resetAlpha0)
	{	
		bdA.m_sweep.alpha0 = 0.0f;
		bdB.m_sweep.alpha0 = 0.0f;
	}

	// Compute the TOI for this contact.
	// Put the sweeps onto the same time interval.
	float alpha0 = bdA.m_sweep.alpha0;


	if (bdA.m_sweep.alpha0 < bdB.m_sweep.alpha0)
	{
		alpha0 = bdB.m_sweep.alpha0;
		b2clSweepAdvance(&bdA.m_sweep, alpha0);
	}
	else if (bdB.m_sweep.alpha0 < bdA.m_sweep.alpha0)
	{
		alpha0 = bdA.m_sweep.alpha0;
		b2clSweepAdvance(&bdB.m_sweep, alpha0);
	}


	// Compute the time of impact in interval [0, minTOI]
	b2clTOIInput input;
	b2clDistanceProxySet(&input.proxyA, &shapeA);
	b2clDistanceProxySet(&input.proxyB, &shapeB);
	input.sweepA = bdA.m_sweep;
	input.sweepB = bdB.m_sweep;
	input.tMax = 1.0f;

	float test1 = bdA.m_sweep.c.y ;
	float test2 = bdB.m_sweep.c.y ;  
	
	//if (numLoops == 36 && i == 0 ) return ; 

	b2clTOIOutput output;
	b2clTimeOfImpact(&output, &input , numLoops) ; 				

	
	// Beta is the fraction of the remaining portion of the .

	float beta = output.t;
		//printf ("beta %f, \n",  beta); 
	if (output.state == e_touching)
	{
		alpha = min(alpha0 + (1.0f - alpha0) * beta, 1.0f);
		//printf ("MyAlpha %f \n", alpha); 
		//printf ("if alpha0 %f, \n",  alpha0); 
	}
	else
	{
		alpha = 1.0f;
	}
	//printf ("Contact id: %d: Index A: %d , alpha: %f \n", i , currentIndices.z , alpha); 
	 
	contactTOIs[i] = FloatFlip(alpha);
}





void b2clOnePairCollidePolygons(b2clManifold* manifold, const b2clPolygonShape* polyA, const b2clTransform* xfA, const b2clPolygonShape* polyB, const b2clTransform* xfB){
/*
	manifold->pointCount = 0 ;
	// Not sure if I need them yet.  
	//manifold.points[0].normalImpulse = 0;
    //manifold.points[0].tangentImpulse = 0;
    //manifold.points[1].normalImpulse = 0;
    //manifold.points[1].tangentImpulse = 0;
	float totalRadius = polyA->m_radius + polyB->m_radius; 
	int edgeA = 0 ; 
	float separationA = b2clFindMaxSeparation(&edgeA, polyA, xfA, polyB, xfB);
	if (separationA > totalRadius) return ; 
	int edgeB = 0 ; 
	float separationB = b2clFindMaxSeparation(&edgeB, polyB, xfB, polyA, xfA);
	if (separationB > totalRadius) return;

	const b2clPolygonShape* poly1;	// reference polygon
	const b2clPolygonShape* poly2;	// incident polygon
	const b2clTransform *xf1;
	const b2clTransform *xf2;
	int edge1;		// reference edge
	uint flip;
	const float k_relativeTol = 0.98f;
	const float k_absoluteTol = 0.001f;
	if (separationB > k_relativeTol * separationA + k_absoluteTol)
	{
		poly1 = polyB;
		poly2 = polyA;
		xf1 = xfB;
		xf2 = xfA;
		edge1 = edgeB;
		manifold->type = 2;
		flip = 1;
	}
	else
	{
		poly1 = polyA;
		poly2 = polyB;
		xf1 = xfA;
		xf2 = xfB;
		edge1 = edgeA;
		manifold->type = 1;
		flip = 0;
	}
    b2clClipVertex incidentEdge[2];
	b2clFindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);

	int count1 = poly1->m_vertexCount;
	const float2* vertices1 = poly1->m_vertices;

	int iv1 = edge1;
	int iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;

	float2 v11 = vertices1[iv1];
	float2 v12 = vertices1[iv2];

	float2 localTangent = v12 - v11;
	localTangent = normalize(localTangent);
	
	float2 localNormal = b2clCross_VS(localTangent, 1.0f);
	float2 planePoint = 0.5f * (v11 + v12);

	float2 tangent = b2clMul_Rotate(xf1->q, localTangent);
	float2 normal = b2clCross_VS(tangent, 1.0f);
	
	v11 = b2clMul_Transform(xf1, v11);
	v12 = b2clMul_Transform(xf1, v12);

	// Face offset.
	float frontOffset = dot(normal, v11);
    
	float sideOffset1 = -dot(tangent, v11) + totalRadius;
	float sideOffset2 = dot(tangent, v12) + totalRadius;

	// Clip incident edge against extruded edge1 side edges.
	b2clClipVertex clipPoints1[2];
	b2clClipVertex clipPoints2[2];
	int np;

	// Clip to box side 1
	np = b2clClipSegmentToLine(clipPoints1, incidentEdge, -tangent, sideOffset1, iv1);

	if (np < 2)
	{
		return;
	}

	// Clip to negative box side 1
	np = b2clClipSegmentToLine(clipPoints2, clipPoints1,  tangent, sideOffset2, iv2);

	if (np < 2)
	{
		return;
	}
    manifold->localNormal = localNormal;
	manifold->localPoint = planePoint;
	int pointCount = 0;
	for (int k = 0; k < b2cl_maxManifoldPoints; ++k)
	{
		float separation = dot(normal, clipPoints2[k].v) - frontOffset;

		if (separation <= totalRadius)
		{
			b2clManifoldPoint* cp = manifold->points + pointCount;
			cp->localPoint = b2clMulT_Transform(xf2, clipPoints2[k].v);
			cp->id = clipPoints2[k].id;
			if (flip)
			{
				// Swap features
				b2clContactFeature cf = cp->id.cf;
				cp->id.cf.indexA = cf.indexB;
				cp->id.cf.indexB = cf.indexA;
				cp->id.cf.typeA = cf.typeB;
				cp->id.cf.typeB = cf.typeA;
			}
			++pointCount;
		}
	}

	manifold->pointCount = pointCount;
*/
}

void ContactEvaluate (b2clManifold* manifold, const b2clPolygonShape* polyA, const b2clTransform* xfA, const b2clPolygonShape* polyB, const b2clTransform* xfB) {

    int contactType = manifold->type ; 
	switch (contactType)
			{
			case 0: // circle-circle
				//collideKernel = collideCirclesKernel;
				break;
			case 1: // circle-polygon
				//collideKernel = collidePolygonAndCircleKernel;
				break;
			case 2: // polygon-polygon
				b2clOnePairCollidePolygons ( manifold, polyA, xfA, polyB, xfB ) ; 
				break;
			case 3: // edge-circle
				//collideKernel = collideEdgeAndCircleKernel;
				break;
			case 4: // edge-polygon
				//collideKernel = collideEdgeAndPolygonKernel;
				break;
			default:
				//printf("Error! OpenCL: ContactEvaluate!\n");
				return; 
			}
}
void ContactUpdate  (b2clManifold* manifold, const b2clPolygonShape* polyA, const b2clTransform* xfA, const b2clPolygonShape* polyB, const b2clTransform* xfB) {
	b2clManifold oldManifold = *manifold; 
	// Re-enable this contact ; Do I need to do this?
	bool touching = false ; 
	// wasTouching = (m_flags & e_touchingFlag) == e_touchingFlag; Do I need this? 
	//Not implemented for sensor
	//bool sensorA = m_fixtureA->IsSensor(); bool sensorB = m_fixtureB->IsSensor(); bool sensor = sensorA || sensorB; 
	//if (sensor){}
	ContactEvaluate ( manifold, polyA, xfA, polyB, xfB ) ;  
	touching = manifold->pointCount > 0 ; 
	for (int i = 0; i < manifold->pointCount; ++i)
	{
		b2clManifoldPoint* mp2 = manifold->points + i;
		mp2->normalImpulse = 0.0f;
		mp2->tangentImpulse = 0.0f;
		b2clContactID id2 = mp2->id;

		for (int j = 0; j < oldManifold.pointCount; ++j)
		{
			b2clManifoldPoint* mp1 = oldManifold.points + j;
			if (mp1->id.key == id2.key)
			{
					mp2->normalImpulse = mp1->normalImpulse;
					mp2->tangentImpulse = mp1->tangentImpulse;
					break;
			}
		}
	}




}
void b2clBodySynchronizeTransform ( b2clTransform* xf, b2clSweep* sweep ) {
	float sina, cosa;
	sina = sincos(sweep->a, &cosa);
	xf->q.x = sina;
	xf->q.y = cosa;
	//xf->q.x = sin (sweep->a);
	//xf->q.y = cos (sweep->a);
	//xf->q.y = cos_wrapper(sweep->a);
	xf->p = sweep->c - b2clMul_Rotate (xf->q, sweep->localCenter); 
}


//void b2clAdvanceOneBody 

__kernel void b2clAdvanceBodiesKernel(const __global int4* globalIndices,
	int numContacts,
	const __global b2clBodyStatic* bodyStaticListBuffer,
	__global b2clBodyDynamic* bodyDynamicListBuffer,
	const __global b2clPolygonShape* polyGlobal,
	__global b2clTransform* xfGlobal,
	__global b2clManifold* manifoldList ,  
	__global unsigned int* contactTOIs,
	__global int* contactIndices){

	int idxContact = get_global_id(0);

	// Currently, we only handle one contact.
	if (idxContact >= 1) return;
	idxContact = contactIndices[idxContact] ; 
	float minAlpha = IFloatFlip (contactTOIs[idxContact]);  
	int4 currentIndices = globalIndices[idxContact] ; 
	b2clBodyDynamic bA = bodyDynamicListBuffer[currentIndices.z];
	b2clBodyDynamic bB = bodyDynamicListBuffer[currentIndices.w];
	b2clPolygonShape polyA = polyGlobal[currentIndices.z];
	b2clPolygonShape polyB = polyGlobal[currentIndices.w]; 
	b2clManifold manifold = manifoldList[idxContact]; 

	//b2clSweep backupSweepA = bA.m_sweep;
	//b2clSweep backupSweepB = bB.m_sweep; 
	b2clTransform xfA, xfB ; 

	b2clBodySweepAdvance (&bA, &xfA, minAlpha);
	b2clBodySweepAdvance (&bB, &xfB, minAlpha);

	ContactUpdate ( &manifold, &polyA, &xfA, &polyB, &xfB ) ; 
	if (manifold.pointCount == 0) {
		//bA.m_sweep = backupSweepA ; 
		//bB.m_sweep = backupSweepB ; 
		//b2clBodySynchronizeTransform ( &xfA, &bA.m_sweep) ; 
		//b2clBodySynchronizeTransform ( &xfB, &bB.m_sweep);
		return ; 
	}

    bodyDynamicListBuffer[currentIndices.z] = bA;
	bodyDynamicListBuffer[currentIndices.w] = bB;
	xfGlobal[currentIndices.z] = xfA ; 
	xfGlobal[currentIndices.w] = xfB; 

	//minContact->Update(m_contactManager.m_contactListener);

}




__kernel void b2clMarkConnectedContactsKernel(const __global int4* globalIndices,
	int numContacts,
	const __global b2clBodyStatic* bodyStaticListBuffer,
	__global b2clBodyDynamic* bodyDynamicListBuffer,
	const __global b2clPolygonShape* polyGlobal,
	__global b2clTransform* xfGlobal,
	__global b2clManifold* manifoldList ,  
	__global unsigned int* contactTOIs,
	__global int* contactIndices,
	__global int* isConnectedBuffer, 
	int seedIndex ) {

	int idxContact = get_global_id(0) ; 
	if (idxContact >= numContacts) return ; 
	idxContact = contactIndices[idxContact]; 
	seedIndex = contactIndices[seedIndex]; 
	if (idxContact == seedIndex) {isConnectedBuffer[idxContact] = 1 ; return ; }
	int4 seedIndices = globalIndices[seedIndex];
	int4 currentIndices = globalIndices[idxContact]; 

	bool findA = false; bool findB = false ; int idxShare, idxOther ; 
	if (seedIndices.z == currentIndices.z || seedIndices.z == currentIndices.w) findA = true ;  
	if (seedIndices.w == currentIndices.w || seedIndices.w == currentIndices.w) findB = true ;
	if (findA == false && findB == false ) return ; 
    if (findA == true) {idxShare = seedIndices.z; idxOther = (seedIndices.z == currentIndices.z)? currentIndices.w: currentIndices.z;}
	else {idxShare = seedIndices.w; idxOther = (seedIndices.w == currentIndices.w)? currentIndices.z:currentIndices.w; }

	// Has this contact already been added to the island? 
	if (isConnectedBuffer[idxContact] == 1) return ; 

	


	b2clBodyStatic staticShare = bodyStaticListBuffer[idxShare];
	b2clBodyStatic staticOther = bodyStaticListBuffer[idxOther];

	// Only add static, kinematic, or bullet bodies.
	// b2_dynamicbody = 2
	if (staticOther.m_type == 2 && staticShare.m_bIsBullet == 0 && staticOther.m_bIsBullet == 0 ) return ; 
	//To do: skip Sensors: 

	// Tentatively advance the body to the TOI.
	float minAlpha = IFloatFlip (contactTOIs[seedIndex]);  
	b2clBodyDynamic bA = bodyDynamicListBuffer[currentIndices.z];
	b2clBodyDynamic bB = bodyDynamicListBuffer[currentIndices.w];
	b2clTransform xfA = xfGlobal[currentIndices.z];
	b2clTransform xfB = xfGlobal[currentIndices.w];
	b2clPolygonShape polyA = polyGlobal[currentIndices.z];
	b2clPolygonShape polyB = polyGlobal[currentIndices.w]; 
	b2clManifold manifold = manifoldList[idxContact];
	
    b2clBodyDynamic* bodyOther; b2clTransform* xfOther;
	if (idxOther == currentIndices.z) {bodyOther = &bA; xfOther = &xfA;}
	else {bodyOther =&bB; xfOther = &xfB;}; 
	
	b2clBodySweepAdvance (bodyOther, xfOther, minAlpha);
	ContactUpdate ( &manifold, &polyA, &xfA, &polyB, &xfB ) ; 
	if (manifold.pointCount == 0) {
		return ; 
	}
    bodyDynamicListBuffer[idxOther] = *bodyOther;
	xfGlobal[idxOther] = *xfOther ;  
	isConnectedBuffer[idxContact] = 1 ; 


}
#endif


__kernel void b2clsyncMovedBodyKernel (
 const __global float* movedBodyBuffer, 
int numBodies, 
__global b2clTransform* xfGlobal,
__global clb2Velocity* velocityBuffer,
__global clb2Position* positionBuffer
)
{
  int idxThread = get_global_id (0);
  if (idxThread >= numBodies) return; 

  b2clTransform xf;
  clb2Velocity vel;
  clb2Position pos;

  int offset = idxThread* 11 ; 
  //float testFloat = movedBodyBuffer[offset+0]; 
    
  int idxBody = (int) movedBodyBuffer[offset+0]; 
  vel.vx = movedBodyBuffer[offset+1];
  vel.vy = movedBodyBuffer[offset+2];
  vel.w = movedBodyBuffer[offset+3];
  pos.cx = movedBodyBuffer[offset+4];
  pos.cy = movedBodyBuffer[offset+5];
  pos.a  = movedBodyBuffer[offset+6];
  xf.p.x = movedBodyBuffer[offset+7];
  xf.p.y = movedBodyBuffer[offset+8];
  xf.q.x = movedBodyBuffer[offset+9];
  xf.q.y = movedBodyBuffer[offset+10];
 

  xfGlobal[idxBody] = xf ; 
  velocityBuffer[idxBody] = vel ; 
  positionBuffer[idxBody] = pos ; 

}
/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/

/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/


#pragma OPENCL EXTENSION cl_amd_printf : enable

/// The maximum number of contact points between two convex shapes. Do
/// not change this value.
#define b2cl_maxManifoldPoints  2

/// The maximum number of vertices on a convex polygon. You cannot increase
/// this too much because b2BlockAllocator has a maximum object size.
#define b2cl_maxPolygonVertices 8

/// A velocity threshold for elastic collisions. Any collision with a relative linear
/// velocity below this threshold will be treated as inelastic.
//#define b2cl_velocityThreshold        0.01f
#define b2cl_velocityThreshold      1.0f

/// This is used to fatten AABBs in the dynamic tree. This is used to predict
/// the future position based on the current displacement.
/// This is a dimensionless multiplier.
#define b2cl_aabbMultiplier     2.0f

#define b2_maxFloat FLT_MAX
#define b2_epsilon FLT_EPSILON
#define b2_pi 3.14159265359f
#define b2_maxTranslation 2.0f
#define b2_maxRotation 0.5f*b2_pi
#define b2_baumgarte 0.2f
#define b2_linearSlop 0.005f
#define b2_angularSlop          (2.0f / 180.0f * b2_pi)
#define b2_polygonRadius        (2.0f * b2_linearSlop)
#define b2_maxLinearCorrection 0.2f
#define b2_maxAngularCorrection     (8.0f / 180.0f * b2_pi)

#ifndef MAXFLOAT
#define MAXFLOAT      3.402823466e+38F
#endif


/// The features that intersect to form the contact point
/// This must be 4 bytes or less.
typedef struct b2clContactFeature
{
    uchar indexA;       ///< Feature index on shapeA
    uchar indexB;       ///< Feature index on shapeB
    uchar typeA;        ///< The feature type on shapeA
    uchar typeB;        ///< The feature type on shapeB
} b2clContactFeature;

/// Contact ids to facilitate warm starting.
typedef union b2clContactID
{
    b2clContactFeature cf;
    uint key;                   ///< Used to quickly compare contact ids.
} b2clContactID;

/// A manifold point is a contact point belonging to a contact
/// manifold. It holds details related to the geometry and dynamics
/// of the contact points.
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleB
/// -e_faceA: the local center of cirlceB or the clip point of polygonB
/// -e_faceB: the clip point of polygonA
/// This structure is stored across time steps, so we keep it small.
/// Note: the impulses are used for internal caching and may not
/// provide reliable contact forces, especially for high speed collisions.
typedef struct b2clManifoldPoint
{
    float2 localPoint;      ///< usage depends on manifold type
    float normalImpulse;    ///< the non-penetration impulse
    float tangentImpulse;   ///< the friction impulse
    b2clContactID id;           ///< uniquely identifies a contact point between two shapes
    float dummy; // for alignment
} b2clManifoldPoint;

/// A manifold for two touching convex shapes.
/// Box2D supports multiple types of contact:
/// - clip point versus plane with radius
/// - point versus point with radius (circles)
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleA
/// -e_faceA: the center of faceA
/// -e_faceB: the center of faceB
/// Similarly the local normal usage:
/// -e_circles: not used
/// -e_faceA: the normal on polygonA
/// -e_faceB: the normal on polygonB
/// We store contacts in this way so that position correction can
/// account for movement, which is critical for continuous physics.
/// All contact scenarios must be expressed in one of these types.
/// This structure is stored across time steps, so we keep it small.
typedef struct b2clManifold
{
    float2 localNormal;                             ///< not use for Type::e_points
    float2 localPoint;                              ///< usage depends on manifold type
    b2clManifoldPoint points[b2cl_maxManifoldPoints];   ///< the points of contact
    int type;
    int pointCount;                             ///< the number of manifold points
    //float2 test;
} b2clManifold;

typedef struct b2clFilter
{
    unsigned short categoryBits;
    unsigned short maskBits;
    short groupIndex;
    short dummy;
} b2clFilter;

/// A convex polygon. It is assumed that the interior of the polygon is to
/// the left of each edge.
/// Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.
/// In most cases you should not need many vertices for a convex polygon.
//////////////
/// We reuse b2clPolygonShape for b2clCircleShape
/// We may have to change this later
typedef struct b2clPolygonShape
{
    float2 m_centroid;
    float2 m_vertices[b2cl_maxPolygonVertices];
    float2 m_normals[b2cl_maxPolygonVertices];
    int m_type;
    float m_radius;
    int m_vertexCount;
    int m_bIsSensor;
    b2clFilter m_filter;
} b2clPolygonShape;

/// A transform contains translation and rotation. It is used to represent
/// the position and orientation of rigid frames.
typedef struct b2clTransform
{
    float2 p;
    float2 q;
} b2clTransform;

/// This describes the motion of a body/shape for TOI computation.
/// Shapes are defined with respect to the body origin, which may
/// no coincide with the center of mass. However, to support dynamics
/// we must interpolate the center of mass position.
typedef struct b2clSweep
{
    float2 localCenter; ///< local center of mass position
    float2 c0, c;       ///< center world positions
    float a0, a;        ///< world angles

    /// Fraction of the current time step in the range [0,1]
    /// c0 and a0 are the positions at alpha0.
    float alpha0;
    float dummy;
}  b2clSweep;

/// Used for computing contact manifolds.
typedef struct b2clClipVertex
{
    float2 v;
    b2clContactID id;
} b2clClipVertex;

typedef struct clb2Velocity
{
    float vx;
    float vy;
    float w;
}clb2Velocity;

typedef struct clb2Position
{
    float cx;
    float cy;
    float a;
}clb2Position;

typedef struct clb2Contact
{
    int color;
    int indexA;
    int indexB;
    float friction;
    float2 normal;
    float invMassA;
    float invIA;
    float invMassB;
    float invIB;
}clb2Contact;

typedef struct clb2Impulse
{
    float normalImpulse1;
    float tangentImpulse1;
    
    float normalImpulse2;
    float tangentImpulse2;
}clb2Impulse;

typedef struct clb2Points
{
    float2 rA1;
    float2 rB1;
    float normalMass1;
    float tangentMass1;
    
    float2 rA2;
    float2 rB2;
    float normalMass2;
    float tangentMass2;
    
    float velocityBias1;
    float velocityBias2;
}clb2Points;

typedef struct b2clFixtureStatic
{
    float m_friction;
    float m_restitution;
    int m_last_uid;
    int dummy; 
} b2clFixtureStatic;

#define MAX_CONNECTED_BODY_INDICES 8
typedef struct b2clBodyStatic
{
    float2 m_localCenter;   ///< local center of mass position
    float /*m_mass,*/ m_invMass;
    // Rotational inertia about the center of mass.
    float /*m_I,*/ m_invI;
    float m_linearDamping;
    float m_angularDamping;
    float m_gravityScale;
    float m_type;
    int m_connectedBodyIndices[MAX_CONNECTED_BODY_INDICES];
    int m_bIsBullet;
    int dummy;
} b2clBodyStatic;

typedef struct b2clBodyDynamic
{
    b2clSweep m_sweep;      // the swept motion for CCD

    float2 m_linearVelocity;
    float2 m_force;
    float m_angularVelocity;
    float m_torque;
    int m_last_uid ;
    int dummy ; 
} b2clBodyDynamic;

// Extract useful information of manifolds for position constraint solver
typedef struct clb2Manifold
{
    float2 localNormal;
    float2 localPoint;
    float2 localPoints1;
    float2 localPoints2;
    int pointCount;
    int type;
    float radiusA;
    float radiusB;
    float2 localCenterA;
    float2 localCenterB;
}clb2Manifold;

typedef struct{
    int type;
    int pointCount;
    float localPointX;
    float localPointY;
    float localNormalX;
    float localNormalY; 
    float point0X;
    float point0Y;
    float point1X;
    float point1Y; 
}clb2SDManifold;

typedef struct{
    int fixtureAIndex;
    int fixtureBIndex;
    int bodyAIndex ; 
    int bodyBIndex ; 
}clb2SDContact;

typedef struct{
    int bodyIndex ;
    float posX;
    float posY ; 
    float posAngle;
    float xfX;
    float xfY;
    float xfS;
    float xfC;
    float alpha;
    float velocityX;
    float velocityY;
    float velocityAngular; 
}clb2SDBody;

typedef struct clb2PositionSolverManifold
{
    float2 normal;
    float2 point;
    float separation;
}clb2PositionSolverManifold;

typedef struct clb2Rotation
{
    float s;
    float c;
}clb2Rotation;

typedef struct clb2Transform
{
    clb2Rotation rotation;
    float2 translation;
}clb2Transform;

typedef struct b2clMat22
{
    float ex[2];
    float ey[2];
}b2clMat22;

typedef struct b2clMat33
{
    float ex[3];
    float ey[3];
    float ez[3];
}b2clMat33;

enum b2clLimitState
{
    e_inactiveLimit,
    e_atLowerLimit,
    e_atUpperLimit,
    e_equalLimits
};

enum b2JointType
{
    e_unknownJoint,
    e_revoluteJoint,
    e_prismaticJoint,
    e_distanceJoint,
    e_pulleyJoint,
    e_mouseJoint,
    e_gearJoint,
    e_wheelJoint,
    e_weldJoint,
    e_frictionJoint,
    e_ropeJoint
};

typedef struct b2clDistanceJointDatastruct
{
    float frequencyHz;
    float dampingRatio;
    float bias;

    float localAnchorA[2];
    float localAnchorB[2];
    float gamma;
    float nlength;

    float u[2];
    float rA[2];
    float rB[2];
    float localCenterA[2];
    float localCenterB[2];
    float invMassA;
    float invMassB;
    float invIA;
    float invIB;
    float mass;
} b2clDistanceJointData;

typedef struct b2clRevoluteJointData
{
    float localAnchorA[2];
    float localAnchorB[2];

    int enableMotor;
    float maxMotorTorque;
    float motorSpeed;

    int enableLimit;
    float referenceAngle;
    float lowerAngle;
    float upperAngle;

    // Solver temp
    float rA[2];
    float rB[2];
    float localCenterA[2];
    float localCenterB[2];
    float invMassA;
    float invMassB;
    float invIA;
    float invIB;
    b2clMat33 mass;         // effective mass for point-to-point constraint.
    float motorMass;    // effective mass for motor/limit angular constraint.
    int limitState;
} b2clRevoluteJointData;

typedef struct b2clPrismaticJointData
{
    // Solver shared
    float localAnchorA[2];
    float localAnchorB[2];
    float localXAxisA[2];
    float localYAxisA[2];
    float referenceAngle;
    float lowerTranslation;
    float upperTranslation;
    float maxMotorForce;
    float motorSpeed;
    int enableLimit;
    int enableMotor;
    int limitState;

    // Solver temp
    float localCenterA[2];
    float localCenterB[2];
    float invMassA;
    float invMassB;
    float invIA;
    float invIB;
    float axis[2], perp[2];
    float s1, s2;
    float a1, a2;
    b2clMat33 K;
    float motorMass;
} b2clPrismaticJointData;

typedef struct b2clGearJointData
{
    int joint1;
    int joint2;
    int typeA;
    int typeB;

    float localAnchorA[2];
    float localAnchorB[2];
    float localAnchorC[2];
    float localAnchorD[2];

    float localAxisC[2];
    float localAxisD[2];

    float referenceAngleA;
    float referenceAngleB;

    float gearConstant;
    float ratio;

    // Solver temp
    float lcA[2], lcB[2], lcC[2], lcD[2];
    float mA, mB, mC, mD;
    float iA, iB, iC, iD;
    float JvAC[2], JvBD[2];
    float JwA, JwB, JwC, JwD;
    float mass;
} b2clGearJointData;

typedef struct b2clPulleyJointData
{
    float groundAnchorA[2];
    float groundAnchorB[2];
    float lengthA;
    float lengthB;
    float localAnchorA[2];
    float localAnchorB[2]; 
    float pulleyConstant; 
    float ratio; 
    float uA[2]; 
    float uB[2]; 
    float rA[2]; 
    float rB[2]; 
    float localCenterA[2];
    float localCenterB[2]; 
    float invMassA; 
    float invMassB; 
    float invIA; 
    float invIB;
    float mass; 
}b2clPulleyJointData; 

typedef struct b2clRopeJointData
{   
    float localAnchorA[2];
    float localAnchorB[2]; 
    float maxLength; 
    float nlength;
    float u[2]; 
    float rA[2]; 
    float rB[2]; 
    float localCenterA[2];
    float localCenterB[2]; 
    float invMassA; 
    float invMassB; 
    float invIA; 
    float invIB;
    float mass; 
    int limitState; 
} b2clRopeJointData; 

typedef struct b2clWheelJointData
{
    float frequencyHz;
    float dampingRatio;

    // Solver shared
    float localAnchorA[2];
    float localAnchorB[2];
    float localXAxisA[2];
    float localYAxisA[2];

    float maxMotorTorque;
    float motorSpeed;
    int enableMotor;

    // Solver temp
    float localCenterA[2];
    float localCenterB[2];
    float invMassA;
    float invMassB;
    float invIA;
    float invIB;

    float ax[2], ay[2];
    float sAx, sBx;
    float sAy, sBy;

    float mass;
    float motorMass;
    float springMass;

    float bias;
    float gamma;
} b2clWheelJointData;

typedef struct b2clWeldJointData
{
    float frequencyHz;
    float dampingRatio;
    float bias;

    // Solver shared
    float localAnchorA[2];
    float localAnchorB[2];
    float referenceAngle;
    float gamma;

    // Solver temp
    float rA[2];
    float rB[2];
    float localCenterA[2];
    float localCenterB[2];
    float invMassA;
    float invMassB;
    float invIA;
    float invIB;
    b2clMat33 mass;
} b2clWeldJointData;

typedef struct b2clMouseJointData
{
    float localAnchorB[2];
    float targetA[2];
    float frequencyHz;
    float dampingRatio;
    float beta;
    
    // Solver shared
    float maxForce;
    float gamma;

    // Solver temp
    float rB[2];
    float localCenterB[2];
    float invMassB;
    float invIB;
    b2clMat22 mass;
    float C[2];
} b2clMouseJointData;

typedef struct b2clFrictionJointData
{
    float localAnchorA[2];
    float localAnchorB[2];

    float maxForce; 
    float maxTorque; 

    // Solver temp
    float rA[2];
    float rB[2];
    float localCenterA[2];
    float localCenterB[2];
    float invMassA;
    float invMassB;
    float invIA;
    float invIB;
    b2clMat22 linearMass;
    float angularMass; 
} b2clFrictionJointData;

typedef struct clJoint
{
    int index;

    // impulse : 4 floats
    union a1{
        struct x1{
            float impulse[3];
        }x;
        struct y1{
            float scalarImpulse;
            float springImpulse;
        }y;
        struct z1{
            float linearImpulse[2];
            float angularImpulse;
        }z;
    }a;
    float motorImpulse;

    int color;
    int type;
    int collideConnected;

    int indexA, indexB, indexC, indexD;

    union b1{
        b2clDistanceJointData distanceJointData;
        b2clRevoluteJointData revoluteJointData;
        b2clPrismaticJointData prismaticJointData;
        b2clGearJointData gearJointData;
        b2clPulleyJointData pulleyJointData;
        b2clRopeJointData ropeJointData;
        b2clWheelJointData wheelJointData;
        b2clWeldJointData weldJointData;
        b2clMouseJointData mouseJointData;
        b2clFrictionJointData frictionJointData;
    }b;
} b2clJoint;

typedef struct
{
    int index;
    float nimpulse[4];
} b2clJointImpulseNode;

typedef struct
{
    int isCollide;
    float normal[2];
    float fraction;
    unsigned int shapeIndex;
} b2clRayCastOutput;

typedef struct
{
    float2 m_buffer[2];
    float2 m_vertices[b2cl_maxPolygonVertices];
    int m_count;
    float m_radius;
} b2clDistanceProxy;

typedef struct 
{
    float metric;       ///< length or area
    short count;
    unsigned char indexA[3];    ///< vertices on shape A
    unsigned char indexB[3];    ///< vertices on shape B
} b2clSimplexCache;

/// Input for b2Distance.
/// You have to option to use the shape radii
/// in the computation. Even 
typedef struct 
{
    b2clDistanceProxy proxyA;
    b2clDistanceProxy proxyB;
    b2clTransform transformA;
    b2clTransform transformB;
    bool useRadii;
} b2clDistanceInput;

/// Output for b2Distance.
typedef struct
{
    float2 pointA;      ///< closest point on shapeA
    float2 pointB;      ///< closest point on shapeB
    float ndistance;
    int iterations; ///< number of GJK iterations used
} b2clDistanceOutput;

typedef struct
{
    b2clDistanceProxy proxyA;
    b2clDistanceProxy proxyB;
    b2clSweep sweepA;
    b2clSweep sweepB;
    float tMax;     // defines sweep interval [0, tMax]
    float dummy;
} b2clTOIInput;

enum b2clTOIOutputState
{
    e_unknown,
    e_failed,
    e_overlapped,
    e_touching,
    e_separated
};

typedef struct
{
    int state;
    float t;
} b2clTOIOutput;

typedef struct
{
    float2 wA;      // support point in proxyA
    float2 wB;      // support point in proxyB
    float2 w;       // wB - wA
    float a;        // barycentric coordinate for closest point
    int indexA; // wA index
    int indexB; // wB index
} b2clSimplexVertex;

typedef struct 
{
    b2clSimplexVertex m_v1, m_v2, m_v3;
    int m_count;
} b2clSimplex;

//typedef struct{
//float v[30];
//} testData; 

//==============================================================================================
// Math functions
//==============================================================================================

/// Multiply two rotations: q * r
inline float2 b2clMul_TwoRotation(const float2 q, const float2 r)
{
    // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
    // [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]
    // s = qs * rc + qc * rs
    // c = qc * rc - qs * rs
    float2 qr;
    qr.x = q.x * r.y + q.y * r.x;
    qr.y = q.y * r.y - q.x * r.x;
    return qr;
}

/// Transpose multiply two rotations: qT * r
inline float2 b2clMulT_TwoRotation(const float2 q, const float2 r)
{
    // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
    // [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]
    // s = qc * rs - qs * rc
    // c = qc * rc + qs * rs
    float2 qr;
    qr.x = q.y * r.x - q.x * r.y;
    qr.y = q.y * r.y + q.x * r.x;
    return qr;
}

/// Rotate a vector
inline float2 b2clMul_Rotate(const float2 q, const float2 v)
{
    float2 result;
    result.x = q.y * v.x - q.x * v.y;
    result.y = q.x * v.x + q.y * v.y;

    return result;
}

/// Inverse rotate a vector
inline float2 b2clMulT_Rotate(const float2 q, const float2 v)
{
    float2 result;
    result.x = q.y * v.x + q.x * v.y;
    result.y = -q.x * v.x + q.y * v.y;

    return result;
}

/// Transform a vector
inline float2 b2clMul_Transform(const b2clTransform *T, const float2 v)
{
    float2 result;
    result.x = (T->q.y * v.x - T->q.x * v.y) + T->p.x;
    result.y = (T->q.x * v.x + T->q.y * v.y) + T->p.y;

    return result;
}

/// Invert transform a vector
inline float2 b2clMulT_Transform(const b2clTransform *T, const float2 v)
{
    float px = v.x - T->p.x;
    float py = v.y - T->p.y;
    float2 result;
    result.x = (T->q.y * px + T->q.x * py);
    result.y = (-T->q.x * px + T->q.y * py);

    return result;
}

// v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
//    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
inline b2clTransform b2clMul_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
    b2clTransform C;
    C.q = b2clMul_TwoRotation(A->q, B->q);
    C.p = b2clMul_TwoRotation(A->q, B->p) + A->p;
    return C;
}

// v2 = A.q' * (B.q * v1 + B.p - A.p)
//    = A.q' * B.q * v1 + A.q' * (B.p - A.p)
inline b2clTransform b2clMulT_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
    b2clTransform C;
    C.q = b2clMulT_TwoRotation(A->q, B->q);
    C.p = b2clMulT_TwoRotation(A->q, B->p - A->p);
    return C;
}

/// Perform the dot product on two vectors.
inline float b2clDot(const float2 a, const float2 b)
{
    return a.x * b.x + a.y * b.y;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float b2clCross_VV(const float2 a, const float2 b)
{
    return a.x * b.y - a.y * b.x;
}

/// Perform the cross product on a vector and a scalar. In 2D this produces
/// a vector.
inline float2 b2clCross_VS(const float2 a, float s)
{
    return (float2)(s * a.y, -s *a.x);
}

/// Perform the cross product on a scalar and a vector. In 2D this produces
/// a vector.
inline float2 b2clCross_SV(float s, const float2 a)
{
    return (float2)(-s * a.y, s * a.x);
}

inline float b2clClamp(float a, float low, float high)
{
    return max(low, min(a, high));
}

inline float2 b2clMin(const float2 a, const float2 b)
{
    return (float2)(min(a.x, b.x), min(a.y, b.y));
}

inline float2 b2clMax(const float2 a, const float2 b)
{
    return (float2)(max(a.x, b.x), max(a.y, b.y));
}

inline float b2clDistanceSquared(const float2 a, const float2 b)
{
    float2 c = a - b;
    return b2clDot(c, c);
}

inline float b2clDistance(const float2 a, const float2 b)
{
    float2 c = a - b;
    return sqrt(b2clDot(c, c));
}

inline float b2clLengthSquared(const float2 v)
{
    return b2clDot(v, v);
}

inline float b2clAbs(float a)
{
    return a > 0.0f ? a : -a;
}

/// Perform the dot product on two vectors.
inline float b2clDot3(const float3 a, const float3 b)
{
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float3 b2clCross3_VV(const float3 a, const float3 b)
{
    return (float3)(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float3 b2clMat33Solve(const b2clMat33 mat, const float3 b)
{
    float3 ex = (float3)(mat.ex[0], mat.ex[1], mat.ex[2]);
    float3 ey = (float3)(mat.ey[0], mat.ey[1], mat.ey[2]);
    float3 ez = (float3)(mat.ez[0], mat.ez[1], mat.ez[2]);

    float det = b2clDot3(ex, b2clCross3_VV(ey, ez));

    if (det != 0.0f)
    {
        det = 1.0f / det;
    }
    float3 x;
    x.x = det * b2clDot3(b, b2clCross3_VV(ey, ez));
    x.y = det * b2clDot3(ex, b2clCross3_VV(b, ez));
    x.z = det * b2clDot3(ex, b2clCross3_VV(ey, b));
    return x;
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float2 b2clMat33Solve22(const b2clMat33 mat, const float2 b)
{
    float2 ex = (float2)(mat.ex[0], mat.ex[1]);
    float2 ey = (float2)(mat.ey[0], mat.ey[1]);

    float det = ex.x * ey.y - ey.x * ex.y;
    if (det != 0.0f)
    {
        det = 1.0f / det;
    }
    float2 x;
    x.x = det * (ey.y * b.x - ey.x * b.y);
    x.y = det * (ex.x * b.y - ex.y * b.x);
    return x;
}

inline float2 b2clMat22Solve(const b2clMat22 mat, const float2 b)
{
    float2 ex = (float2)(mat.ex[0], mat.ex[1]);
    float2 ey = (float2)(mat.ey[0], mat.ey[1]);

    float det = ex.x * ey.y - ey.x * ex.y;
    if (det != 0.0f)
    {
        det = 1.0f / det;
    }
    float2 x;
    x.x = det * (ey.y * b.x - ey.x * b.y);
    x.y = det * (ex.x * b.y - ex.y * b.x);
    return x;
}

inline float2 b2clMat33Mul22(const b2clMat33 A, const float2 v)
{
    return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float2 b2clMat22Mul(const b2clMat22 A, const float2 v)
{
    return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline void b2clGetInverse22(const b2clMat33 in, b2clMat33* out)
{
    float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
    float det = a * d - b * c;
    if (det != 0.0f)
    {
        det = 1.0f / det;
    }

    out->ex[0] =  det * d;  out->ey[0] = -det * b; out->ex[2] = 0.0f;
    out->ex[1] = -det * c;  out->ey[1] =  det * a; out->ey[2] = 0.0f;
    out->ez[0] = 0.0f; out->ez[1] = 0.0f; out->ez[2] = 0.0f;
}

inline void b2clGetSymInverse33(const b2clMat33 in, b2clMat33* out)
{
    //float det = b2clDot(ex, b2clCross(ey, ez));
    float det = in.ex[0] * (in.ey[1] * in.ez[2] - in.ey[2] * in.ez[1]) 
        + in.ex[1] * (in.ey[2] * in.ez[0] - in.ey[0] * in.ez[2]) 
        + in.ex[2] * (in.ey[0] * in.ez[1] - in.ey[1] * in.ez[0]);

    if (det != 0.0f)
    {
        det = 1.0f / det;
    }

    float a11 = in.ex[0], a12 = in.ey[0], a13 = in.ez[0];
    float a22 = in.ey[1], a23 = in.ez[1];
    float a33 = in.ez[2];

    out->ex[0] = det * (a22 * a33 - a23 * a23);
    out->ex[1] = det * (a13 * a23 - a12 * a33);
    out->ex[2] = det * (a12 * a23 - a13 * a22);

    out->ey[0] = out->ex[1];
    out->ey[1] = det * (a11 * a33 - a13 * a13);
    out->ey[2] = det * (a13 * a12 - a11 * a23);

    out->ez[0] = out->ex[2];
    out->ez[1] = out->ey[2];
    out->ez[2] = det * (a11 * a22 - a12 * a12);
}

inline float2 b2clMat33MulV2(const b2clMat33 A, const float2 v)
{
    return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float3 b2clMat33MulV3(const b2clMat33 A, const float3 v)
{
    //return v.x * A.ex + v.y * A.ey + v.z * A.ez;
    return (float3)(A.ex[0] * v.x + A.ey[0] * v.y + A.ez[0] * v.z,
        A.ex[1] * v.x + A.ey[1] * v.y + A.ez[1] * v.z,
        A.ex[2] * v.x + A.ey[2] * v.y + A.ez[2] * v.z);
}

inline void b2clMat22GetInverse(const b2clMat22 in, b2clMat22* out)
{
    float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
    float det = a * d - b * c;
    if (det != 0.0f)
    {
        det = 1.0f / det;
    }
    out->ex[0] =  det * d;  out->ey[0] = -det * b;
    out->ex[1] = -det * c;  out->ey[1] =  det * a;
}

inline void b2clSweepNormalize(b2clSweep* sweep)
{
    float twoPi = 2.0f * b2_pi;
    float d =  twoPi * floor(sweep->a0 / twoPi);
    sweep->a0 -= d;
    sweep->a -= d;
}

inline void b2clSweepGetTransform(b2clSweep* sweep, b2clTransform* xf, float beta)
{
    xf->p = (1.0f - beta) * sweep->c0 + beta * sweep->c;
    float angle = (1.0f - beta) * sweep->a0 + beta * sweep->a;
    xf->q.x = sin(angle);
    xf->q.y = cos(angle);

    // Shift to origin
    xf->p -= b2clMul_Rotate(xf->q, sweep->localCenter);
}

inline void b2clSweepAdvance(b2clSweep* sweep, float alpha)
{
    float beta = (alpha - sweep->alpha0) / (1.0f - sweep->alpha0);
    sweep->c0 = (1.0f - beta) * sweep->c0 + beta * sweep->c;
    sweep->a0 = (1.0f - beta) * sweep->a0 + beta * sweep->a;
    sweep->alpha0 = alpha;
}
inline void b2clBodySweepAdvance (b2clBodyDynamic* body, b2clTransform* xf, float alpha) {
    b2clSweepAdvance(&(body->m_sweep), alpha); 
    body->m_sweep.c = body->m_sweep.c0;
    body->m_sweep.a = body->m_sweep.a0;
    xf->q.x = sin (body->m_sweep.a);
    xf->q.y = cos (body->m_sweep.a); 
    xf->p = body->m_sweep.c - b2clMul_Rotate(xf->q, body->m_sweep.localCenter);
}

inline void b2clDistanceProxySet(b2clDistanceProxy* proxy, const b2clPolygonShape* shape)
{
    proxy->m_count = shape->m_vertexCount;
    proxy->m_radius = shape->m_radius;
    for (int i = 0; i < shape->m_vertexCount; ++i)
    {
        proxy->m_vertices[i] = shape->m_vertices[i];
    }
}

inline int b2clDistanceProxyGetSupport(const b2clDistanceProxy* proxy, float2 d)
{
    int bestIndex = 0;
    float bestValue = b2clDot(proxy->m_vertices[0], d);
    for (int i = 1; i < proxy->m_count; ++i)
    {
        float value = b2clDot(proxy->m_vertices[i], d);
        if (value > bestValue)
        {
            bestIndex = i;
            bestValue = value;
        }
    }
    return bestIndex;
}

inline float2 b2clDistanceProxyGetVertex(const b2clDistanceProxy* proxy, int index)
{
    return proxy->m_vertices[index];
}

// Convert a vector into a unit vector. Returns the length.
inline float b2clNormalize(float2* v)
{
    float length = sqrt(b2clDot(*v, *v));
    if (length < b2_epsilon)
    {
        return 0.0f;
    }
    float invLength = 1.0f / length;
    (*v).x *= invLength;
    (*v).y *= invLength;

    return length;
}

/*
inline float cos_wrapper(float a)
{
    //float sina = sin(a);
    //return sqrt(1-sina*sina);

    //return sin(1.5707963268-a);

    return cos(a);
}
*/

//#include <Box2D/Common/OpenCL/b2CLTypeDefOCL.h>

__kernel void SolveVelocityConstraint(
                                 __global clb2Velocity* velocities,
                                 __global clb2Contact* contacts,
                                 __global clb2Impulse* impulses,
                                 __global clb2Points* points,
                                 const unsigned int offset,
                                 const unsigned int length)
{
    unsigned int contactIndex = get_global_id(0)+offset;

    if(contactIndex>=offset+length) return;

    clb2Contact thisContact = contacts[contactIndex];
    clb2Impulse thisImpulse = impulses[contactIndex];
    clb2Points thisPoints = points[contactIndex];
    clb2Velocity thisVelA = velocities[thisContact.indexA];
    clb2Velocity thisVelB = velocities[thisContact.indexB];
    
    // Calculate the tangent impulse for the first contact point
    float2 dv;
    dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB1.y-thisVelA.vx+thisVelA.w * thisPoints.rA1.y;
    dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB1.x-thisVelA.vy-thisVelA.w * thisPoints.rA1.x;
    
    float vp = dv.x*thisContact.normal.y-dv.y*thisContact.normal.x;
    float lambda = thisPoints.tangentMass1 * (-vp);
    
    float maxFriction = thisContact.friction * thisImpulse.normalImpulse1;
    float newImpulse=clamp(thisImpulse.tangentImpulse1+lambda,-maxFriction,maxFriction);
    lambda=newImpulse-thisImpulse.tangentImpulse1;
    thisImpulse.tangentImpulse1=newImpulse;
    
    float2 P; 
    P.x = lambda*thisContact.normal.y;
    P.y = -lambda*thisContact.normal.x;
    
    thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
    thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 
    thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA1.x * P.y - thisPoints.rA1.y * P.x); 
    
    thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
    thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
    thisVelB.w= thisVelB.w+thisContact.invIB * (thisPoints.rB1.x * P.y - thisPoints.rB1.y * P.x);
    
    // Calculate the tangent impulse for the second contact point if there is the second contact point
    if(thisPoints.normalMass2>=0){
        
        dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB2.y-thisVelA.vx+thisVelA.w * thisPoints.rA2.y;
        dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB2.x-thisVelA.vy-thisVelA.w * thisPoints.rA2.x;
        
        vp = dv.x*thisContact.normal.y-dv.y*thisContact.normal.x;
        lambda = thisPoints.tangentMass2 * (-vp);
        
        maxFriction = thisContact.friction * thisImpulse.normalImpulse2;
        newImpulse=clamp(thisImpulse.tangentImpulse2+lambda,-maxFriction,maxFriction);
        lambda=newImpulse-thisImpulse.tangentImpulse2;
        thisImpulse.tangentImpulse2=newImpulse;
        
        P.x = lambda*thisContact.normal.y;
        P.y = -lambda*thisContact.normal.x;
        
        thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
        thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 
        thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA2.x * P.y - thisPoints.rA2.y * P.x); 
        
        thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
        thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
        thisVelB.w= thisVelB.w+thisContact.invIB * (thisPoints.rB2.x * P.y - thisPoints.rB2.y * P.x);
    }
    
    // Calculate the normal impulse for the first contact point
    dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB1.y-thisVelA.vx+thisVelA.w * thisPoints.rA1.y;
    dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB1.x-thisVelA.vy-thisVelA.w * thisPoints.rA1.x;
    
    vp = dv.x*thisContact.normal.x+dv.y*thisContact.normal.y;
    lambda = -thisPoints.normalMass1 * (vp-thisPoints.velocityBias1);
    
    newImpulse=fmax(thisImpulse.normalImpulse1+lambda,0);
    lambda=newImpulse-thisImpulse.normalImpulse1;
    thisImpulse.normalImpulse1=newImpulse;
    
    P.x = lambda*thisContact.normal.x;
    P.y = lambda*thisContact.normal.y;
    
    thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
    thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 
    thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA1.x * P.y - thisPoints.rA1.y * P.x); 
    
    thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
    thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
    thisVelB.w= thisVelB.w+thisContact.invIB * (thisPoints.rB1.x * P.y - thisPoints.rB1.y * P.x);
    
    // Calculate the normal impulse for the second contact point if there is the second contact point
    if(thisPoints.normalMass2>=0){
        
        dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB2.y-thisVelA.vx+thisVelA.w * thisPoints.rA2.y;
        dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB2.x-thisVelA.vy-thisVelA.w * thisPoints.rA2.x;
        
        vp = dv.x*thisContact.normal.x+dv.y*thisContact.normal.y;
        lambda = -thisPoints.normalMass2 * (vp-thisPoints.velocityBias2);
    
        newImpulse=fmax(thisImpulse.normalImpulse2+lambda,0);
        lambda=newImpulse-thisImpulse.normalImpulse2;
        thisImpulse.normalImpulse2=newImpulse;
        
        P.x = lambda*thisContact.normal.x;
        P.y = lambda*thisContact.normal.y;
        
        thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
        thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 
        thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA2.x * P.y - thisPoints.rA2.y * P.x); 
        
        thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
        thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
        thisVelB.w = thisVelB.w+thisContact.invIB * (thisPoints.rB2.x * P.y - thisPoints.rB2.y * P.x);
    }
    
    // Copy the results back to the buffers
    impulses[contactIndex] = thisImpulse;
    velocities[thisContact.indexA] = thisVelA;
    velocities[thisContact.indexB] = thisVelB;
}



/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/


/*
*
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2014, Samsung Electronics Co. Ltd.*/


#pragma OPENCL EXTENSION cl_amd_printf : enable

/// The maximum number of contact points between two convex shapes. Do
/// not change this value.
#define b2cl_maxManifoldPoints	2

/// The maximum number of vertices on a convex polygon. You cannot increase
/// this too much because b2BlockAllocator has a maximum object size.
#define b2cl_maxPolygonVertices	8

/// A velocity threshold for elastic collisions. Any collision with a relative linear
/// velocity below this threshold will be treated as inelastic.
//#define b2cl_velocityThreshold		0.01f
#define b2cl_velocityThreshold		1.0f

/// This is used to fatten AABBs in the dynamic tree. This is used to predict
/// the future position based on the current displacement.
/// This is a dimensionless multiplier.
#define b2cl_aabbMultiplier		2.0f

#define	b2_maxFloat	FLT_MAX
#define	b2_epsilon FLT_EPSILON
#define b2_pi 3.14159265359f
#define b2_maxTranslation 2.0f
#define b2_maxRotation 0.5f*b2_pi
#define b2_baumgarte 0.2f
#define b2_linearSlop 0.005f
#define b2_angularSlop			(2.0f / 180.0f * b2_pi)
#define b2_polygonRadius		(2.0f * b2_linearSlop)
#define b2_maxLinearCorrection 0.2f
#define b2_maxAngularCorrection		(8.0f / 180.0f * b2_pi)

#ifndef MAXFLOAT
#define MAXFLOAT      3.402823466e+38F
#endif


/// The features that intersect to form the contact point
/// This must be 4 bytes or less.
typedef struct b2clContactFeature
{
	uchar indexA;		///< Feature index on shapeA
	uchar indexB;		///< Feature index on shapeB
	uchar typeA;		///< The feature type on shapeA
	uchar typeB;		///< The feature type on shapeB
} b2clContactFeature;

/// Contact ids to facilitate warm starting.
typedef union b2clContactID
{
	b2clContactFeature cf;
	uint key;					///< Used to quickly compare contact ids.
} b2clContactID;

/// A manifold point is a contact point belonging to a contact
/// manifold. It holds details related to the geometry and dynamics
/// of the contact points.
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleB
/// -e_faceA: the local center of cirlceB or the clip point of polygonB
/// -e_faceB: the clip point of polygonA
/// This structure is stored across time steps, so we keep it small.
/// Note: the impulses are used for internal caching and may not
/// provide reliable contact forces, especially for high speed collisions.
typedef struct b2clManifoldPoint
{
	float2 localPoint;		///< usage depends on manifold type
	float normalImpulse;	///< the non-penetration impulse
	float tangentImpulse;	///< the friction impulse
	b2clContactID id;			///< uniquely identifies a contact point between two shapes
	float dummy; // for alignment
} b2clManifoldPoint;

/// A manifold for two touching convex shapes.
/// Box2D supports multiple types of contact:
/// - clip point versus plane with radius
/// - point versus point with radius (circles)
/// The local point usage depends on the manifold type:
/// -e_circles: the local center of circleA
/// -e_faceA: the center of faceA
/// -e_faceB: the center of faceB
/// Similarly the local normal usage:
/// -e_circles: not used
/// -e_faceA: the normal on polygonA
/// -e_faceB: the normal on polygonB
/// We store contacts in this way so that position correction can
/// account for movement, which is critical for continuous physics.
/// All contact scenarios must be expressed in one of these types.
/// This structure is stored across time steps, so we keep it small.
typedef struct b2clManifold
{
	float2 localNormal;								///< not use for Type::e_points
	float2 localPoint;								///< usage depends on manifold type
	b2clManifoldPoint points[b2cl_maxManifoldPoints];	///< the points of contact
	int type;
	int pointCount;								///< the number of manifold points
	//float2 test;
} b2clManifold;

typedef struct b2clFilter
{
	unsigned short categoryBits;
	unsigned short maskBits;
	short groupIndex;
	short dummy;
} b2clFilter;

/// A convex polygon. It is assumed that the interior of the polygon is to
/// the left of each edge.
/// Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.
/// In most cases you should not need many vertices for a convex polygon.
//////////////
/// We reuse b2clPolygonShape for b2clCircleShape
/// We may have to change this later
typedef struct b2clPolygonShape
{
	float2 m_centroid;
	float2 m_vertices[b2cl_maxPolygonVertices];
	float2 m_normals[b2cl_maxPolygonVertices];
	int m_type;
	float m_radius;
	int m_vertexCount;
	int m_bIsSensor;
	b2clFilter m_filter;
} b2clPolygonShape;

/// A transform contains translation and rotation. It is used to represent
/// the position and orientation of rigid frames.
typedef struct b2clTransform
{
	float2 p;
	float2 q;
} b2clTransform;

/// This describes the motion of a body/shape for TOI computation.
/// Shapes are defined with respect to the body origin, which may
/// no coincide with the center of mass. However, to support dynamics
/// we must interpolate the center of mass position.
typedef struct b2clSweep
{
	float2 localCenter;	///< local center of mass position
	float2 c0, c;		///< center world positions
	float a0, a;		///< world angles

	/// Fraction of the current time step in the range [0,1]
	/// c0 and a0 are the positions at alpha0.
	float alpha0;
	float dummy;
}  b2clSweep;

/// Used for computing contact manifolds.
typedef struct b2clClipVertex
{
	float2 v;
	b2clContactID id;
} b2clClipVertex;

typedef struct clb2Velocity
{
    float vx;
    float vy;
    float w;
}clb2Velocity;

typedef struct clb2Position
{
    float cx;
    float cy;
    float a;
}clb2Position;

typedef struct clb2Contact
{
    int color;
    int indexA;
    int indexB;
    float friction;
    float2 normal;
    float invMassA;
    float invIA;
    float invMassB;
    float invIB;
}clb2Contact;

typedef struct clb2Impulse
{
    float normalImpulse1;
    float tangentImpulse1;
    
    float normalImpulse2;
    float tangentImpulse2;
}clb2Impulse;

typedef struct clb2Points
{
    float2 rA1;
    float2 rB1;
    float normalMass1;
    float tangentMass1;
    
    float2 rA2;
    float2 rB2;
    float normalMass2;
    float tangentMass2;
    
    float velocityBias1;
    float velocityBias2;
}clb2Points;

typedef struct b2clFixtureStatic
{
	float m_friction;
	float m_restitution;
	int m_last_uid;
	int dummy; 
} b2clFixtureStatic;

#define MAX_CONNECTED_BODY_INDICES 8
typedef struct b2clBodyStatic
{
	float2 m_localCenter;	///< local center of mass position
	float /*m_mass,*/ m_invMass;
	// Rotational inertia about the center of mass.
	float /*m_I,*/ m_invI;
	float m_linearDamping;
	float m_angularDamping;
	float m_gravityScale;
	float m_type;
	int m_connectedBodyIndices[MAX_CONNECTED_BODY_INDICES];
	int m_bIsBullet;
	int dummy;
} b2clBodyStatic;

typedef struct b2clBodyDynamic
{
	b2clSweep m_sweep;		// the swept motion for CCD

	float2 m_linearVelocity;
	float2 m_force;
	float m_angularVelocity;
	float m_torque;
	int m_last_uid ;
	int dummy ; 
} b2clBodyDynamic;

// Extract useful information of manifolds for position constraint solver
typedef struct clb2Manifold
{
    float2 localNormal;
    float2 localPoint;
    float2 localPoints1;
    float2 localPoints2;
    int pointCount;
    int type;
    float radiusA;
    float radiusB;
    float2 localCenterA;
    float2 localCenterB;
}clb2Manifold;

typedef struct{
    int type;
	int pointCount;
	float localPointX;
	float localPointY;
	float localNormalX;
	float localNormalY; 
	float point0X;
	float point0Y;
	float point1X;
	float point1Y; 
}clb2SDManifold;

typedef struct{
	int fixtureAIndex;
	int fixtureBIndex;
	int bodyAIndex ; 
	int bodyBIndex ; 
}clb2SDContact;

typedef struct{
	int bodyIndex ;
	float posX;
	float posY ; 
	float posAngle;
	float xfX;
	float xfY;
	float xfS;
	float xfC;
	float alpha;
	float velocityX;
	float velocityY;
	float velocityAngular; 
}clb2SDBody;

typedef struct clb2PositionSolverManifold
{
    float2 normal;
    float2 point;
    float separation;
}clb2PositionSolverManifold;

typedef struct clb2Rotation
{
    float s;
    float c;
}clb2Rotation;

typedef struct clb2Transform
{
    clb2Rotation rotation;
    float2 translation;
}clb2Transform;

typedef struct b2clMat22
{
	float ex[2];
	float ey[2];
}b2clMat22;

typedef struct b2clMat33
{
	float ex[3];
	float ey[3];
	float ez[3];
}b2clMat33;

enum b2clLimitState
{
	e_inactiveLimit,
	e_atLowerLimit,
	e_atUpperLimit,
	e_equalLimits
};

enum b2JointType
{
	e_unknownJoint,
	e_revoluteJoint,
	e_prismaticJoint,
	e_distanceJoint,
	e_pulleyJoint,
	e_mouseJoint,
	e_gearJoint,
	e_wheelJoint,
    e_weldJoint,
	e_frictionJoint,
	e_ropeJoint
};

typedef struct b2clDistanceJointDatastruct
{
	float frequencyHz;
	float dampingRatio;
	float bias;

	float localAnchorA[2];
	float localAnchorB[2];
	float gamma;
	float nlength;

	float u[2];
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	float mass;
} b2clDistanceJointData;

typedef struct b2clRevoluteJointData
{
	float localAnchorA[2];
	float localAnchorB[2];

	int enableMotor;
	float maxMotorTorque;
	float motorSpeed;

	int enableLimit;
	float referenceAngle;
	float lowerAngle;
	float upperAngle;

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat33 mass;			// effective mass for point-to-point constraint.
	float motorMass;	// effective mass for motor/limit angular constraint.
	int limitState;
} b2clRevoluteJointData;

typedef struct b2clPrismaticJointData
{
	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float localXAxisA[2];
	float localYAxisA[2];
	float referenceAngle;
	float lowerTranslation;
	float upperTranslation;
	float maxMotorForce;
	float motorSpeed;
	int enableLimit;
	int enableMotor;
	int limitState;

	// Solver temp
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	float axis[2], perp[2];
	float s1, s2;
	float a1, a2;
	b2clMat33 K;
	float motorMass;
} b2clPrismaticJointData;

typedef struct b2clGearJointData
{
	int joint1;
	int joint2;
	int typeA;
	int typeB;

	float localAnchorA[2];
	float localAnchorB[2];
	float localAnchorC[2];
	float localAnchorD[2];

	float localAxisC[2];
	float localAxisD[2];

	float referenceAngleA;
	float referenceAngleB;

	float gearConstant;
	float ratio;

	// Solver temp
	float lcA[2], lcB[2], lcC[2], lcD[2];
	float mA, mB, mC, mD;
	float iA, iB, iC, iD;
	float JvAC[2], JvBD[2];
	float JwA, JwB, JwC, JwD;
	float mass;
} b2clGearJointData;

typedef struct b2clPulleyJointData
{
	float groundAnchorA[2];
	float groundAnchorB[2];
	float lengthA;
	float lengthB;
	float localAnchorA[2];
	float localAnchorB[2]; 
	float pulleyConstant; 
	float ratio; 
	float uA[2]; 
	float uB[2]; 
	float rA[2]; 
	float rB[2]; 
	float localCenterA[2];
	float localCenterB[2]; 
	float invMassA; 
	float invMassB; 
	float invIA; 
	float invIB;
	float mass; 
}b2clPulleyJointData; 

typedef struct b2clRopeJointData
{	
	float localAnchorA[2];
	float localAnchorB[2]; 
	float maxLength; 
	float nlength;
	float u[2]; 
	float rA[2]; 
	float rB[2]; 
	float localCenterA[2];
	float localCenterB[2]; 
	float invMassA; 
	float invMassB; 
	float invIA; 
	float invIB;
	float mass; 
	int limitState; 
} b2clRopeJointData; 

typedef struct b2clWheelJointData
{
	float frequencyHz;
	float dampingRatio;

	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float localXAxisA[2];
	float localYAxisA[2];

	float maxMotorTorque;
	float motorSpeed;
	int enableMotor;

	// Solver temp
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;

	float ax[2], ay[2];
	float sAx, sBx;
	float sAy, sBy;

	float mass;
	float motorMass;
	float springMass;

	float bias;
	float gamma;
} b2clWheelJointData;

typedef struct b2clWeldJointData
{
	float frequencyHz;
	float dampingRatio;
	float bias;

	// Solver shared
	float localAnchorA[2];
	float localAnchorB[2];
	float referenceAngle;
	float gamma;

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat33 mass;
} b2clWeldJointData;

typedef struct b2clMouseJointData
{
	float localAnchorB[2];
	float targetA[2];
	float frequencyHz;
	float dampingRatio;
	float beta;
	
	// Solver shared
	float maxForce;
	float gamma;

	// Solver temp
	float rB[2];
	float localCenterB[2];
	float invMassB;
	float invIB;
	b2clMat22 mass;
	float C[2];
} b2clMouseJointData;

typedef struct b2clFrictionJointData
{
	float localAnchorA[2];
	float localAnchorB[2];

	float maxForce; 
	float maxTorque; 

	// Solver temp
	float rA[2];
	float rB[2];
	float localCenterA[2];
	float localCenterB[2];
	float invMassA;
	float invMassB;
	float invIA;
	float invIB;
	b2clMat22 linearMass;
	float angularMass; 
} b2clFrictionJointData;

typedef struct clJoint
{
	int index;

	// impulse : 4 floats
	union a1{
		struct x1{
			float impulse[3];
		}x;
		struct y1{
			float scalarImpulse;
			float springImpulse;
		}y;
		struct z1{
			float linearImpulse[2];
			float angularImpulse;
		}z;
	}a;
	float motorImpulse;

	int color;
	int type;
	int collideConnected;

	int indexA, indexB, indexC, indexD;

	union b1{
		b2clDistanceJointData distanceJointData;
		b2clRevoluteJointData revoluteJointData;
		b2clPrismaticJointData prismaticJointData;
		b2clGearJointData gearJointData;
		b2clPulleyJointData pulleyJointData;
		b2clRopeJointData ropeJointData;
		b2clWheelJointData wheelJointData;
		b2clWeldJointData weldJointData;
		b2clMouseJointData mouseJointData;
		b2clFrictionJointData frictionJointData;
	}b;
} b2clJoint;

typedef struct
{
	int index;
    float nimpulse[4];
} b2clJointImpulseNode;

typedef struct
{
	int isCollide;
	float normal[2];
	float fraction;
	unsigned int shapeIndex;
} b2clRayCastOutput;

typedef struct
{
	float2 m_buffer[2];
	float2 m_vertices[b2cl_maxPolygonVertices];
	int m_count;
	float m_radius;
} b2clDistanceProxy;

typedef struct 
{
	float metric;		///< length or area
	short count;
	unsigned char indexA[3];	///< vertices on shape A
	unsigned char indexB[3];	///< vertices on shape B
} b2clSimplexCache;

/// Input for b2Distance.
/// You have to option to use the shape radii
/// in the computation. Even 
typedef struct 
{
	b2clDistanceProxy proxyA;
	b2clDistanceProxy proxyB;
	b2clTransform transformA;
	b2clTransform transformB;
	bool useRadii;
} b2clDistanceInput;

/// Output for b2Distance.
typedef struct
{
	float2 pointA;		///< closest point on shapeA
	float2 pointB;		///< closest point on shapeB
	float ndistance;
	int iterations;	///< number of GJK iterations used
} b2clDistanceOutput;

typedef struct
{
	b2clDistanceProxy proxyA;
	b2clDistanceProxy proxyB;
	b2clSweep sweepA;
	b2clSweep sweepB;
	float tMax;		// defines sweep interval [0, tMax]
	float dummy;
} b2clTOIInput;

enum b2clTOIOutputState
{
	e_unknown,
	e_failed,
	e_overlapped,
	e_touching,
	e_separated
};

typedef struct
{
	int state;
	float t;
} b2clTOIOutput;

typedef struct
{
	float2 wA;		// support point in proxyA
	float2 wB;		// support point in proxyB
	float2 w;		// wB - wA
	float a;		// barycentric coordinate for closest point
	int indexA;	// wA index
	int indexB;	// wB index
} b2clSimplexVertex;

typedef struct 
{
	b2clSimplexVertex m_v1, m_v2, m_v3;
	int m_count;
} b2clSimplex;

//typedef struct{
//float v[30];
//} testData; 

//==============================================================================================
// Math functions
//==============================================================================================

/// Multiply two rotations: q * r
inline float2 b2clMul_TwoRotation(const float2 q, const float2 r)
{
	// [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
	// [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]
	// s = qs * rc + qc * rs
	// c = qc * rc - qs * rs
	float2 qr;
	qr.x = q.x * r.y + q.y * r.x;
	qr.y = q.y * r.y - q.x * r.x;
	return qr;
}

/// Transpose multiply two rotations: qT * r
inline float2 b2clMulT_TwoRotation(const float2 q, const float2 r)
{
	// [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
	// [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]
	// s = qc * rs - qs * rc
	// c = qc * rc + qs * rs
	float2 qr;
	qr.x = q.y * r.x - q.x * r.y;
	qr.y = q.y * r.y + q.x * r.x;
	return qr;
}

/// Rotate a vector
inline float2 b2clMul_Rotate(const float2 q, const float2 v)
{
	float2 result;
	result.x = q.y * v.x - q.x * v.y;
	result.y = q.x * v.x + q.y * v.y;

	return result;
}

/// Inverse rotate a vector
inline float2 b2clMulT_Rotate(const float2 q, const float2 v)
{
	float2 result;
	result.x = q.y * v.x + q.x * v.y;
	result.y = -q.x * v.x + q.y * v.y;

	return result;
}

/// Transform a vector
inline float2 b2clMul_Transform(const b2clTransform *T, const float2 v)
{
	float2 result;
	result.x = (T->q.y * v.x - T->q.x * v.y) + T->p.x;
	result.y = (T->q.x * v.x + T->q.y * v.y) + T->p.y;

	return result;
}

/// Invert transform a vector
inline float2 b2clMulT_Transform(const b2clTransform *T, const float2 v)
{
	float px = v.x - T->p.x;
	float py = v.y - T->p.y;
	float2 result;
	result.x = (T->q.y * px + T->q.x * py);
	result.y = (-T->q.x * px + T->q.y * py);

	return result;
}

// v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
//    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
inline b2clTransform b2clMul_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
	b2clTransform C;
	C.q = b2clMul_TwoRotation(A->q, B->q);
	C.p = b2clMul_TwoRotation(A->q, B->p) + A->p;
	return C;
}

// v2 = A.q' * (B.q * v1 + B.p - A.p)
//    = A.q' * B.q * v1 + A.q' * (B.p - A.p)
inline b2clTransform b2clMulT_TwoTransform(const b2clTransform *A, const b2clTransform *B)
{
	b2clTransform C;
	C.q = b2clMulT_TwoRotation(A->q, B->q);
	C.p = b2clMulT_TwoRotation(A->q, B->p - A->p);
	return C;
}

/// Perform the dot product on two vectors.
inline float b2clDot(const float2 a, const float2 b)
{
	return a.x * b.x + a.y * b.y;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float b2clCross_VV(const float2 a, const float2 b)
{
	return a.x * b.y - a.y * b.x;
}

/// Perform the cross product on a vector and a scalar. In 2D this produces
/// a vector.
inline float2 b2clCross_VS(const float2 a, float s)
{
	return (float2)(s * a.y, -s *a.x);
}

/// Perform the cross product on a scalar and a vector. In 2D this produces
/// a vector.
inline float2 b2clCross_SV(float s, const float2 a)
{
	return (float2)(-s * a.y, s * a.x);
}

inline float b2clClamp(float a, float low, float high)
{
	return max(low, min(a, high));
}

inline float2 b2clMin(const float2 a, const float2 b)
{
	return (float2)(min(a.x, b.x), min(a.y, b.y));
}

inline float2 b2clMax(const float2 a, const float2 b)
{
	return (float2)(max(a.x, b.x), max(a.y, b.y));
}

inline float b2clDistanceSquared(const float2 a, const float2 b)
{
	float2 c = a - b;
	return b2clDot(c, c);
}

inline float b2clDistance(const float2 a, const float2 b)
{
	float2 c = a - b;
	return sqrt(b2clDot(c, c));
}

inline float b2clLengthSquared(const float2 v)
{
	return b2clDot(v, v);
}

inline float b2clAbs(float a)
{
	return a > 0.0f ? a : -a;
}

/// Perform the dot product on two vectors.
inline float b2clDot3(const float3 a, const float3 b)
{
	return a.x * b.x + a.y * b.y + a.z * b.z;
}

/// Perform the cross product on two vectors. In 2D this produces a scalar.
inline float3 b2clCross3_VV(const float3 a, const float3 b)
{
	return (float3)(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float3 b2clMat33Solve(const b2clMat33 mat, const float3 b)
{
	float3 ex = (float3)(mat.ex[0], mat.ex[1], mat.ex[2]);
	float3 ey = (float3)(mat.ey[0], mat.ey[1], mat.ey[2]);
	float3 ez = (float3)(mat.ez[0], mat.ez[1], mat.ez[2]);

	float det = b2clDot3(ex, b2clCross3_VV(ey, ez));

	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float3 x;
	x.x = det * b2clDot3(b, b2clCross3_VV(ey, ez));
	x.y = det * b2clDot3(ex, b2clCross3_VV(b, ez));
	x.z = det * b2clDot3(ex, b2clCross3_VV(ey, b));
	return x;
}

/// Solve A * x = b, where b is a column vector. This is more efficient
/// than computing the inverse in one-shot cases.
inline float2 b2clMat33Solve22(const b2clMat33 mat, const float2 b)
{
	float2 ex = (float2)(mat.ex[0], mat.ex[1]);
	float2 ey = (float2)(mat.ey[0], mat.ey[1]);

	float det = ex.x * ey.y - ey.x * ex.y;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float2 x;
	x.x = det * (ey.y * b.x - ey.x * b.y);
	x.y = det * (ex.x * b.y - ex.y * b.x);
	return x;
}

inline float2 b2clMat22Solve(const b2clMat22 mat, const float2 b)
{
	float2 ex = (float2)(mat.ex[0], mat.ex[1]);
	float2 ey = (float2)(mat.ey[0], mat.ey[1]);

	float det = ex.x * ey.y - ey.x * ex.y;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	float2 x;
	x.x = det * (ey.y * b.x - ey.x * b.y);
	x.y = det * (ex.x * b.y - ex.y * b.x);
	return x;
}

inline float2 b2clMat33Mul22(const b2clMat33 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float2 b2clMat22Mul(const b2clMat22 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline void b2clGetInverse22(const b2clMat33 in, b2clMat33* out)
{
	float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
	float det = a * d - b * c;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}

	out->ex[0] =  det * d;	out->ey[0] = -det * b; out->ex[2] = 0.0f;
	out->ex[1] = -det * c;	out->ey[1] =  det * a; out->ey[2] = 0.0f;
	out->ez[0] = 0.0f; out->ez[1] = 0.0f; out->ez[2] = 0.0f;
}

inline void b2clGetSymInverse33(const b2clMat33 in, b2clMat33* out)
{
	//float det = b2clDot(ex, b2clCross(ey, ez));
	float det = in.ex[0] * (in.ey[1] * in.ez[2] - in.ey[2] * in.ez[1]) 
		+ in.ex[1] * (in.ey[2] * in.ez[0] - in.ey[0] * in.ez[2]) 
		+ in.ex[2] * (in.ey[0] * in.ez[1] - in.ey[1] * in.ez[0]);

	if (det != 0.0f)
	{
		det = 1.0f / det;
	}

	float a11 = in.ex[0], a12 = in.ey[0], a13 = in.ez[0];
	float a22 = in.ey[1], a23 = in.ez[1];
	float a33 = in.ez[2];

	out->ex[0] = det * (a22 * a33 - a23 * a23);
	out->ex[1] = det * (a13 * a23 - a12 * a33);
	out->ex[2] = det * (a12 * a23 - a13 * a22);

	out->ey[0] = out->ex[1];
	out->ey[1] = det * (a11 * a33 - a13 * a13);
	out->ey[2] = det * (a13 * a12 - a11 * a23);

	out->ez[0] = out->ex[2];
	out->ez[1] = out->ey[2];
	out->ez[2] = det * (a11 * a22 - a12 * a12);
}

inline float2 b2clMat33MulV2(const b2clMat33 A, const float2 v)
{
	return (float2)(A.ex[0] * v.x + A.ey[0] * v.y, A.ex[1] * v.x + A.ey[1] * v.y);
}

inline float3 b2clMat33MulV3(const b2clMat33 A, const float3 v)
{
	//return v.x * A.ex + v.y * A.ey + v.z * A.ez;
	return (float3)(A.ex[0] * v.x + A.ey[0] * v.y + A.ez[0] * v.z,
		A.ex[1] * v.x + A.ey[1] * v.y + A.ez[1] * v.z,
		A.ex[2] * v.x + A.ey[2] * v.y + A.ez[2] * v.z);
}

inline void b2clMat22GetInverse(const b2clMat22 in, b2clMat22* out)
{
	float a = in.ex[0], b = in.ey[0], c = in.ex[1], d = in.ey[1];
	float det = a * d - b * c;
	if (det != 0.0f)
	{
		det = 1.0f / det;
	}
	out->ex[0] =  det * d;	out->ey[0] = -det * b;
	out->ex[1] = -det * c;	out->ey[1] =  det * a;
}

inline void b2clSweepNormalize(b2clSweep* sweep)
{
	float twoPi = 2.0f * b2_pi;
	float d =  twoPi * floor(sweep->a0 / twoPi);
	sweep->a0 -= d;
	sweep->a -= d;
}

inline void b2clSweepGetTransform(b2clSweep* sweep, b2clTransform* xf, float beta)
{
	xf->p = (1.0f - beta) * sweep->c0 + beta * sweep->c;
	float angle = (1.0f - beta) * sweep->a0 + beta * sweep->a;
	xf->q.x = sin(angle);
	xf->q.y = cos(angle);

	// Shift to origin
	xf->p -= b2clMul_Rotate(xf->q, sweep->localCenter);
}

inline void b2clSweepAdvance(b2clSweep* sweep, float alpha)
{
	float beta = (alpha - sweep->alpha0) / (1.0f - sweep->alpha0);
	sweep->c0 = (1.0f - beta) * sweep->c0 + beta * sweep->c;
	sweep->a0 = (1.0f - beta) * sweep->a0 + beta * sweep->a;
	sweep->alpha0 = alpha;
}
inline void b2clBodySweepAdvance (b2clBodyDynamic* body, b2clTransform* xf, float alpha) {
	b2clSweepAdvance(&(body->m_sweep), alpha); 
	body->m_sweep.c = body->m_sweep.c0;
	body->m_sweep.a = body->m_sweep.a0;
    xf->q.x = sin (body->m_sweep.a);
	xf->q.y = cos (body->m_sweep.a); 
	xf->p = body->m_sweep.c - b2clMul_Rotate(xf->q, body->m_sweep.localCenter);
}

inline void b2clDistanceProxySet(b2clDistanceProxy* proxy, const b2clPolygonShape* shape)
{
	proxy->m_count = shape->m_vertexCount;
	proxy->m_radius = shape->m_radius;
	for (int i = 0; i < shape->m_vertexCount; ++i)
	{
		proxy->m_vertices[i] = shape->m_vertices[i];
	}
}

inline int b2clDistanceProxyGetSupport(const b2clDistanceProxy* proxy, float2 d)
{
	int bestIndex = 0;
	float bestValue = b2clDot(proxy->m_vertices[0], d);
	for (int i = 1; i < proxy->m_count; ++i)
	{
		float value = b2clDot(proxy->m_vertices[i], d);
		if (value > bestValue)
		{
			bestIndex = i;
			bestValue = value;
		}
	}
	return bestIndex;
}

inline float2 b2clDistanceProxyGetVertex(const b2clDistanceProxy* proxy, int index)
{
	return proxy->m_vertices[index];
}

// Convert a vector into a unit vector. Returns the length.
inline float b2clNormalize(float2* v)
{
	float length = sqrt(b2clDot(*v, *v));
	if (length < b2_epsilon)
	{
		return 0.0f;
	}
	float invLength = 1.0f / length;
	(*v).x *= invLength;
	(*v).y *= invLength;

	return length;
}

/*
inline float cos_wrapper(float a)
{
	//float sina = sin(a);
	//return sqrt(1-sina*sina);

	//return sin(1.5707963268-a);

	return cos(a);
}
*/

//#include <Box2D/Common/OpenCL/b2CLTypeDefOCL.h>

/// Friction mixing law. The idea is to allow either fixture to drive the restitution to zero.
/// For example, anything slides on ice.
inline float b2clMixFriction(float friction1, float friction2)
{
	return sqrt(friction1 * friction2);
}

/// Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface.
/// For example, a superball bounces on anything.
inline float b2clMixRestitution(float restitution1, float restitution2)
{
	return restitution1 > restitution2 ? restitution1 : restitution2;
}

__kernel void InitializeBodyState(
                                 __global clb2Velocity* velocities, // input & output
                                 __global clb2Position* positions, // input & output
								 __global b2clTransform* xfGlobal, // output
                                 const unsigned int num_body,
					  const __global b2clBodyStatic* bodyStaticListBuffer,
					  __global b2clBodyDynamic* bodyDynamicListBuffer,
					  const float2 gravity,
					  const float h)
{
    unsigned int i = get_global_id(0);

    if(i >= num_body) return;

	b2clBodyStatic bs = bodyStaticListBuffer[i];
	b2clBodyDynamic bd = bodyDynamicListBuffer[i];

	float2 c;
	c.x = positions[i].cx;
	c.y = positions[i].cy;
	float a = positions[i].a;
	float2 v;
	v.x = velocities[i].vx;
	v.y = velocities[i].vy;
	float w = velocities[i].w;

	if (bs.m_type == 2)// b2_dynamicBody
	{
		// Integrate velocities.
		v += h * (bs.m_gravityScale * gravity + bs.m_invMass * bd.m_force);
		w += h * bs.m_invI * bd.m_torque;

		// Apply damping.
		// ODE: dv/dt + c * v = 0
		// Solution: v(t) = v0 * exp(-c * t)
		// Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)
		// v2 = exp(-c * dt) * v1
		// Taylor expansion:
		// v2 = (1.0f - c * dt) * v1
		v *= b2clClamp(1.0f - h * bs.m_linearDamping, 0.0f, 1.0f);
		w *= b2clClamp(1.0f - h * bs.m_angularDamping, 0.0f, 1.0f);
	}

	
	positions[i].cx = c.x;
	positions[i].cy = c.y;
	positions[i].a = a;
	velocities[i].vx = v.x;
	velocities[i].vy = v.y;
	velocities[i].w = w;

	bd.m_sweep.c0 = bd.m_sweep.c;
	bd.m_sweep.a0 = bd.m_sweep.a;
	bodyDynamicListBuffer[i] = bd;
}

__kernel void InitializeBodyStateFirstFrame(
                                 __global clb2Velocity* velocities, // output
                                 __global clb2Position* positions, // output
                                 const unsigned int num_body,
					  const __global b2clBodyStatic* bodyStaticListBuffer,
					  __global b2clBodyDynamic* bodyDynamicListBuffer,
					  const float2 gravity,
					  const float h)
{
    unsigned int i = get_global_id(0);

    if(i >= num_body) return;

	b2clBodyStatic bs = bodyStaticListBuffer[i];
	b2clBodyDynamic bd = bodyDynamicListBuffer[i];

	float2 c = bd.m_sweep.c;
	float a = bd.m_sweep.a;
	float2 v = bd.m_linearVelocity;
	float w = bd.m_angularVelocity;

	if (bs.m_type == 2)// b2_dynamicBody
	{
		// Integrate velocities.
		v += h * (bs.m_gravityScale * gravity + bs.m_invMass * bd.m_force);
		w += h * bs.m_invI * bd.m_torque;

		// Apply damping.
		// ODE: dv/dt + c * v = 0
		// Solution: v(t) = v0 * exp(-c * t)
		// Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)
		// v2 = exp(-c * dt) * v1
		// Taylor expansion:
		// v2 = (1.0f - c * dt) * v1
		v *= b2clClamp(1.0f - h * bs.m_linearDamping, 0.0f, 1.0f);
		w *= b2clClamp(1.0f - h * bs.m_angularDamping, 0.0f, 1.0f);
	}


	positions[i].cx = c.x;
	positions[i].cy = c.y;
	positions[i].a = a;
	velocities[i].vx = v.x;
	velocities[i].vy = v.y;
	velocities[i].w = w;

	bd.m_sweep.c0 = bd.m_sweep.c;
	bd.m_sweep.a0 = bd.m_sweep.a;
	bodyDynamicListBuffer[i] = bd;
}




__kernel void WarmStart(
                       __global clb2Velocity* velocities, // input and output
                       __global clb2Contact* contacts,
                       __global clb2Impulse* impulses,
                       __global clb2Points* points,
                       const unsigned int contactCount)
{
    unsigned int contactIndex = get_global_id(0);

	int indexA, indexB;
	float2 vA, vB;
	float wA, wB;
    if(contactIndex < contactCount)
	{
		clb2Contact thisContact = contacts[contactIndex];
		clb2Impulse thisImpulse = impulses[contactIndex];
		clb2Points thisPoints = points[contactIndex];

		indexA = thisContact.indexA;
		indexB = thisContact.indexB;
		float mA = thisContact.invMassA;
		float iA = thisContact.invIA;
		float mB = thisContact.invMassB;
		float iB = thisContact.invIB;

		vA.x = 0;
		vA.y = 0;
		wA = 0;
		vB.x = 0;
		vB.y = 0;
		wB = 0;

		float2 normal = thisContact.normal;
		float2 tangent = b2clCross_VS(normal, 1.0f);

	//printf("normalImpuls: %f, tangentImpulse: %f\n", thisImpulse.normalImpulse1, thisImpulse.tangentImpulse1);
		float2 P = thisImpulse.normalImpulse1 * normal + thisImpulse.tangentImpulse1 * tangent;
		wA -= iA * b2clCross_VV(thisPoints.rA1, P);
		vA -= mA * P;
		wB += iB * b2clCross_VV(thisPoints.rB1, P);
		vB += mB * P;

		if(thisPoints.normalMass2>=0)
		{
			P = thisImpulse.normalImpulse2 * normal + thisImpulse.tangentImpulse2 * tangent;
			wA -= iA * b2clCross_VV(thisPoints.rA2, P);
			vA -= mA * P;
			wB += iB * b2clCross_VV(thisPoints.rB2, P);
			vB += mB * P;
		}


	}

	// serialize all threads to make sure synchronization
	for (int k=0; k<contactCount; k++)
	{
		if (contactIndex==k)
		{
			velocities[indexA].vx += vA.x;
			velocities[indexA].vy += vA.y;
			velocities[indexA].w += wA;
			velocities[indexB].vx += vB.x;
			velocities[indexB].vy += vB.y;
			velocities[indexB].w += wB;
		}
		barrier(CLK_GLOBAL_MEM_FENCE);
	}
}

__kernel void WarmStartWithColoring(
                       __global clb2Velocity* velocities, // input and output
                       __global clb2Contact* contacts,
                       __global clb2Impulse* impulses,
                       __global clb2Points* points,
                       const unsigned int offset,
                       const unsigned int colorLength)
{
    unsigned int contactIndex = get_global_id(0) + offset;

	if(contactIndex>=offset+colorLength) return;

	int indexA, indexB;
	float2 vA, vB;
	float wA, wB;

	clb2Contact thisContact = contacts[contactIndex];
	clb2Impulse thisImpulse = impulses[contactIndex];
	clb2Points thisPoints = points[contactIndex];

	indexA = thisContact.indexA;
	indexB = thisContact.indexB;
	float mA = thisContact.invMassA;
	float iA = thisContact.invIA;
	float mB = thisContact.invMassB;
	float iB = thisContact.invIB;

	vA.x = 0;
	vA.y = 0;
	wA = 0;
	vB.x = 0;
	vB.y = 0;
	wB = 0;

	float2 normal = thisContact.normal;
	float2 tangent = b2clCross_VS(normal, 1.0f);

	float2 P = thisImpulse.normalImpulse1 * normal + thisImpulse.tangentImpulse1 * tangent;
	wA -= iA * b2clCross_VV(thisPoints.rA1, P);
	vA -= mA * P;
	wB += iB * b2clCross_VV(thisPoints.rB1, P);
	vB += mB * P;

	if(thisPoints.normalMass2>=0)
	{
		P = thisImpulse.normalImpulse2 * normal + thisImpulse.tangentImpulse2 * tangent;
		wA -= iA * b2clCross_VV(thisPoints.rA2, P);
		vA -= mA * P;
		wB += iB * b2clCross_VV(thisPoints.rB2, P);
		vB += mB * P;
	}

	velocities[indexA].vx += vA.x;
	velocities[indexA].vy += vA.y;
	velocities[indexA].w += wA;
	velocities[indexB].vx += vB.x;
	velocities[indexB].vy += vB.y;
	velocities[indexB].w += wB;
}


__kernel void WarmStartSplit(
                       __global clb2Velocity* velocities, // input and output
					   __global clb2Velocity* splitVelocities,
					   __global unsigned int* indexContact2BodySplitVelocities,
					   __global unsigned int* hasSplitVelocitiesContacts,
					   __global unsigned int* Contacts4EachBody, 
                       __global clb2Contact* contacts,
                       __global clb2Impulse* impulses,
                       __global clb2Points* points,
                       unsigned int numContact,
                       unsigned int numBody
					 )
{

    unsigned int indexThread = get_global_id (0); 


	unsigned int contactIndex = indexThread ;
	int maxContactNumPerBody = 20 ; 
	//unsigned int contactIndex = get_global_id(0);
	//if (contactIndex >= numContact) return ; 
	int indexA, indexB; float2 vA, vB; float wA, wB;

    if (contactIndex < numContact) {

		clb2Contact thisContact = contacts[contactIndex];
		clb2Impulse thisImpulse = impulses[contactIndex];
		clb2Points thisPoints = points[contactIndex];

		indexA = thisContact.indexA;
		indexB = thisContact.indexB;
		float mA = thisContact.invMassA;
		float iA = thisContact.invIA;
		float mB = thisContact.invMassB;
		float iB = thisContact.invIB;
		int numBodyA = Contacts4EachBody[indexA]; 
		int numBodyB = Contacts4EachBody[indexB];  mA *= numBodyA ; mB *= numBodyB ; 
		int isGround[2] ; isGround[0] = (mA == 0)? 1 :0 ; isGround[1] = (mB == 0) ? 1:0 ; 
		unsigned int indexContact2BodyA = indexContact2BodySplitVelocities[contactIndex*2+0];
		unsigned int indexContact2BodyB = indexContact2BodySplitVelocities[contactIndex*2+1];

		vA.x = 0; vA.y = 0; wA = 0;vB.x = 0; vB.y = 0; wB = 0;

		float2 normal = thisContact.normal;
		float2 tangent = b2clCross_VS(normal, 1.0f);

		float2 P = thisImpulse.normalImpulse1 * normal + thisImpulse.tangentImpulse1 * tangent;
		//printf ("this warmstartimpulse: %f \n", thisImpulse.normalImpulse1);
		//printf ("thisImpulse.normalImpulse1: %f \n", thisImpulse.normalImpulse1);
		wA -= iA * b2clCross_VV(thisPoints.rA1, P); vA -= mA * P;
		wB += iB * b2clCross_VV(thisPoints.rB1, P); vB += mB * P;
		
		//printf ("warm start thisImpulse.normalImpulse1 %f \n", thisImpulse.normalImpulse1 );
		
		

		if(thisPoints.normalMass2>=0)
		{
			P = thisImpulse.normalImpulse2 * normal + thisImpulse.tangentImpulse2 * tangent;
			wA -= iA * b2clCross_VV(thisPoints.rA2, P);
			vA -= mA * P;
			wB += iB * b2clCross_VV(thisPoints.rB2, P);
			vB += mB * P;
		}
		clb2Velocity splitVA, splitVB ; 
		
		
		//printf ("contact number: %d , value: %f \n", contactIndex,  wA);
		splitVA.vx = vA.x ; splitVA.vy = vA.y*1.0  ; splitVA.w = wA ; 
		splitVB.vx = vB.x ; splitVB.vy = vB.y*1.0  ; splitVB.w = wB ; 

		

	    if (!isGround[0]) {
		       // splitVelocities [indexA * maxContactNumPerBody + indexContact2BodyA] = splitVA ; 		
			   splitVelocities [indexA * maxContactNumPerBody + indexContact2BodyA] = splitVA ; 
			   //printf ("warmstart splitVB.vy:  %f, ", splitVA.vy);		
		}
	    if (!isGround[1]) {
		       splitVelocities [indexB * maxContactNumPerBody + indexContact2BodyB] = splitVB ;
			   //printf ("warmstart splitVB.vy:  %f, ", splitVB.vy);
		}
		

	}


	 	
}



__kernel void WarmStartSplitWithColoring(
                       __global clb2Velocity* velocities, // input and output
                       __global clb2Contact* contacts,
                       __global clb2Impulse* impulses,
					   __global unsigned int* numContacts4EachBody,
                       __global clb2Points* points,
                       const unsigned int offset,
                       const unsigned int colorLength)
{

    unsigned int contactIndex = get_global_id(0) + offset;

	if(contactIndex>=offset+colorLength) return;

	int indexA, indexB;
	float2 vA, vB;
	float wA, wB;

	clb2Contact thisContact = contacts[contactIndex];
	clb2Impulse thisImpulse = impulses[contactIndex];
	clb2Points thisPoints = points[contactIndex];

	indexA = thisContact.indexA;
	indexB = thisContact.indexB;
	float mA = thisContact.invMassA;
	float iA = thisContact.invIA;
	float mB = thisContact.invMassB;
	float iB = thisContact.invIB;

	unsigned int numContactsA = numContacts4EachBody[indexA];
	unsigned int numContactsB = numContacts4EachBody[indexB];

	vA.x = 0;
	vA.y = 0;
	wA = 0;
	vB.x = 0;
	vB.y = 0;
	wB = 0;

	float2 normal = thisContact.normal;
	float2 tangent = b2clCross_VS(normal, 1.0f);

	float2 P = thisImpulse.normalImpulse1 * normal + thisImpulse.tangentImpulse1 * tangent;
	//P /= 4.0;
	wA -= iA * b2clCross_VV(thisPoints.rA1, P);
	vA -= mA * P;
	wB += iB * b2clCross_VV(thisPoints.rB1, P);
	vB += mB * P;

	if(thisPoints.normalMass2>=0)
	{
		P = thisImpulse.normalImpulse2 * normal + thisImpulse.tangentImpulse2 * tangent;
		//P /=4.0 ; 
		wA -= iA * b2clCross_VV(thisPoints.rA2, P);
		vA -= mA * P;
		wB += iB * b2clCross_VV(thisPoints.rB2, P);
		vB += mB * P;
	}


	if (numContactsA == 0) {vA.x = vA.y = wA = 0 ; numContactsA = 1 ; }
	if (numContactsB == 0) {vB.x = vB.y = wB = 0 ; numContactsB = 1 ; }

	float fNumA = numContactsA ,fNumB = numContactsB ; 



	velocities[indexA].vx += vA.x;
	velocities[indexA].vy += vA.y;
	velocities[indexA].w += wA;
	velocities[indexB].vx += vB.x;
	velocities[indexB].vy += vB.y;
	velocities[indexB].w += wB;


}






__kernel void InitializeVelocityConstraint(
                                 __global clb2Contact* contacts, // output
                                 __global clb2Impulse* impulses, // output
                                 __global clb2Points* points, // output
                                 __global clb2Manifold* manifoldsForPositionSolver, // output
								 //__global uint* manifoldKeys, // output, keys to be sorted
								 //__global uint* globalIndices, // output, values to be sorted
                                 const unsigned int contactCount,
						const __global clb2Velocity* velocities,
						const __global clb2Position* positions,
						const __global b2clFixtureStatic* fixtureStaticListBuffer,
						const __global b2clBodyStatic* bodyStaticListBuffer,
						const __global int4* indices, //indices to bodies and fixtures
						const __global int* coloredContactIndexToContactIndexMap,
						const __global b2clPolygonShape* polyGlobal,
						const __global b2clTransform* xfGlobal,
						const __global b2clManifold* manifolds, // input
						const int warmStarting,
						const float dtRatio)
{
    unsigned int contactIndex = get_global_id(0);

    if(contactIndex >= contactCount) return;

    clb2Contact thisContact;
    clb2Points currentPoints;
    clb2Impulse currentImpulses;
    clb2Manifold currentManifolds;

    int globalIndex = coloredContactIndexToContactIndexMap[contactIndex];
	int4 currentIndices = indices[globalIndex];

	float frictionA = fixtureStaticListBuffer[currentIndices.x].m_friction;
	float frictionB = fixtureStaticListBuffer[currentIndices.y].m_friction;
	thisContact.friction = b2clMixFriction(frictionA, frictionB);

	b2clBodyStatic bodyStaticA = bodyStaticListBuffer[currentIndices.z];
	b2clBodyStatic bodyStaticB = bodyStaticListBuffer[currentIndices.w];

	//// for debug
	//if (bodyStaticA.m_type==2 && bodyStaticB.m_type==2)
	//	printf("Both bodies (%d and %d) of #%d contact are dynamic!!!\n", currentIndices.z, currentIndices.w, contactIndex);

	thisContact.invMassA = bodyStaticA.m_invMass;
	thisContact.invMassB = bodyStaticB.m_invMass;
	thisContact.invIA = bodyStaticA.m_invI;
	thisContact.invIB = bodyStaticB.m_invI;
	thisContact.indexA = currentIndices.z;
	thisContact.indexB = currentIndices.w;

	//extractd code from b2WorldManifold::Initialize
	b2clManifold manifold = manifolds[globalIndex];
	b2clTransform xfA = xfGlobal[currentIndices.z];
	b2clTransform xfB = xfGlobal[currentIndices.w];
	float radiusA = polyGlobal[currentIndices.x].m_radius;
	float radiusB = polyGlobal[currentIndices.y].m_radius;
	float2 worldManifoldPoints[b2cl_maxManifoldPoints];
	float2 normal;
	switch (manifold.type)
	{
	case 0:
		{
			normal = (float2)(1.0, 0.0);
			float2 pointA = b2clMul_Transform(&xfA, manifold.localPoint);
			float2 pointB = b2clMul_Transform(&xfB, manifold.points[0].localPoint);
			if (b2clDistanceSquared(pointA, pointB) > b2_epsilon * b2_epsilon)
			{
				normal = normalize(pointB - pointA);
			}

			float2 cA = pointA + radiusA * normal;
			float2 cB = pointB - radiusB * normal;
			worldManifoldPoints[0] = 0.5f * (cA + cB);
		}
		break;
	case 1:
		{
			normal = b2clMul_Rotate(xfA.q, manifold.localNormal);
			float2 planePoint = b2clMul_Transform(&xfA, manifold.localPoint);
			
			for (int i = 0; i < manifold.pointCount; ++i)
			{
				float2 clipPoint = b2clMul_Transform(&xfB, manifold.points[i].localPoint);
				float2 cA = clipPoint + (radiusA - b2clDot(clipPoint - planePoint, normal)) * normal;
				float2 cB = clipPoint - radiusB * normal;
				worldManifoldPoints[i] = 0.5f * (cA + cB);
				//worldManifoldPoints[i] = clipPoint;
			}
			break;
		}
	case 2:
		{
			normal = b2clMul_Rotate(xfB.q, manifold.localNormal);
			float2 planePoint = b2clMul_Transform(&xfB, manifold.localPoint);

			for (int i = 0; i < manifold.pointCount; ++i)
			{
				float2 clipPoint = b2clMul_Transform(&xfA, manifold.points[i].localPoint);
				float2 cB = clipPoint + (radiusB - b2clDot(clipPoint - planePoint, normal)) * normal;
				float2 cA = clipPoint - radiusA * normal;
				worldManifoldPoints[i] = 0.5f * (cA + cB);
			}

			// Ensure normal points from A to B.
			normal = -normal;
			break;
		}
	}
	thisContact.normal = normal;

	clb2Position positionA = positions[currentIndices.z];
	clb2Position positionB = positions[currentIndices.w];
	currentPoints.rA1 = worldManifoldPoints[0] - (float2)(positionA.cx, positionA.cy);
	currentPoints.rB1 = worldManifoldPoints[0] - (float2)(positionB.cx, positionB.cy);

	float rnA = b2clCross_VV(currentPoints.rA1, normal);
	float rnB = b2clCross_VV(currentPoints.rB1, normal);
	float kNormal = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rnA * rnA + thisContact.invIB * rnB * rnB;
	currentPoints.normalMass1 = kNormal > 0.0f ? 1.0f / kNormal : 0.0f;

	float2 tangent = b2clCross_VS(normal, 1.0f);
	float rtA = b2clCross_VV(currentPoints.rA1, tangent);
	float rtB = b2clCross_VV(currentPoints.rB1, tangent);
	float kTangent = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rtA * rtA + thisContact.invIB * rtB * rtB;
	currentPoints.tangentMass1 = kTangent > 0.0f ? 1.0f /  kTangent : 0.0f;

	// Setup a velocity bias for restitution.
	clb2Velocity velocityA = velocities[currentIndices.z];
	clb2Velocity velocityB = velocities[currentIndices.w];
	float2 vA = (float2)(velocityA.vx, velocityA.vy);
	float2 vB = (float2)(velocityB.vx, velocityB.vy);
	float wA = velocityA.w;
	float wB = velocityB.w;
	float restitutionA = fixtureStaticListBuffer[currentIndices.x].m_restitution;
	float restitutionB = fixtureStaticListBuffer[currentIndices.y].m_restitution;
	float mixedrestitution = b2clMixRestitution(restitutionA, restitutionB);

	currentPoints.velocityBias1 = 0.0f;
	float vRel = b2clDot(normal, vB + b2clCross_SV(wB, currentPoints.rB1) - vA - b2clCross_SV(wA, currentPoints.rA1));
	if (vRel < -b2cl_velocityThreshold)
	{
		currentPoints.velocityBias1 = -mixedrestitution * vRel;
	}

	// This part is only useful for first frame.
	// In later frames, impulse will be reset in ReadLastImpulse
	if (warmStarting)
	{
		currentImpulses.normalImpulse1 = dtRatio * manifold.points[0].normalImpulse;
		currentImpulses.tangentImpulse1 = dtRatio * manifold.points[0].tangentImpulse;
	}
	else
	{
		currentImpulses.normalImpulse1 = 0.0f;
		currentImpulses.tangentImpulse1 = 0.0f;
	}

    // Extract useful manifold information for the position constraint solver
    currentManifolds.localNormal = manifold.localNormal;
    currentManifolds.localPoint = manifold.localPoint;
    currentManifolds.type=manifold.type;
    currentManifolds.pointCount=manifold.pointCount;
    currentManifolds.localPoints1=manifold.points[0].localPoint;
    currentManifolds.radiusA=radiusA;
    currentManifolds.radiusB=radiusB;
    currentManifolds.localCenterA=bodyStaticA.m_localCenter;
    currentManifolds.localCenterB=bodyStaticB.m_localCenter;
    
	if (manifold.pointCount>1)
	{
		currentPoints.rA2 = worldManifoldPoints[1] - (float2)(positionA.cx, positionA.cy);
		currentPoints.rB2 = worldManifoldPoints[1] - (float2)(positionB.cx, positionB.cy);

		float rnA = b2clCross_VV(currentPoints.rA2, normal);
		float rnB = b2clCross_VV(currentPoints.rB2, normal);
		float kNormal = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rnA * rnA + thisContact.invIB * rnB * rnB;
		currentPoints.normalMass2 = kNormal > 0.0f ? 1.0f / kNormal : 0.0f;

		float2 tangent = b2clCross_VS(normal, 1.0f);
		float rtA = b2clCross_VV(currentPoints.rA2, tangent);
		float rtB = b2clCross_VV(currentPoints.rB2, tangent);
		float kTangent = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rtA * rtA + thisContact.invIB * rtB * rtB;
		currentPoints.tangentMass2 = kTangent > 0.0f ? 1.0f /  kTangent : 0.0f;

		currentPoints.velocityBias2 = 0.0f;
		float vRel = b2clDot(normal, vB + b2clCross_SV(wB, currentPoints.rB2) - vA - b2clCross_SV(wA, currentPoints.rA2));
		if (vRel < -b2cl_velocityThreshold)
		{
			currentPoints.velocityBias2 = -mixedrestitution * vRel;
		}

		// This part is only useful for first frame.
		// In later frames, impulse will be reset in ReadLastImpulse
		if (warmStarting)
		{
			currentImpulses.normalImpulse2 = dtRatio * manifold.points[1].normalImpulse;
			currentImpulses.tangentImpulse2 = dtRatio * manifold.points[1].tangentImpulse;
		}
		else
		{
			currentImpulses.normalImpulse2 = 0.0f;
			currentImpulses.tangentImpulse2 = 0.0f;
		}

		currentManifolds.localPoints2=manifold.points[1].localPoint;
	}
	else
	{
		currentPoints.rA2 = -1;
		currentPoints.rB2 = -1;
		currentPoints.normalMass2 = -1;
		currentPoints.tangentMass2 = -1;
		currentPoints.velocityBias2 = -1;
		currentImpulses.normalImpulse2 = 0;
		currentImpulses.tangentImpulse2 = 0;
	}

	contacts[contactIndex] = thisContact;

	points[contactIndex].rA1 = currentPoints.rA1;
	points[contactIndex].rB1 = currentPoints.rB1;
	points[contactIndex].normalMass1 = currentPoints.normalMass1;
	points[contactIndex].tangentMass1 = currentPoints.tangentMass1;
	points[contactIndex].velocityBias1 = currentPoints.velocityBias1;

	points[contactIndex].rA2 = currentPoints.rA2;
	points[contactIndex].rB2 = currentPoints.rB2;
	points[contactIndex].normalMass2 = currentPoints.normalMass2;
	points[contactIndex].tangentMass2 = currentPoints.tangentMass2;
	points[contactIndex].velocityBias2 = currentPoints.velocityBias2;

	// This part is only useful for first frame.
	// In later frames, impulse will be reset in ReadLastImpulse
	impulses[contactIndex] = currentImpulses;
    
    manifoldsForPositionSolver[contactIndex] = currentManifolds;

	//if (currentIndices.x<currentIndices.y)
	//	manifoldKeys[contactIndex] = currentIndices.x<<16 | currentIndices.y; // suppose both indices are less than 65536 and thus fit in 16 bits.
	//else
	//	manifoldKeys[contactIndex] = currentIndices.y<<16 | currentIndices.x; // suppose both indices are less than 65536 and thus fit in 16 bits.
	//globalIndices[contactIndex] = globalIndex;
}


__kernel void CountContactNum4EachBodyConstraint (				 
                              volatile __global unsigned int* numContacts4EachBody,
							  __global unsigned int* indexContact2BodySplitVelocity,
							  const __global int4* indices, 
							  const __global int* coloredContactIndexToContactIndexMap,
							   const __global b2clBodyStatic* bodyStaticListBuffer,
							  unsigned int contactCount
                             ) 
{



 unsigned int contactIndex = get_global_id(0) ; 
	if (contactIndex >= contactCount) return ; 
	
    clb2Contact thisContact;
    int globalIndex = coloredContactIndexToContactIndexMap[contactIndex];
	int4 currentIndices = indices[globalIndex];
	thisContact.indexA = currentIndices.z;
	thisContact.indexB = currentIndices.w;
	b2clBodyStatic bodyStaticA = bodyStaticListBuffer[currentIndices.z];
	b2clBodyStatic bodyStaticB = bodyStaticListBuffer[currentIndices.w];
	if (bodyStaticA.m_invMass != 0) 
       indexContact2BodySplitVelocity[contactIndex*2+0] =  atomic_inc ( numContacts4EachBody+thisContact.indexA );  
	if (bodyStaticB.m_invMass != 0 )
       indexContact2BodySplitVelocity[contactIndex*2+1] =  atomic_inc ( numContacts4EachBody+thisContact.indexB );

}

__kernel void InitializeVelocityConstraint_HasSplit(
                                 __global clb2Contact* contacts, // output
                                 __global clb2Impulse* impulses, // output
                                 __global clb2Points* points, // output
                                 __global clb2Manifold* manifoldsForPositionSolver, // output
								 //__global uint* manifoldKeys, // output, keys to be sorted
								 //__global uint* globalIndices, // output, values to be sorted
                                 const unsigned int contactCount,
						const __global clb2Velocity* velocities,
						const __global clb2Position* positions,
						const __global b2clFixtureStatic* fixtureStaticListBuffer,
						const __global b2clBodyStatic* bodyStaticListBuffer,
						const __global int4* indices, //indices to bodies and fixtures
						const __global int* coloredContactIndexToContactIndexMap,
						const __global b2clPolygonShape* polyGlobal,
						const __global b2clTransform* xfGlobal,
						const __global b2clManifold* manifolds, // input
						const int warmStarting,
						const float dtRatio,
						__global unsigned int* numContacts4EachBody, 
						__global unsigned int* indexContact2BodySplitVelocity
)
{
    unsigned int contactIndex = get_global_id(0) ; 
	if (contactIndex >= contactCount) return ; 
    clb2Contact thisContact;
    clb2Points currentPoints;
    clb2Impulse currentImpulses;
    clb2Manifold currentManifolds;

    int globalIndex = coloredContactIndexToContactIndexMap[contactIndex];
	int4 currentIndices = indices[globalIndex];

	float frictionA = fixtureStaticListBuffer[currentIndices.x].m_friction;
	float frictionB = fixtureStaticListBuffer[currentIndices.y].m_friction;
	thisContact.friction = b2clMixFriction(frictionA, frictionB);

	b2clBodyStatic bodyStaticA = bodyStaticListBuffer[currentIndices.z];
	b2clBodyStatic bodyStaticB = bodyStaticListBuffer[currentIndices.w];
	thisContact.invMassA = bodyStaticA.m_invMass;
	thisContact.invMassB = bodyStaticB.m_invMass;
	thisContact.invIA = bodyStaticA.m_invI;
	thisContact.invIB = bodyStaticB.m_invI;
	thisContact.indexA = currentIndices.z;
	thisContact.indexB = currentIndices.w;



	//extractd code from b2WorldManifold::Initialize
	b2clManifold manifold = manifolds[globalIndex];
	b2clTransform xfA = xfGlobal[currentIndices.z];
	b2clTransform xfB = xfGlobal[currentIndices.w];
	float radiusA = polyGlobal[currentIndices.x].m_radius;
	float radiusB = polyGlobal[currentIndices.y].m_radius;
	float2 worldManifoldPoints[b2cl_maxManifoldPoints];
	float2 normal;
	switch (manifold.type)
	{
	case 0:
		{
			normal = (float2)(1.0, 0.0);
			float2 pointA = b2clMul_Transform(&xfA, manifold.localPoint);
			float2 pointB = b2clMul_Transform(&xfB, manifold.points[0].localPoint);
			if (b2clDistanceSquared(pointA, pointB) > b2_epsilon * b2_epsilon)
			{
				normal = normalize(pointB - pointA);
			}

			float2 cA = pointA + radiusA * normal;
			float2 cB = pointB - radiusB * normal;
			worldManifoldPoints[0] = 0.5f * (cA + cB);
		}
		break;
	case 1:
		{
			normal = b2clMul_Rotate(xfA.q, manifold.localNormal);
			float2 planePoint = b2clMul_Transform(&xfA, manifold.localPoint);
			
			for (int i = 0; i < manifold.pointCount; ++i)
			{
				float2 clipPoint = b2clMul_Transform(&xfB, manifold.points[i].localPoint);
				float2 cA = clipPoint + (radiusA - b2clDot(clipPoint - planePoint, normal)) * normal;
				float2 cB = clipPoint - radiusB * normal;
				worldManifoldPoints[i] = 0.5f * (cA + cB);
				//worldManifoldPoints[i] = clipPoint;
			}
			break;
		}
	case 2:
		{
			normal = b2clMul_Rotate(xfB.q, manifold.localNormal);
			float2 planePoint = b2clMul_Transform(&xfB, manifold.localPoint);

			for (int i = 0; i < manifold.pointCount; ++i)
			{
				float2 clipPoint = b2clMul_Transform(&xfA, manifold.points[i].localPoint);
				float2 cB = clipPoint + (radiusB - b2clDot(clipPoint - planePoint, normal)) * normal;
				float2 cA = clipPoint - radiusA * normal;
				worldManifoldPoints[i] = 0.5f * (cA + cB);
			}

			// Ensure normal points from A to B.
			normal = -normal;
			break;
		}
	}
	thisContact.normal = normal;

	clb2Position positionA = positions[currentIndices.z];
	clb2Position positionB = positions[currentIndices.w];
	currentPoints.rA1 = worldManifoldPoints[0] - (float2)(positionA.cx, positionA.cy);
	currentPoints.rB1 = worldManifoldPoints[0] - (float2)(positionB.cx, positionB.cy);
	int numA = numContacts4EachBody[thisContact.indexA] ;  if (numA == 0) numA = 1;
	int numB = numContacts4EachBody[thisContact.indexB] ;  if (numB == 0) numB = 1; 

	float rnA = b2clCross_VV(currentPoints.rA1, normal);
	float rnB = b2clCross_VV(currentPoints.rB1, normal);

	/////////////////////////////////////
	//make invIB small
	//thisContact.invIA = thisContact.invIB = 1 ; 

	/////////////////////////////////////


	

	//printf ("thisContact.invIA: %f, \n" , thisContact.invIA); 
	//printf ("thisContact.invMassA: %f, \n" , thisContact.invMassA); 
	//printf ("kNormal: %f, \n" , kNormal);
	float kNormal = thisContact.invMassA*numA + thisContact.invMassB* numB + thisContact.invIA*numA * rnA * rnA + thisContact.invIB * numB * rnB * rnB;
	//float kNormal = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rnA * rnA + thisContact.invIB * rnB * rnB;
	currentPoints.normalMass1 = kNormal > 0.0f ? 1.0f / kNormal : 0.0f;
	//printf ("currentpoints.normal Mass1: %f, \n" , kNormal); 

	float2 tangent = b2clCross_VS(normal, 1.0f);
	float rtA = b2clCross_VV(currentPoints.rA1, tangent);
	float rtB = b2clCross_VV(currentPoints.rB1, tangent);
	float kTangent = thisContact.invMassA * numA + thisContact.invMassB * numB + thisContact.invIA * numA * rtA * rtA + thisContact.invIB * numB * rtB * rtB;
	//float kTangent = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rnA * rnA + thisContact.invIB * rnB * rnB;
	currentPoints.tangentMass1 = kTangent > 0.0f ? 1.0f /  kTangent : 0.0f;

	// Setup a velocity bias for restitution.
	clb2Velocity velocityA = velocities[currentIndices.z];
	clb2Velocity velocityB = velocities[currentIndices.w];
	float2 vA = (float2)(velocityA.vx, velocityA.vy);
	float2 vB = (float2)(velocityB.vx, velocityB.vy);
	float wA = velocityA.w;
	float wB = velocityB.w;
	float restitutionA = fixtureStaticListBuffer[currentIndices.x].m_restitution;
	float restitutionB = fixtureStaticListBuffer[currentIndices.y].m_restitution;
	float mixedrestitution = b2clMixRestitution(restitutionA, restitutionB);

	currentPoints.velocityBias1 = 0.0f;
	float vRel = b2clDot(normal, vB + b2clCross_SV(wB, currentPoints.rB1) - vA - b2clCross_SV(wA, currentPoints.rA1));
	if (vRel < -b2cl_velocityThreshold)
	{
		currentPoints.velocityBias1 = -mixedrestitution * vRel;
	}

	// This part is only useful for first frame.
	// In later frames, impulse will be reset in ReadLastImpulse
	if (warmStarting)
	{
		currentImpulses.normalImpulse1 = dtRatio * manifold.points[0].normalImpulse;
		currentImpulses.tangentImpulse1 = dtRatio * manifold.points[0].tangentImpulse;
	}
	else
	{
		currentImpulses.normalImpulse1 = 0.0f;
		currentImpulses.tangentImpulse1 = 0.0f;
	}

    // Extract useful manifold information for the position constraint solver
    currentManifolds.localNormal = manifold.localNormal;
    currentManifolds.localPoint = manifold.localPoint;
    currentManifolds.type=manifold.type;
    currentManifolds.pointCount=manifold.pointCount;
    currentManifolds.localPoints1=manifold.points[0].localPoint;
    currentManifolds.radiusA=radiusA;
    currentManifolds.radiusB=radiusB;
    currentManifolds.localCenterA=bodyStaticA.m_localCenter;
    currentManifolds.localCenterB=bodyStaticB.m_localCenter;
    
	if (manifold.pointCount>1)
	{
		currentPoints.rA2 = worldManifoldPoints[1] - (float2)(positionA.cx, positionA.cy);
		currentPoints.rB2 = worldManifoldPoints[1] - (float2)(positionB.cx, positionB.cy);

		float rnA = b2clCross_VV(currentPoints.rA2, normal);
		float rnB = b2clCross_VV(currentPoints.rB2, normal);
		float kNormal = thisContact.invMassA * numA + thisContact.invMassB * numB + thisContact.invIA * numA * rnA * rnA + thisContact.invIB *numB * rnB * rnB;
		//float kNormal = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rnA * rnA + thisContact.invIB * rnB * rnB;
		currentPoints.normalMass2 = kNormal > 0.0f ? 1.0f / kNormal : 0.0f;

		float2 tangent = b2clCross_VS(normal, 1.0f);
		float rtA = b2clCross_VV(currentPoints.rA2, tangent);
		float rtB = b2clCross_VV(currentPoints.rB2, tangent);
		float kTangent = thisContact.invMassA * numA + thisContact.invMassB * numB + thisContact.invIA * numA * rtA * rtA + thisContact.invIB * numB * rtB * rtB;
		//float kTangent = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rnA * rnA + thisContact.invIB * rnB * rnB;
		currentPoints.tangentMass2 = kTangent > 0.0f ? 1.0f /  kTangent : 0.0f;

		currentPoints.velocityBias2 = 0.0f;
		float vRel = b2clDot(normal, vB + b2clCross_SV(wB, currentPoints.rB2) - vA - b2clCross_SV(wA, currentPoints.rA2));
		if (vRel < -b2cl_velocityThreshold)
		{
			currentPoints.velocityBias2 = -mixedrestitution * vRel;
		}

		// This part is only useful for first frame.
		// In later frames, impulse will be reset in ReadLastImpulse
		if (warmStarting)
		{
			currentImpulses.normalImpulse2 = dtRatio * manifold.points[1].normalImpulse;
			currentImpulses.tangentImpulse2 = dtRatio * manifold.points[1].tangentImpulse;
		}
		else
		{
			currentImpulses.normalImpulse2 = 0.0f;
			currentImpulses.tangentImpulse2 = 0.0f;
		}

		currentManifolds.localPoints2=manifold.points[1].localPoint;
	}
	else
	{
		currentPoints.rA2 = -1;
		currentPoints.rB2 = -1;
		currentPoints.normalMass2 = -1;
		currentPoints.tangentMass2 = -1;
		currentPoints.velocityBias2 = -1;
		currentImpulses.normalImpulse2 = 0;
		currentImpulses.tangentImpulse2 = 0;
	}

	contacts[contactIndex] = thisContact;

	points[contactIndex].rA1 = currentPoints.rA1;
	points[contactIndex].rB1 = currentPoints.rB1;
	points[contactIndex].normalMass1 = currentPoints.normalMass1;
	points[contactIndex].tangentMass1 = currentPoints.tangentMass1;
	points[contactIndex].velocityBias1 = currentPoints.velocityBias1;

	points[contactIndex].rA2 = currentPoints.rA2;
	points[contactIndex].rB2 = currentPoints.rB2;
	points[contactIndex].normalMass2 = currentPoints.normalMass2;
	points[contactIndex].tangentMass2 = currentPoints.tangentMass2;
	points[contactIndex].velocityBias2 = currentPoints.velocityBias2;

	// This part is only useful for first frame.
	// In later frames, impulse will be reset in ReadLastImpulse
	impulses[contactIndex] = currentImpulses;
    
    manifoldsForPositionSolver[contactIndex] = currentManifolds;

	//if (currentIndices.x<currentIndices.y)
	//	manifoldKeys[contactIndex] = currentIndices.x<<16 | currentIndices.y; // suppose both indices are less than 65536 and thus fit in 16 bits.
	//else
	//	manifoldKeys[contactIndex] = currentIndices.y<<16 | currentIndices.x; // suppose both indices are less than 65536 and thus fit in 16 bits.
	//globalIndices[contactIndex] = globalIndex;
}

__kernel void StoreImpulses(
                        __global b2clManifold* manifolds, // input and output
						__global uint* manifoldKeys, // output, keys to be sorted
						__global uint* globalIndices, // output, values to be sorted
                        const __global int* coloredContactIndexToContactIndexMap,
                        const __global clb2Impulse* impulses,
						const __global int4* indices, //indices to bodies and fixtures
                        const int contactCount)
{
    unsigned int contactIndex = get_global_id(0);

	if(contactIndex >= contactCount) return;
    
    int globalIndex = coloredContactIndexToContactIndexMap[contactIndex];
   
    b2clManifold manifold = manifolds[globalIndex];
    clb2Impulse currentImpulses = impulses[contactIndex];

    manifold.points[0].normalImpulse = currentImpulses.normalImpulse1;
    manifold.points[0].tangentImpulse = currentImpulses.tangentImpulse1;

	//printf ("Store Impulse:  %f \n", manifold.points[0].normalImpulse ) ; 
    
    if(manifold.pointCount>1)
	{
        manifold.points[1].normalImpulse = currentImpulses.normalImpulse2;
        manifold.points[1].tangentImpulse = currentImpulses.tangentImpulse2;
    }
	else
	{
        manifold.points[1].normalImpulse = 0;
        manifold.points[1].tangentImpulse = 0;
    }
    
	//printf("pointCount: %d, normalImpuls: %f, tangentImpulse: %f\n", manifold.pointCount, manifold.points[0].normalImpulse, manifold.points[0].tangentImpulse);
    manifolds[globalIndex] = manifold;

	int4 currentIndices = indices[globalIndex];

 
	if (currentIndices.x<currentIndices.y)
		manifoldKeys[contactIndex] = currentIndices.x<<16 | currentIndices.y; // suppose both indices are less than 65536 and thus fit in 16 bits.
	else
		manifoldKeys[contactIndex] = currentIndices.y<<16 | currentIndices.x; // suppose both indices are less than 65536 and thus fit in 16 bits.

	//if (currentIndices.z<currentIndices.w)
	//	manifoldKeys[contactIndex] = currentIndices.z<<16 | currentIndices.w; // suppose both indices are less than 65536 and thus fit in 16 bits.
	//else
	//	manifoldKeys[contactIndex] = currentIndices.w<<16 | currentIndices.z; // suppose both indices are less than 65536 and thus fit in 16 bits.
	globalIndices[contactIndex] = globalIndex;
}


__kernel void SolveVelocityConstraintComplex(
                                 __global clb2Velocity* velocities,
                                 __global clb2Contact* contacts,
                                 __global clb2Impulse* impulses,
                                 __global clb2Points* points,
								 //__global float* testArray, 
                                 const unsigned int offset,
                                 const unsigned int colorLength
                                 
								 )

{
    unsigned int contactIndex = get_global_id(0) + offset;

    if(contactIndex>=offset+colorLength) return;

    clb2Contact thisContact = contacts[contactIndex];
    clb2Impulse thisImpulse = impulses[contactIndex];
    clb2Points thisPoints = points[contactIndex];
    clb2Velocity thisVelA = velocities[thisContact.indexA];
    clb2Velocity thisVelB = velocities[thisContact.indexB];

	//if (thisContact.indexA == 2 && thisContact.indexB == 1) {
	//	//printf ("2 and 1 , return " ); 
	//	return ; 
	//}



	// Computer K ; 
	b2clMat22 K ; 
	b2clMat22 normalMassMat ; 
	if (thisPoints.normalMass2 >=0 ) {
		   float rn1A = thisPoints.rA1.x * thisContact.normal.y - thisPoints.rA1.y * thisContact.normal.x ;   
		   float rn1B = thisPoints.rB1.x * thisContact.normal.y - thisPoints.rB1.y * thisContact.normal.x ;
		   float rn2A = thisPoints.rA2.x * thisContact.normal.y - thisPoints.rA2.y * thisContact.normal.x ;
		   float rn2B = thisPoints.rB2.x * thisContact.normal.y - thisPoints.rB2.y * thisContact.normal.x ;
		   float k11 = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rn1A * rn1A + thisContact.invIB * rn1B * rn1B ; 
		   float k22 = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rn2A * rn2A + thisContact.invIB * rn2B * rn2B ; 
		   float k12 = thisContact.invMassA + thisContact.invMassB + thisContact.invIA * rn1A * rn2A + thisContact.invIB * rn1B * rn2B ; 
		    
           float k_maxConditionNumber = 1000.0f ; 
		   bool ifcase = (  k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12) ) ; 
           if ( ifcase ) {
			K.ex[0] = k11 ; K.ex[1] = k12 ; 
			K.ey[0] = k12 ; K.ey[1] = k22 ; 
			b2clMat22GetInverse ( K , &normalMassMat ) ; 
		   }
		   else {
			thisPoints.normalMass2 = -1 ; 
		   }
    }



    // Calculate the tangent impulse for the first contact point
    float2 dv;
    dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB1.y-thisVelA.vx+thisVelA.w * thisPoints.rA1.y;
    dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB1.x-thisVelA.vy-thisVelA.w * thisPoints.rA1.x;
    
    float vp = dv.x*thisContact.normal.y-dv.y*thisContact.normal.x;
    float lambda = thisPoints.tangentMass1 * (-vp);
    
    float maxFriction = thisContact.friction * thisImpulse.normalImpulse1;
	
    float newImpulse=clamp(thisImpulse.tangentImpulse1+lambda,-maxFriction,maxFriction);
    lambda=newImpulse-thisImpulse.tangentImpulse1;
    thisImpulse.tangentImpulse1=newImpulse;

//float kTangent = thisContact.invMassA * numA + thisContact.invMassB * numB + thisContact.invIA * numA * rtA * rtA + thisContact.invIB * numB * rtB * rtB;

    
    float2 P; 
    P.x = lambda*thisContact.normal.y;
    P.y = -lambda*thisContact.normal.x;

	//if (thisContact.indexA == 1 && thisContact.indexB == 0) {
	//	printf ("indexA: %d \n", thisContact.indexA); 
	//}

	
    thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
    thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 

	//printf ("after thisVelA.vy: %f \n", thisVelA.vy ); 
    thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA1.x * P.y - thisPoints.rA1.y * P.x); 
    
    thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
    thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
    thisVelB.w= thisVelB.w+thisContact.invIB * (thisPoints.rB1.x * P.y - thisPoints.rB1.y * P.x);

   			
    // Calculate the tangent impulse for the second contact point if there is the second contact point
    if(thisPoints.normalMass2>=0)
	{
        dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB2.y-thisVelA.vx+thisVelA.w * thisPoints.rA2.y;
        dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB2.x-thisVelA.vy-thisVelA.w * thisPoints.rA2.x;
        
        vp = dv.x*thisContact.normal.y-dv.y*thisContact.normal.x;
        lambda = thisPoints.tangentMass2 * (-vp);
        
        maxFriction = thisContact.friction * thisImpulse.normalImpulse2;
        newImpulse=clamp(thisImpulse.tangentImpulse2+lambda,-maxFriction,maxFriction);
        lambda=newImpulse-thisImpulse.tangentImpulse2;
        thisImpulse.tangentImpulse2=newImpulse;
        
        P.x = lambda*thisContact.normal.y;
        P.y = -lambda*thisContact.normal.x;
        
        thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
        thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 

		
        thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA2.x * P.y - thisPoints.rA2.y * P.x); 
        
        thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
        thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
        thisVelB.w= thisVelB.w+thisContact.invIB * (thisPoints.rB2.x * P.y - thisPoints.rB2.y * P.x);
    }
    
    // Calculate the normal impulse for the first contact point
	if ( thisPoints.normalMass2 <0 ) {
		dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB1.y-thisVelA.vx+thisVelA.w * thisPoints.rA1.y;
		dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB1.x-thisVelA.vy-thisVelA.w * thisPoints.rA1.x;
    
		vp = dv.x*thisContact.normal.x+dv.y*thisContact.normal.y;
		lambda = -thisPoints.normalMass1 * (vp-thisPoints.velocityBias1);
    
		newImpulse=fmax(thisImpulse.normalImpulse1+lambda,0);
		lambda=newImpulse-thisImpulse.normalImpulse1;
		thisImpulse.normalImpulse1=newImpulse;
    
		P.x = lambda*thisContact.normal.x;
		P.y = lambda*thisContact.normal.y; 
		thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
		thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 
		thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA1.x * P.y - thisPoints.rA1.y * P.x); 

	 
    
		thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
		thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
		thisVelB.w= thisVelB.w+thisContact.invIB * (thisPoints.rB1.x * P.y - thisPoints.rB1.y * P.x);
	}
	else {

	       float2 a; 
		   a.x = thisImpulse.normalImpulse1;
		   a.y = thisImpulse.normalImpulse2;

           float2 dv1 , dv2 ; 
		   dv1.x = thisVelB.vx-thisVelB.w * thisPoints.rB1.y-thisVelA.vx+thisVelA.w * thisPoints.rA1.y;
		   dv1.y = thisVelB.vy+thisVelB.w * thisPoints.rB1.x-thisVelA.vy-thisVelA.w * thisPoints.rA1.x;
		   dv2.x = thisVelB.vx-thisVelB.w * thisPoints.rB2.y-thisVelA.vx+thisVelA.w * thisPoints.rA2.y;
           dv2.y = thisVelB.vy+thisVelB.w * thisPoints.rB2.x-thisVelA.vy-thisVelA.w * thisPoints.rA2.x;

		   float vn1 , vn2 ; 
		   vn1 = dv1.x*thisContact.normal.x+dv1.y*thisContact.normal.y;
		   vn2 = dv2.x*thisContact.normal.x+dv2.y*thisContact.normal.y;

		   float2 b ; 

		   b.x = vn1 - thisPoints.velocityBias1 ; 
		   b.y = vn2 - thisPoints.velocityBias2 ; 

		   float2 Ka  = b2clMat22Mul ( K , a ) ; 
		   b.x = b.x - Ka.x  ; b.y = b.y - Ka.y ; 
		   float k_errorTol = 1e-3f ; 

		   for (;;)
		   {
			float2 x = b2clMat22Mul (normalMassMat, b); x.x = 0 - x.x ; x.y = 0- x.y ; 
				
				if (x.x >= 0.0f && x.y >= 0.0f)
				{

				    //float2 vA, wA, vB, wB ; 

					//vA.x = thisVelA.vx ; vA.y = thisVelA.vy ; wA = thisVelA.w ; 
					//vB.x = thisVelB.vx ; vB.y = thisVelB.vy ; wB = thisVelB.w ;
					 
					// Get the incremental impulse
					float2 d ;
					d = x - a;  
				    
					// Apply incremental impulse
					float2 P1 , P2 ; 
					P1.x = d.x * thisContact.normal.x ; P1.y = d.x * thisContact.normal.y ; 
					P2.x = d.y * thisContact.normal.x ; P2.y = d.y * thisContact.normal.y ; 



					thisVelA.vx = thisVelA.vx - thisContact.invMassA * (P1.x + P2.x);
					thisVelA.vy = thisVelA.vy - thisContact.invMassA * (P1.y + P2.y);
					float cr_rA1P1 = b2clCross_VV (thisPoints.rA1, P1 ) ; 
					float cr_rA2P2 = b2clCross_VV (thisPoints.rA2, P2 ) ;
					thisVelA.w = thisVelA.w - thisContact.invIA * (cr_rA1P1 + cr_rA2P2); 

					thisVelB.vx = thisVelB.vx + thisContact.invMassB * (P1.x + P2.x);
					thisVelB.vy = thisVelB.vy + thisContact.invMassB * (P1.y + P2.y);
					float cr_rB1P1 = b2clCross_VV (thisPoints.rB1, P1 ) ;
					float cr_rB2P2 = b2clCross_VV (thisPoints.rB2, P2 ) ;
					thisVelB.w = thisVelB.w + thisContact.invIB * (cr_rB1P1 + cr_rB2P2); 

					//printf ("thisVelA.vy: %f \n", thisVelA.vy);

					thisImpulse.normalImpulse1 = x.x ; 
					thisImpulse.normalImpulse2 = x.y ; 
					break;
				}
				x.x = 0 - thisPoints.normalMass1 * b.x ; 
				x.y = 0.0f ;
				vn1 = 0.0f ; 
				vn2 = K.ex[1] * x.x + b.y ; 
				
				if (x.x >= 0.0f && vn2 >= 0.0f)
				{
					float2 d ;
					d = x - a;  
				    
					// Apply incremental impulse
					float2 P1 , P2 ; 
					P1.x = d.x * thisContact.normal.x ; P1.y = d.x * thisContact.normal.y ; 
					P2.x = d.y * thisContact.normal.x ; P2.y = d.y * thisContact.normal.y ; 



					thisVelA.vx = thisVelA.vx - thisContact.invMassA * (P1.x + P2.x);
					
					thisVelA.vy = thisVelA.vy - thisContact.invMassA * (P1.y + P2.y);
                    
					float cr_rA1P1 = b2clCross_VV (thisPoints.rA1, P1 ) ; 
					float cr_rA2P2 = b2clCross_VV (thisPoints.rA2, P2 ) ;
					thisVelA.w = thisVelA.w - thisContact.invIA * (cr_rA1P1 + cr_rA2P2); 

					thisVelB.vx = thisVelB.vx + thisContact.invMassB * (P1.x + P2.x);
					thisVelB.vy = thisVelB.vy + thisContact.invMassB * (P1.y + P2.y);
					float cr_rB1P1 = b2clCross_VV (thisPoints.rB1, P1 ) ;
					float cr_rB2P2 = b2clCross_VV (thisPoints.rB2, P2 ) ;
					thisVelB.w = thisVelB.w + thisContact.invIB * (cr_rB1P1 + cr_rB2P2); 

					//printf ("thisVelA.vy: %f \n", thisVelA.vy);

					thisImpulse.normalImpulse1 = x.x ; 
					thisImpulse.normalImpulse2 = x.y ; 
					break;
				}
				x.x = 0.0f;
				x.y = 0 - thisPoints.normalMass2 * b.y;
				vn1 = K.ey[1]*x.y + b.x ; 
				vn2 = 0.0f;
				if (x.y >= 0.0f && vn1 >= 0.0f)
				{
					float2 d ;
					d = x - a;  
				    
					// Apply incremental impulse
					float2 P1 , P2 ; 
					P1.x = d.x * thisContact.normal.x ; P1.y = d.x * thisContact.normal.y ; 
					P2.x = d.y * thisContact.normal.x ; P2.y = d.y * thisContact.normal.y ; 

					thisVelA.vx = thisVelA.vx - thisContact.invMassA * (P1.x + P2.x);
					thisVelA.vy = thisVelA.vy - thisContact.invMassA * (P1.y + P2.y);
					float cr_rA1P1 = b2clCross_VV (thisPoints.rA1, P1 ) ; 
					float cr_rA2P2 = b2clCross_VV (thisPoints.rA2, P2 ) ;
					thisVelA.w = thisVelA.w - thisContact.invIA * (cr_rA1P1 + cr_rA2P2); 

					thisVelB.vx = thisVelB.vx + thisContact.invMassB * (P1.x + P2.x);
					thisVelB.vy = thisVelB.vy + thisContact.invMassB * (P1.y + P2.y);
					float cr_rB1P1 = b2clCross_VV (thisPoints.rB1, P1 ) ;
					float cr_rB2P2 = b2clCross_VV (thisPoints.rB2, P2 ) ;
					thisVelB.w = thisVelB.w + thisContact.invIB * (cr_rB1P1 + cr_rB2P2); 

					//printf ("thisVelA.vy: %f \n", thisVelA.vy);

					thisImpulse.normalImpulse1 = x.x ; 
					thisImpulse.normalImpulse2 = x.y ; 
					break;
				}
				x.x = 0.0f ; 
				x.y =0.0f;
				vn1 = b.x ; 
				vn2 = b.y ; 
				if (vn1 >=0.0f && vn2 >=0.0f)
				{
					float2 d ;
					d = x - a;  
				    
					// Apply incremental impulse
					float2 P1 , P2 ; 
					P1.x = d.x * thisContact.normal.x ; P1.y = d.x * thisContact.normal.y ; 
					P2.x = d.y * thisContact.normal.x ; P2.y = d.y * thisContact.normal.y ; 

					thisVelA.vx = thisVelA.vx - thisContact.invMassA * (P1.x + P2.x);
					thisVelA.vy = thisVelA.vy - thisContact.invMassA * (P1.y + P2.y);
					float cr_rA1P1 = b2clCross_VV (thisPoints.rA1, P1 ) ; 
					float cr_rA2P2 = b2clCross_VV (thisPoints.rA2, P2 ) ;
					thisVelA.w = thisVelA.w - thisContact.invIA * (cr_rA1P1 + cr_rA2P2); 

					thisVelB.vx = thisVelB.vx + thisContact.invMassB * (P1.x + P2.x);
					thisVelB.vy = thisVelB.vy + thisContact.invMassB * (P1.y + P2.y);
					float cr_rB1P1 = b2clCross_VV (thisPoints.rB1, P1 ) ;
					float cr_rB2P2 = b2clCross_VV (thisPoints.rB2, P2 ) ;
					thisVelB.w = thisVelB.w + thisContact.invIB * (cr_rB1P1 + cr_rB2P2); 
					//printf ("thisVelA.vy: %f \n", thisVelA.vy);

					thisImpulse.normalImpulse1 = x.x ; 
					thisImpulse.normalImpulse2 = x.y ; 
					break;
				}
				break ; 
		   }
	}

    // Copy the results back to the buffers
    impulses[contactIndex] = thisImpulse;
    velocities[thisContact.indexA] = thisVelA;
    velocities[thisContact.indexB] = thisVelB;
}







__kernel void SolveVelocityConstraint(
                                 __global clb2Velocity* velocities,
                                 __global clb2Contact* contacts,
                                 __global clb2Impulse* impulses,
                                 __global clb2Points* points,
								 //__global float* testArray, 
                                 const unsigned int offset,
                                 const unsigned int colorLength
                                 
								 )

{
    unsigned int contactIndex = get_global_id(0) + offset;

    if(contactIndex>=offset+colorLength) return;

    clb2Contact thisContact = contacts[contactIndex];
    clb2Impulse thisImpulse = impulses[contactIndex];
    clb2Points thisPoints = points[contactIndex];
    clb2Velocity thisVelA = velocities[thisContact.indexA];
    clb2Velocity thisVelB = velocities[thisContact.indexB];

    // Calculate the tangent impulse for the first contact point
    float2 dv;
    dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB1.y-thisVelA.vx+thisVelA.w * thisPoints.rA1.y;
    dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB1.x-thisVelA.vy-thisVelA.w * thisPoints.rA1.x;
    
    float vp = dv.x*thisContact.normal.y-dv.y*thisContact.normal.x;
    float lambda = thisPoints.tangentMass1 * (-vp);
    
    float maxFriction = thisContact.friction * thisImpulse.normalImpulse1;
    float newImpulse=clamp(thisImpulse.tangentImpulse1+lambda,-maxFriction,maxFriction);
    lambda=newImpulse-thisImpulse.tangentImpulse1;
    thisImpulse.tangentImpulse1=newImpulse;

//float kTangent = thisContact.invMassA * numA + thisContact.invMassB * numB + thisContact.invIA * numA * rtA * rtA + thisContact.invIB * numB * rtB * rtB;

    
    float2 P; 
    P.x = lambda*thisContact.normal.y;
    P.y = -lambda*thisContact.normal.x;
    
    thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
    thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 
    thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA1.x * P.y - thisPoints.rA1.y * P.x); 
    
    thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
    thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
    thisVelB.w= thisVelB.w+thisContact.invIB * (thisPoints.rB1.x * P.y - thisPoints.rB1.y * P.x);
    
    // Calculate the tangent impulse for the second contact point if there is the second contact point
    if(thisPoints.normalMass2>=0)
	{
        dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB2.y-thisVelA.vx+thisVelA.w * thisPoints.rA2.y;
        dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB2.x-thisVelA.vy-thisVelA.w * thisPoints.rA2.x;
        
        vp = dv.x*thisContact.normal.y-dv.y*thisContact.normal.x;
        lambda = thisPoints.tangentMass2 * (-vp);
        
        maxFriction = thisContact.friction * thisImpulse.normalImpulse2;
        newImpulse=clamp(thisImpulse.tangentImpulse2+lambda,-maxFriction,maxFriction);
        lambda=newImpulse-thisImpulse.tangentImpulse2;
        thisImpulse.tangentImpulse2=newImpulse;
        
        P.x = lambda*thisContact.normal.y;
        P.y = -lambda*thisContact.normal.x;
        
        thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
        thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 
        thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA2.x * P.y - thisPoints.rA2.y * P.x); 
        
        thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
        thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
        thisVelB.w= thisVelB.w+thisContact.invIB * (thisPoints.rB2.x * P.y - thisPoints.rB2.y * P.x);
    }
    
    // Calculate the normal impulse for the first contact point
    dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB1.y-thisVelA.vx+thisVelA.w * thisPoints.rA1.y;
    dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB1.x-thisVelA.vy-thisVelA.w * thisPoints.rA1.x;
    
    vp = dv.x*thisContact.normal.x+dv.y*thisContact.normal.y;
    lambda = -thisPoints.normalMass1 * (vp-thisPoints.velocityBias1);
    
    newImpulse=fmax(thisImpulse.normalImpulse1+lambda,0);
    lambda=newImpulse-thisImpulse.normalImpulse1;
    thisImpulse.normalImpulse1=newImpulse;
    
    P.x = lambda*thisContact.normal.x;
    P.y = lambda*thisContact.normal.y;
    
    thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
    thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 
    thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA1.x * P.y - thisPoints.rA1.y * P.x); 

	 
    
    thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
    thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
    thisVelB.w= thisVelB.w+thisContact.invIB * (thisPoints.rB1.x * P.y - thisPoints.rB1.y * P.x);
	//testArray[7] = thisVelA.w ; testArray[8] = thisVelB.w ; testArray[9] = P.y ;testArray[10]= thisVelB.vy; 

	//testArray[0] = thisVelA.w ; testArray[1] = thisVelB.w ;

  // testArray[contactIndex* 20+0] = P.x ; testArray[contactIndex* 20+1] = P.y ;
 //  testArray[contactIndex* 20+2] = 0 -thisContact.invMassB * P.x; testArray[contactIndex* 20+3] = 0 - thisContact.invMassB * P.y; 
    
    // Calculate the normal impulse for the second contact point if there is the second contact point
    if(thisPoints.normalMass2>=0)
	{
        dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB2.y-thisVelA.vx+thisVelA.w * thisPoints.rA2.y;
        dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB2.x-thisVelA.vy-thisVelA.w * thisPoints.rA2.x;
        
        vp = dv.x*thisContact.normal.x+dv.y*thisContact.normal.y;
        lambda = -thisPoints.normalMass2 * (vp-thisPoints.velocityBias2);
    
        newImpulse=fmax(thisImpulse.normalImpulse2+lambda,0);
        lambda=newImpulse-thisImpulse.normalImpulse2;
        thisImpulse.normalImpulse2=newImpulse;
        
        P.x = lambda*thisContact.normal.x;
        P.y = lambda*thisContact.normal.y;
        
        thisVelA.vx = thisVelA.vx-thisContact.invMassA * P.x; 
        thisVelA.vy = thisVelA.vy-thisContact.invMassA * P.y; 
        thisVelA.w = thisVelA.w-thisContact.invIA * (thisPoints.rA2.x * P.y - thisPoints.rA2.y * P.x); 
        
        thisVelB.vx = thisVelB.vx+thisContact.invMassB * P.x; 
        thisVelB.vy = thisVelB.vy+thisContact.invMassB * P.y; 
        thisVelB.w = thisVelB.w+thisContact.invIB * (thisPoints.rB2.x * P.y - thisPoints.rB2.y * P.x);
    }
    
    // Copy the results back to the buffers
    impulses[contactIndex] = thisImpulse;
    velocities[thisContact.indexA] = thisVelA;
    velocities[thisContact.indexB] = thisVelB;
}









__kernel void SolveSplitImpulseVelocityConstraint(
                                 __global clb2Velocity* velocities,
								 //__global clb2Velocity* oldVelocities,
								 __global clb2Velocity* splitVelocities,
                                 __global clb2Contact* contacts,
                                 __global clb2Impulse* impulses,
								// __global clb2Impulse* splitImpulses, 
                                 __global clb2Points* points,
								 //__global float* testBuffer, 
								 __global unsigned int* numContacts4EachBody,
								 __global unsigned int* indexContact2BodySplitVelocity,
								 unsigned int contactCount  
								 
								 //unsigned int lastIter
                                )
{
    unsigned int contactIndex = get_global_id(0);
	if (contactIndex >= contactCount) return ; 

    clb2Contact thisContact = contacts[contactIndex];
	clb2Impulse thisOldImpulse = impulses[contactIndex];  
    clb2Points thisPoints = points[contactIndex];

    clb2Velocity thisVelA = velocities[thisContact.indexA];
    clb2Velocity thisVelB = velocities[thisContact.indexB];

	//clb2Velocity thisOldVelA = oldVelocities[thisContact.indexA];
	//clb2Velocity thisOldVelB = oldVelocities[thisContact.indexB];

		/////////////////////////////////////
	//make invIB small
	//thisContact.invIA = thisContact.invIB = 1 ; 

	/////////////////////////////////////


	unsigned int indexContact2BodyA = indexContact2BodySplitVelocity[contactIndex*2+0];
	unsigned int indexContact2BodyB = indexContact2BodySplitVelocity[contactIndex*2+1]; 
	int numBodyA = numContacts4EachBody [thisContact.indexA];
	int numBodyB = numContacts4EachBody [thisContact.indexB];
	int maxContactNumPerBody = 20 ;
	bool isGround[2] ; isGround[0] = thisContact.invMassA == 0 ? true:false ; isGround[1] = thisContact.invMassB == 0 ? true: false ; 
	if (isGround[0])  { thisPoints.rA1.x = thisPoints.rA1.y = thisPoints.rA2.x = thisPoints.rA2.y = 0 ; } 
	if (isGround[1])  { thisPoints.rB1.x = thisPoints.rB1.y = thisPoints.rB2.x = thisPoints.rB2.y = 0 ; }

	clb2Impulse thisImpulse; 
	thisImpulse = impulses[contactIndex]; 

    // update old velocities using this new velocities. 
	//oldVelocities[thisContact.indexA] = thisVelA ; oldVelocities[thisContact.indexB] = thisVelB ;
	// update old impulse using this new impulse. 
	impulses[contactIndex] = thisImpulse ; 

    clb2Velocity deltaVA, deltaVB ; 
	deltaVA.vx = deltaVA.vy = deltaVA.w =0 ; deltaVB.vx = deltaVB.vy = deltaVB.w = 0 ; 

    // Calculate the tangent impulse for the first contact point
    float2 dv;
    dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB1.y-thisVelA.vx+thisVelA.w * thisPoints.rA1.y;
    dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB1.x-thisVelA.vy-thisVelA.w * thisPoints.rA1.x;

	
    
    float vp = dv.x*thisContact.normal.y-dv.y*thisContact.normal.x;
    float lambda = thisPoints.tangentMass1 * (-vp);
    
    float maxFriction = thisContact.friction * thisImpulse.normalImpulse1;
    float newImpulse=clamp(thisImpulse.tangentImpulse1+lambda,-maxFriction,maxFriction);
    lambda=newImpulse-thisImpulse.tangentImpulse1;
    thisImpulse.tangentImpulse1=newImpulse;
    
    float2 P; 
    P.x = lambda*thisContact.normal.y;
    P.y = -lambda*thisContact.normal.x;
	float delta_x, delta_y, delta_w ; 


	//delta_x = thisContact.invMassA * P.x  ; delta_y = thisContact.invMassA * P.y ; delta_w = thisContact.invIA * (thisPoints.rA1.x * P.y - thisPoints.rA1.y * P.x) ; 

	delta_x = thisContact.invMassA*numBodyA * P.x  ; delta_y = thisContact.invMassA *numBodyA * P.y ; delta_w = thisContact.invIA*numBodyA * (thisPoints.rA1.x * P.y - thisPoints.rA1.y * P.x) ; 
	deltaVA.vx -= delta_x ; deltaVA.vy -= delta_y ; deltaVA.w -= delta_w ; 
	thisVelA.vx -= delta_x ; thisVelA.vy -= delta_y ; thisVelA.w -= delta_w ; 
	 
	//delta_x = thisContact.invMassB  * P.x ; delta_y = thisContact.invMassB  * P.y; delta_w = thisContact.invIB * (thisPoints.rB1.x * P.y - thisPoints.rB1.y * P.x) ; 
	delta_x = thisContact.invMassB *numBodyB * P.x ; delta_y = thisContact.invMassB *numBodyB * P.y; delta_w = thisContact.invIB*numBodyB * (thisPoints.rB1.x * P.y - thisPoints.rB1.y * P.x) ; 
    deltaVB.vx += delta_x ; deltaVB.vy += delta_y ; deltaVB.w += delta_w ; 
	thisVelB.vx += delta_x ; thisVelB.vy += delta_y ; thisVelB.w += delta_w ;  
    
    // Calculate the tangent impulse for the second contact point if there is the second contact point
	
    if(thisPoints.normalMass2>=0)
	{
        dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB2.y-thisVelA.vx+thisVelA.w * thisPoints.rA2.y;
        dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB2.x-thisVelA.vy-thisVelA.w * thisPoints.rA2.x;
        
        vp = dv.x*thisContact.normal.y-dv.y*thisContact.normal.x;
        lambda = thisPoints.tangentMass2 * (-vp);
        
        maxFriction = thisContact.friction * thisImpulse.normalImpulse2;
        newImpulse=clamp(thisImpulse.tangentImpulse2+lambda,-maxFriction,maxFriction);
        lambda=newImpulse-thisImpulse.tangentImpulse2;
        thisImpulse.tangentImpulse2=newImpulse;
        
        P.x = lambda*thisContact.normal.y;
        P.y = -lambda*thisContact.normal.x;
        

	 // delta_x = thisContact.invMassA * P.x ; delta_y = thisContact.invMassA * P.y ; delta_w = thisContact.invIA * (thisPoints.rA2.x * P.y - thisPoints.rA2.y * P.x);   
	 delta_x = thisContact.invMassA *numBodyA * P.x ; delta_y = thisContact.invMassA *numBodyA * P.y ; delta_w = thisContact.invIA *numBodyA * (thisPoints.rA2.x * P.y - thisPoints.rA2.y * P.x);  
      deltaVA.vx -= delta_x ; deltaVA.vy -= delta_y ; deltaVA.w -= delta_w; 
	  thisVelA.vx -= delta_x ; thisVelA.vy -= delta_y ; thisVelA.w -= delta_w ; 

	 // delta_x = thisContact.invMassB * P.x ; delta_y = thisContact.invMassB * P.y ; delta_w = thisContact.invIB * (thisPoints.rB2.x * P.y - thisPoints.rB2.y * P.x) ; 
	 delta_x = thisContact.invMassB * numBodyB * P.x ; delta_y = thisContact.invMassB * numBodyB*  P.y ; delta_w = thisContact.invIB * numBodyB *  (thisPoints.rB2.x * P.y - thisPoints.rB2.y * P.x) ; 
	  deltaVB.vx += delta_x ; deltaVB.vy += delta_y; deltaVB.w += delta_w ; 
	  thisVelB.vx += delta_x ; thisVelB.vy += delta_y ; thisVelB.w += delta_w ; 
	  
	
    }
    

    // Calculate the normal impulse for the first contact point
    dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB1.y-thisVelA.vx+thisVelA.w * thisPoints.rA1.y;
    dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB1.x-thisVelA.vy-thisVelA.w * thisPoints.rA1.x;
	   
    //printf ("this Impulse lambda: %f \n", thisImpulse.normalImpulse1);
	//printf ("dv.y: %f \n", dv.y);

    vp = dv.x*thisContact.normal.x+dv.y*thisContact.normal.y;
	
    lambda = -thisPoints.normalMass1 * (vp-thisPoints.velocityBias1);
	//printf ("this Impulse lambda: %f \n", lambda);
   // printf ("normalMass1: %f \n", thisPoints.normalMass1);

	float lv = 1.0 ; 

    newImpulse=fmax(thisImpulse.normalImpulse1+lambda,0);
    lambda=newImpulse-thisImpulse.normalImpulse1;
    thisImpulse.normalImpulse1=newImpulse;

    
    P.x = lambda*thisContact.normal.x;
    P.y = lambda*thisContact.normal.y; 
  
	
	//delta_x = thisContact.invMassA * P.x; delta_y = thisContact.invMassA * P.y ; delta_w = thisContact.invIA * (thisPoints.rA1.x * P.y - thisPoints.rA1.y * P.x) ; 
	delta_x = thisContact.invMassA *numBodyA * P.x; delta_y = thisContact.invMassA * numBodyA * P.y ; delta_w = thisContact.invIA *numBodyA * (thisPoints.rA1.x * P.y - thisPoints.rA1.y * P.x) ; 
    deltaVA.vx -= delta_x ; deltaVA.vy -= delta_y ; deltaVA.w -= delta_w ; 
	thisVelA.vx -= delta_x ; thisVelA.vy -= delta_y ; thisVelA.w -= delta_w ; 

	//printf ("P_y: %f \n", P.y);

	//delta_x = thisContact.invMassB * P.x ; delta_y = thisContact.invMassB * P.y ; delta_w = thisContact.invIB * (thisPoints.rB1.x * P.y - thisPoints.rB1.y * P.x) ; 
	delta_x = thisContact.invMassB * numBodyB * P.x ; delta_y = thisContact.invMassB * numBodyB * P.y ; delta_w = thisContact.invIB * numBodyB* (thisPoints.rB1.x * P.y - thisPoints.rB1.y * P.x) ; 
    deltaVB.vx += delta_x ; deltaVB.vy += delta_y ; deltaVB.w += delta_w ; 
	thisVelB.vx += delta_x ; thisVelB.vy += delta_y ; thisVelB.w += delta_w ;
	
	 
	              	 
    // Calculate the normal impulse for the second contact point if there is the second contact point
	
    if(thisPoints.normalMass2>=0)
	{
	
        dv.x = thisVelB.vx-thisVelB.w * thisPoints.rB2.y-thisVelA.vx+thisVelA.w * thisPoints.rA2.y;
        dv.y = thisVelB.vy+thisVelB.w * thisPoints.rB2.x-thisVelA.vy-thisVelA.w * thisPoints.rA2.x;
        
        vp = dv.x*thisContact.normal.x+dv.y*thisContact.normal.y;
        lambda = -thisPoints.normalMass2 * (vp-thisPoints.velocityBias2);
		//printf ("this Impulse lambda: %f \n", lambda);
        

        newImpulse=fmax(thisImpulse.normalImpulse2+lambda,0);	
        lambda=newImpulse-thisImpulse.normalImpulse2;
        thisImpulse.normalImpulse2=newImpulse;
        
        P.x = lambda*thisContact.normal.x;
        P.y = lambda*thisContact.normal.y;


     // delta_x = thisContact.invMassA * P.x; delta_y = thisContact.invMassA * P.y ; delta_w = thisContact.invIA * (thisPoints.rA2.x * P.y - thisPoints.rA2.y * P.x) ; 
	 delta_x = thisContact.invMassA * numBodyA * P.x; delta_y = thisContact.invMassA * numBodyA*  P.y ; delta_w = thisContact.invIA * numBodyA * (thisPoints.rA2.x * P.y - thisPoints.rA2.y * P.x) ; 
      deltaVA.vx -= delta_x ; deltaVA.vy -= delta_y ; deltaVA.w -= delta_w ; 
	  thisVelA.vx -= delta_x ; thisVelA.vy -= delta_y ; thisVelA.w -= delta_w; 
	  
	  //delta_x = thisContact.invMassB * P.x ; delta_y = thisContact.invMassB * P.y; delta_w = thisContact.invIB * (thisPoints.rB2.x * P.y - thisPoints.rB2.y * P.x);
	  delta_x = thisContact.invMassB * numBodyB * P.x ; delta_y = thisContact.invMassB * numBodyB * P.y; delta_w = thisContact.invIB * numBodyB * (thisPoints.rB2.x * P.y - thisPoints.rB2.y * P.x);
      deltaVB.vx += delta_x ; deltaVB.vy += delta_y ; deltaVB.w += delta_w ; 
	  thisVelB.vx += delta_x ; thisVelB.vy += delta_y ; thisVelB.w += delta_w ; 	  
    }
    // Copy the results back to the buffers

	if (!isGround[0]) {
		//deltaVA.vx *= numBodyA ; deltaVA.vy *= numBodyA ; deltaVA.w *= numBodyA ; 
		splitVelocities [thisContact.indexA * maxContactNumPerBody + indexContact2BodyA] = deltaVA ; 
		//printf ("numBodyA: %f , \n", numBodyA) ; 
	}
	if (!isGround[1]) {
		//deltaVB.vx *= numBodyB ; deltaVB.vy *= numBodyB ; deltaVB.w *= numBodyB ; 
		splitVelocities [thisContact.indexB * maxContactNumPerBody + indexContact2BodyB] = deltaVB ; 
		//printf ("deltaB.vy: %f , \n", deltaVB.vy) ; 	
	}
  
    impulses[contactIndex] = thisImpulse;
	//printf ("thisImpulse: %f , \n", thisImpulse.normalImpulse1) ; 
}





__kernel void SolveMergeVelocityConstraint(
                                 __global clb2Velocity* velocities,
								 __global clb2Velocity* splitVelocities,
                                 __global clb2Contact* contacts,
                                 __global clb2Impulse* impulses,
                                 __global clb2Points* points,
								 __global unsigned int* numContacts4EachBody,
								 __global unsigned int* indexContact2BodySplitVelocity,
								 const uint bodyCount
                                )
{

    unsigned int bodyIndex = get_global_id(0);
	if (bodyIndex >= bodyCount) return ; 
	clb2Velocity thisBodyVelocity = velocities[bodyIndex];
	unsigned int numContacts4Body = numContacts4EachBody[bodyIndex]; 
	clb2Velocity  deltaMergedVelocity; deltaMergedVelocity.vx = deltaMergedVelocity.vy = deltaMergedVelocity.w = 0 ; 
	//__global clb2Velocity* pDeltaSplitVelocity  ; 
	clb2Velocity  thisSplitVelocity ; 

	int maxContactNumPerBody = 20 ; 
	for ( int i = 0 ; i < numContacts4Body; i ++ ) {
		thisSplitVelocity = splitVelocities[bodyIndex*maxContactNumPerBody+i] ; 
		deltaMergedVelocity.vx += thisSplitVelocity.vx ; deltaMergedVelocity.vy += thisSplitVelocity.vy ; deltaMergedVelocity.w += thisSplitVelocity.w ;
		//printf ("SplitedVelocitySpeed: %f \n", thisSplitVelocity.vy);  
	} 
	if (numContacts4Body > 0 ) {
		deltaMergedVelocity.vx /= numContacts4Body; deltaMergedVelocity.vy /= numContacts4Body ;  	deltaMergedVelocity.w /= numContacts4Body ;
	} 
	thisBodyVelocity.vx += deltaMergedVelocity.vx ; 
	thisBodyVelocity.vy += deltaMergedVelocity.vy ;
	thisBodyVelocity.w += deltaMergedVelocity.w ;
	velocities[bodyIndex] = thisBodyVelocity; 
	//printf ("MergeVelocitySpeed: %f \n", thisBodyVelocity.vy); 

}






__kernel void SynchronizeXf(
							__global b2clTransform* xfGlobal, // output
                            __global clb2Position* positions,
							const __global b2clBodyStatic* bodyStaticListBuffer,
							__global b2clBodyDynamic* bodyDynamicListBuffer,
                            const unsigned int num_body)
{
    unsigned int i = get_global_id(0);

    if(i >= num_body) return;

	b2clBodyStatic bs = bodyStaticListBuffer[i];
	__global b2clBodyDynamic* bd = bodyDynamicListBuffer + i;

	float2 c;
	c.x = positions[i].cx;
	c.y = positions[i].cy;
	float a = positions[i].a;

	// synchronize xf for each body
	float2 p, q;
	
	float sina, cosa;
	sina = sincos(a, &cosa);
	q.x = sina;
	q.y = cosa; 
	//q.x = /*native_*/sin(a);
	//q.y = cos(a);
	//q.y = cos_wrapper(a);
	p = c - b2clMul_Rotate(q, bs.m_localCenter);
	xfGlobal[i].p = p;
	xfGlobal[i].q = q;

	bd->m_sweep.c = c;
	bd->m_sweep.a = a;
}

__kernel void ReadLastImpulses(
                                 __global clb2Impulse* impulses, // output
								 __global uint* lastManifoldKeys, // input, sorted keys
								 __global uint* lastGlobalIndices, // input, sorted values
								 const unsigned int lastContactCount,
                                 const unsigned int contactCount,
						const __global int4* indices, //indices to bodies and fixtures
						const __global int* coloredContactIndexToContactIndexMap,
						const __global b2clManifold* manifolds,
						const __global b2clManifold* lastManifolds,
						const int warmStarting,
						const float dtRatio)
{
    unsigned int contactIndex = get_global_id(0);

    if(contactIndex >= contactCount) return;

	clb2Impulse currentImpulses;

	if (!warmStarting)
	{
		currentImpulses.normalImpulse1 = 0.0f;
		currentImpulses.tangentImpulse1 = 0.0f;
		currentImpulses.normalImpulse2 = 0.0f;
		currentImpulses.tangentImpulse2 = 0.0f;

		impulses[contactIndex] = currentImpulses;

		return;
	}

    int globalIndex = coloredContactIndexToContactIndexMap[contactIndex];
	int4 currentIndices = indices[globalIndex];


	int currentKey;
	if (currentIndices.x<currentIndices.y)
		currentKey = currentIndices.x<<16 | currentIndices.y; // suppose both indices are less than 65536 and thus fit in 16 bits.
	else
		currentKey = currentIndices.y<<16 | currentIndices.x; // suppose both indices are less than 65536 and thus fit in 16 bits.

	//if (currentIndices.z<currentIndices.w)
	//	currentKey = currentIndices.z<<16 | currentIndices.w; // suppose both indices are less than 65536 and thus fit in 16 bits.
	//else
	//	currentKey = currentIndices.w<<16 | currentIndices.z; // suppose both indices are less than 65536 and thus fit in 16 bits.

	// binary saerch currentKey in lastManifoldKeys
	int lb = 0; // low bound
	int ub = lastContactCount-1; // upper bound
	int mid;
	bool bFound = false;
	uint midKey;
	//if (lastManifoldKeys[lb]<currentKey || lastManifoldKeys[ub]>currentKey)
	//	// currentKey not in lastManifoldKeys
	//	bFound = false;
	//else // do binary search
	{
		for (; lb<ub; )
		{
			mid = (lb+ub)/2;
			midKey = lastManifoldKeys[mid];
			if (midKey==currentKey)
			{
				bFound = true;
				break;
			}
			else if (midKey<currentKey)
			{
				ub = mid-1;
			}
			else
			{
				lb = mid+1;
			}
		}
		if (ub<lb)
			bFound = false;
	}
	if (lb==ub)
	{
		mid = lb;
      //  if (currentKey == lastManifoldKeys[mid] ) bFound = true ; 
	   // else bFound = false;
		bFound = true;
	}

	if (bFound)
	{
		//printf ("bFound! \n" ); 
		b2clManifold currentManifold = manifolds[globalIndex];
		for (int k = 0; k < currentManifold.pointCount; ++k)
		{
			b2clManifoldPoint* mp2 = currentManifold.points + k;
			mp2->normalImpulse = 0.0f;
			mp2->tangentImpulse = 0.0f;
			int key2 = mp2->id.key;

			int lastGlobalIndex = lastGlobalIndices[mid];
			b2clManifold lastManifold = lastManifolds[lastGlobalIndex];
			//printf("last global index: %d\n", lastGlobalIndex);
			for (int j = 0; j < lastManifold.pointCount; ++j)
			{
				b2clManifoldPoint* mp1 = lastManifold.points + j;

				//if (mp1->id.key == key2)
				//{
					mp2->normalImpulse = mp1->normalImpulse;
					mp2->tangentImpulse = mp1->tangentImpulse;
					break;
				//}
			}
		}

		currentImpulses.normalImpulse1 = dtRatio * currentManifold.points[0].normalImpulse;
		currentImpulses.tangentImpulse1 = dtRatio * currentManifold.points[0].tangentImpulse;
		//printf ("ReadImpulse : %f \n" , currentImpulses.normalImpulse1 ) ;
		if (currentManifold.pointCount>1)
		{
			currentImpulses.normalImpulse2 = dtRatio * currentManifold.points[1].normalImpulse;
			currentImpulses.tangentImpulse2 = dtRatio * currentManifold.points[1].tangentImpulse;
		}
	}
	else
	{
		currentImpulses.normalImpulse1 = 0.0f;
		currentImpulses.tangentImpulse1 = 0.0f;
		currentImpulses.normalImpulse2 = 0.0f;
		currentImpulses.tangentImpulse2 = 0.0f;
	}

	impulses[contactIndex] = currentImpulses;
}

__kernel void ReadLastImpulsesFirstFrame(
                                 __global clb2Impulse* impulses, // output
								 __global uint* lastManifoldKeys, // input, sorted keys
								 __global uint* lastGlobalIndices, // input, sorted values
                                 //__global clb2Position* positions, // for debug
								 const unsigned int lastContactCount,
                                 const unsigned int contactCount,
						const __global int4* indices, //indices to bodies and fixtures
						const __global b2clFixtureStatic* fixtureStaticListBuffer,
						const __global int* coloredContactIndexToContactIndexMap,
						const __global b2clManifold* manifolds,
						const __global b2clManifold* lastManifolds,
						const int warmStarting,
						const float dtRatio)
{
    unsigned int contactIndex = get_global_id(0);

    if(contactIndex >= contactCount) return;

	clb2Impulse currentImpulses;

	if (!warmStarting)
	{
		currentImpulses.normalImpulse1 = 0.0f;
		currentImpulses.tangentImpulse1 = 0.0f;
		currentImpulses.normalImpulse2 = 0.0f;
		currentImpulses.tangentImpulse2 = 0.0f;

		impulses[contactIndex] = currentImpulses;

		return;
	}

    int globalIndex = coloredContactIndexToContactIndexMap[contactIndex];
	int4 currentIndices = indices[globalIndex];
	//// for debug
	//clb2Position thisPos = positions[currentIndices.z];

	// binary saerch currentKey in lastManifoldKeys
	int lb = 0; // low bound
	int ub = lastContactCount-1; // upper bound
	int mid;
	bool bFound = false;
	uint midKey;
	int currentKey;
	//if (currentIndices.x<currentIndices.y)
	//	currentKey = currentIndices.x<<16 | currentIndices.y; // suppose both indices are less than 65536 and thus fit in 16 bits.
	//else
	//	currentKey = currentIndices.y<<16 | currentIndices.x; // suppose both indices are less than 65536 and thus fit in 16 bits.

	//printf("currentIndex: (%d, %d)\n", currentIndices.x, currentIndices.y);
	int2 lastIndices;
	lastIndices.x = fixtureStaticListBuffer[currentIndices.x].m_last_uid;
	lastIndices.y = fixtureStaticListBuffer[currentIndices.y].m_last_uid;
	//printf("lastIndex: (%d, %d)\n", lastIndices.x, lastIndices.y);

	if (lastIndices.x>=0 && lastIndices.y>=0)
	{
		if (lastIndices.x<lastIndices.y)
			currentKey = lastIndices.x<<16 | lastIndices.y; // suppose both indices are less than 65536 and thus fit in 16 bits.
		else
			currentKey = lastIndices.y<<16 | lastIndices.x; // suppose both indices are less than 65536 and thus fit in 16 bits.

		//if (lastManifoldKeys[lb]<currentKey || lastManifoldKeys[ub]>currentKey)
		//	// currentKey not in lastManifoldKeys
		//	bFound = false;
		//else // do binary search
		{
			for (; lb<ub; )
			{
				mid = (lb+ub)/2;
				midKey = lastManifoldKeys[mid];
				if (midKey==currentKey)
				{
					bFound = true;
					break;
				}
				else if (midKey<currentKey)
				{
					ub = mid-1;
				}
				else
				{
					lb = mid+1;
				}
			}
			if (ub<lb)
				bFound = false;
		}
		if (lb==ub)
		{
			mid = lb;
			bFound = true;
		}
	}

	if (bFound)
	{
		//if (/*get_global_id(0)<10 && */thisPos.cx<100 && lastIndices.x==398 && lastIndices.y==397)
		//	printf("Found!!!\n");
		b2clManifold currentManifold = manifolds[globalIndex];
		for (int k = 0; k < currentManifold.pointCount; ++k)
		{
			b2clManifoldPoint* mp2 = currentManifold.points + k;
			mp2->normalImpulse = 0.0f;
			mp2->tangentImpulse = 0.0f;
			int key2 = mp2->id.key;

			int lastGlobalIndex = lastGlobalIndices[mid];
			b2clManifold lastManifold = lastManifolds[lastGlobalIndex];
			//printf("last global index: %d\n", lastGlobalIndex);
			for (int j = 0; j < lastManifold.pointCount; ++j)
			{
				b2clManifoldPoint* mp1 = lastManifold.points + j;

				if (mp1->id.key == key2)
				{
					mp2->normalImpulse = mp1->normalImpulse;
					mp2->tangentImpulse = mp1->tangentImpulse;
					//if (/*get_global_id(0)<10 && */thisPos.cx<100 && lastIndices.x==398 && lastIndices.y==397)
					//	printf("key2:%d, normalImpuls: %f, tangentImpulse: %f\n", key2, mp1->normalImpulse, mp1->tangentImpulse);
					break;
				}
			}
		}

		currentImpulses.normalImpulse1 = dtRatio * currentManifold.points[0].normalImpulse;
		currentImpulses.tangentImpulse1 = dtRatio * currentManifold.points[0].tangentImpulse;
		if (currentManifold.pointCount>1)
		{
			currentImpulses.normalImpulse2 = dtRatio * currentManifold.points[1].normalImpulse;
			currentImpulses.tangentImpulse2 = dtRatio * currentManifold.points[1].tangentImpulse;
		}
	}
	else
	{
		//printf("Not Found!!!\n");
		currentImpulses.normalImpulse1 = 0.0f;
		currentImpulses.tangentImpulse1 = 0.0f;
		currentImpulses.normalImpulse2 = 0.0f;
		currentImpulses.tangentImpulse2 = 0.0f;
	}

	impulses[contactIndex] = currentImpulses;

	//// for debug
	//if (/*get_global_id(0)<10 && */thisPos.cx<100 && lastIndices.x==398 && lastIndices.y==397)
	//	printf("Impulse %d: (%f, %f)\n", contactIndex, currentImpulses.normalImpulse1, currentImpulses.tangentImpulse1);
	//	//printf("thisPos.cx: %f\n", thisPos.cx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// InitializeDistanceJointVelocityConstraint
//
// Initialize values of Distance joints for the solver computation.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void InitializeDistanceJointVelocityConstraint(
						__global clb2Velocity* velocities,
						const __global clb2Position* positions,
						const __global b2clBodyStatic* bodyStaticListBuffer,
						const __global b2clTransform* xfGlobal,
						__global b2clJoint* jointListBuffer,
						//int numContact, 
						int warmStarting,
						float dt,
						float dtRatio,
						const unsigned int offset,
						const unsigned int colorLength 
						//__global testData* testBuffer 
						)
{
    unsigned int contactIndex = get_global_id(0) + offset;
    if(contactIndex>=offset+colorLength) return;

	//printf ("Initialize Distance JOint \n");

	b2clJoint thisJoint = jointListBuffer[contactIndex]; 
	b2clBodyStatic bodyStaticA = bodyStaticListBuffer[thisJoint.indexA];
	b2clBodyStatic bodyStaticB = bodyStaticListBuffer[thisJoint.indexB];

	
 
	b2clTransform xfA = xfGlobal[thisJoint.indexA];
	b2clTransform xfB = xfGlobal[thisJoint.indexB];

	clb2Position positionA = positions[thisJoint.indexA]; clb2Velocity velocityA = velocities[thisJoint.indexA];  
	clb2Position positionB = positions[thisJoint.indexB]; clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 cA =  (float2)(positionA.cx, positionA.cy);   float aA = positionA.a;
	float2 vA =  (float2)(velocityA.vx, velocityA.vy);   float wA = velocityA.w;
	float2 cB =  (float2)(positionB.cx, positionB.cy);  float aB = positionB.a;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy);  float wB = velocityB.w;


	

	// Can this part move to the copyJoint function? 
	float2 m_localAnchorA = (float2) (thisJoint.b.distanceJointData.localAnchorA[0] , thisJoint.b.distanceJointData.localAnchorA[1]);
	float2 m_localAnchorB = (float2) (thisJoint.b.distanceJointData.localAnchorB[0] , thisJoint.b.distanceJointData.localAnchorB[1]);
	float2 m_localCenterA = (float2) (bodyStaticA.m_localCenter.x, bodyStaticA.m_localCenter.y);
	float2 m_localCenterB = (float2) (bodyStaticB.m_localCenter.x, bodyStaticB.m_localCenter.y);
	thisJoint.b.distanceJointData.localCenterA[0] = m_localCenterA.x;
	thisJoint.b.distanceJointData.localCenterA[1] = m_localCenterA.y;
	thisJoint.b.distanceJointData.localCenterB[0] = m_localCenterB.x;
	thisJoint.b.distanceJointData.localCenterB[1] = m_localCenterB.y;
	thisJoint.b.distanceJointData.invMassA = bodyStaticA.m_invMass;
	thisJoint.b.distanceJointData.invMassB = bodyStaticB.m_invMass; 
	thisJoint.b.distanceJointData.invIA = bodyStaticA.m_invI;
	thisJoint.b.distanceJointData.invIB = bodyStaticB.m_invI;
 
	float2 m_rA = b2clMul_Rotate( xfA.q, m_localAnchorA - m_localCenterA);
	float2 m_rB = b2clMul_Rotate( xfB.q, m_localAnchorB - m_localCenterB);


    float2 m_u =  cB + m_rB - cA - m_rA ; 


	
	float length = b2clDot ( m_u, m_u ) ; length = sqrt (length); 


	if (length > b2_linearSlop)
	{
		m_u *= 1.0f/length ; 
	}
	else{
		m_u.x = m_u.y = 0 ; 
	}
 
	float crAu = b2clCross_VV(m_rA, m_u); 
	float crBu = b2clCross_VV(m_rB, m_u);

	float invMass = thisJoint.b.distanceJointData.invMassA + thisJoint.b.distanceJointData.invIA*crAu*crAu + thisJoint.b.distanceJointData.invMassB + thisJoint.b.distanceJointData.invIB*crBu*crBu;
 

	thisJoint.b.distanceJointData.mass = invMass != 0.0f ? 1.0f /invMass :0.0f ; 
	if (thisJoint.b.distanceJointData.frequencyHz > 0.0f) {
		float C = length - thisJoint.b.distanceJointData.nlength ; 

		float omega = 2.0f*b2_pi * thisJoint.b.distanceJointData.frequencyHz;
		float d = 2.0f * thisJoint.b.distanceJointData.mass * thisJoint.b.distanceJointData.dampingRatio * omega;
		float k = thisJoint.b.distanceJointData.mass * omega * omega ; 
		float h = dt ; 
		thisJoint.b.distanceJointData.gamma = h * (d + h * k);
		thisJoint.b.distanceJointData.gamma = thisJoint.b.distanceJointData.gamma != 0.0f ? 1.0f / thisJoint.b.distanceJointData.gamma :0.0f ; 
		thisJoint.b.distanceJointData.bias = C * h * k * thisJoint.b.distanceJointData.gamma; 
		invMass += thisJoint.b.distanceJointData.gamma ; 
		thisJoint.b.distanceJointData.mass = invMass != 0.0f ?1.0f/invMass :0.0f ;  
	}
	else {
		thisJoint.b.distanceJointData.gamma = 0.0f;
		thisJoint.b.distanceJointData.bias = 0.0f ; 
	}
	if (warmStarting){
		// Scale the impulse to support a variable time step.
		thisJoint.a.y.scalarImpulse *= dtRatio;

		float2 P = thisJoint.a.y.scalarImpulse * m_u;
		vA -= thisJoint.b.distanceJointData.invMassA * P;
		wA -= thisJoint.b.distanceJointData.invIA * b2clCross_VV(m_rA, P);
		vB += thisJoint.b.distanceJointData.invMassB * P;
		wB += thisJoint.b.distanceJointData.invIB * b2clCross_VV(m_rB, P);

		velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
		velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB;
	}
	else {
		thisJoint.a.y.scalarImpulse = 0.0f ; 
	}
	thisJoint.b.distanceJointData.rA[0] = m_rA.x ; thisJoint.b.distanceJointData.rA[1] = m_rA.y ; 
	thisJoint.b.distanceJointData.rB[0] = m_rB.x ; thisJoint.b.distanceJointData.rB[1] = m_rB.y ; 
    thisJoint.b.distanceJointData.u[0] = m_u.x ;   thisJoint.b.distanceJointData.u[1] = m_u.y ;  
	jointListBuffer[contactIndex] = thisJoint ; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// InitializeRevoluteJointVelocityConstraint
//
// Initialize values of Revolute joints for the solver computation.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void InitializeRevoluteJointVelocityConstraint(
						__global clb2Velocity* velocities,
						const __global clb2Position* positions,
						const __global b2clBodyStatic* bodyStaticListBuffer,
						const __global b2clTransform* xfGlobal,
						__global b2clJoint* jointListBuffer,
						//int numContact, 
					    int warmStarting,
						float dt,
						float dtRatio,
						const unsigned int offset,
						const unsigned int colorLength						
						//__global testData* testBuffer 
						)
{
    unsigned int contactIndex = get_global_id(0) + offset;
    if(contactIndex>=offset+colorLength) return;


	b2clJoint thisJoint = jointListBuffer[contactIndex]; 
	b2clBodyStatic bodyStaticA = bodyStaticListBuffer[thisJoint.indexA];
	b2clBodyStatic bodyStaticB = bodyStaticListBuffer[thisJoint.indexB];

	b2clTransform xfA = xfGlobal[thisJoint.indexA];
	b2clTransform xfB = xfGlobal[thisJoint.indexB];

	clb2Position positionA = positions[thisJoint.indexA]; clb2Velocity velocityA = velocities[thisJoint.indexA];  
	clb2Position positionB = positions[thisJoint.indexB]; clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 cA =  (float2)(positionA.cx, positionA.cy);   float aA = positionA.a;
	float2 vA =  (float2)(velocityA.vx, velocityA.vy);   float wA = velocityA.w;
	float2 cB =  (float2)(positionB.cx, positionB.cy);  float aB = positionB.a;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy);  float wB = velocityB.w;

	// Can this part move to the copyJoint function? 
	float2 m_localAnchorA = (float2) (thisJoint.b.revoluteJointData.localAnchorA[0] , thisJoint.b.revoluteJointData.localAnchorA[1]);
	float2 m_localAnchorB = (float2) (thisJoint.b.revoluteJointData.localAnchorB[0] , thisJoint.b.revoluteJointData.localAnchorB[1]);
	float2 m_localCenterA = (float2) (bodyStaticA.m_localCenter.x, bodyStaticA.m_localCenter.y);
	float2 m_localCenterB = (float2) (bodyStaticB.m_localCenter.x, bodyStaticB.m_localCenter.y);
	thisJoint.b.revoluteJointData.localCenterA[0] = m_localCenterA.x;
	thisJoint.b.revoluteJointData.localCenterA[1] = m_localCenterA.y;
	thisJoint.b.revoluteJointData.localCenterB[0] = m_localCenterB.x;
	thisJoint.b.revoluteJointData.localCenterB[1] = m_localCenterB.y;
	thisJoint.b.revoluteJointData.invMassA = bodyStaticA.m_invMass;
	thisJoint.b.revoluteJointData.invMassB = bodyStaticB.m_invMass; 
	thisJoint.b.revoluteJointData.invIA = bodyStaticA.m_invI;
	thisJoint.b.revoluteJointData.invIB = bodyStaticB.m_invI;
 
	float2 m_rA = b2clMul_Rotate( xfA.q, m_localAnchorA - m_localCenterA);
	float2 m_rB = b2clMul_Rotate( xfB.q, m_localAnchorB - m_localCenterB);
	
	// J = [-I -r1_skew I r2_skew]
	//     [ 0       -1 0       1]
	// r_skew = [-ry; rx]

	// Matlab
	// K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]
	//     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]
	//     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]

	float mA = thisJoint.b.revoluteJointData.invMassA, mB = thisJoint.b.revoluteJointData.invMassB;
	float iA = thisJoint.b.revoluteJointData.invIA, iB = thisJoint.b.revoluteJointData.invIB;

	bool fixedRotation = (iA + iB == 0.0f);

	thisJoint.b.revoluteJointData.mass.ex[0] = mA + mB + m_rA.y * m_rA.y * iA + m_rB.y * m_rB.y * iB;
	thisJoint.b.revoluteJointData.mass.ey[0] = -m_rA.y * m_rA.x * iA - m_rB.y * m_rB.x * iB;
	thisJoint.b.revoluteJointData.mass.ez[0] = -m_rA.y * iA - m_rB.y * iB;
	thisJoint.b.revoluteJointData.mass.ex[1] = thisJoint.b.revoluteJointData.mass.ey[0];
	thisJoint.b.revoluteJointData.mass.ey[1] = mA + mB + m_rA.x * m_rA.x * iA + m_rB.x * m_rB.x * iB;
	thisJoint.b.revoluteJointData.mass.ez[1] = m_rA.x * iA + m_rB.x * iB;
	thisJoint.b.revoluteJointData.mass.ex[2] = thisJoint.b.revoluteJointData.mass.ez[0];
	thisJoint.b.revoluteJointData.mass.ey[2] = thisJoint.b.revoluteJointData.mass.ez[1];
	thisJoint.b.revoluteJointData.mass.ez[2] = iA + iB;

	thisJoint.b.revoluteJointData.motorMass = iA + iB;
	if (thisJoint.b.revoluteJointData.motorMass > 0.0f)
	{
		thisJoint.b.revoluteJointData.motorMass = 1.0f / thisJoint.b.revoluteJointData.motorMass;
	}

	if (thisJoint.b.revoluteJointData.enableMotor == 0 || fixedRotation)
	{
		thisJoint.motorImpulse = 0.0f;
	}

	if (thisJoint.b.revoluteJointData.enableLimit && fixedRotation == false)
	{
		float jointAngle = aB - aA - thisJoint.b.revoluteJointData.referenceAngle;
		if (b2clAbs(thisJoint.b.revoluteJointData.upperAngle - thisJoint.b.revoluteJointData.lowerAngle) < 2.0f * b2_angularSlop)
		{
			thisJoint.b.revoluteJointData.limitState = e_equalLimits;
		}
		else if (jointAngle <= thisJoint.b.revoluteJointData.lowerAngle)
		{
			if (thisJoint.b.revoluteJointData.limitState != e_atLowerLimit)
			{
				thisJoint.a.x.impulse[2] = 0.0f;
			}
			thisJoint.b.revoluteJointData.limitState = e_atLowerLimit;
		}
		else if (jointAngle >= thisJoint.b.revoluteJointData.upperAngle)
		{
			if (thisJoint.b.revoluteJointData.limitState != e_atUpperLimit)
			{
				thisJoint.a.x.impulse[2] = 0.0f;
			}
			thisJoint.b.revoluteJointData.limitState = e_atUpperLimit;
		}
		else
		{
			thisJoint.b.revoluteJointData.limitState = e_inactiveLimit;
			thisJoint.a.x.impulse[2] = 0.0f;
		}
	}
	else
	{
		thisJoint.b.revoluteJointData.limitState = e_inactiveLimit;
	}

	if (warmStarting)
	{
		// Scale impulses to support a variable time step.
		thisJoint.a.x.impulse[0] *= dtRatio;
		thisJoint.a.x.impulse[1] *= dtRatio;
		thisJoint.a.x.impulse[2] *= dtRatio;
		thisJoint.motorImpulse *= dtRatio;

		float2 P = (float2)(thisJoint.a.x.impulse[0], thisJoint.a.x.impulse[1]);

		vA -= mA * P;
		wA -= iA * (b2clCross_VV(m_rA, P) + thisJoint.motorImpulse + thisJoint.a.x.impulse[2]);

		vB += mB * P;
		wB += iB * (b2clCross_VV(m_rB, P) + thisJoint.motorImpulse + thisJoint.a.x.impulse[2]);

		velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
		velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB;
	}
	else 
	{
		thisJoint.a.x.impulse[0] = 0.0f;
		thisJoint.a.x.impulse[1] = 0.0f;
		thisJoint.a.x.impulse[2] = 0.0f;
		thisJoint.motorImpulse = 0.0f;
	}
	thisJoint.b.revoluteJointData.rA[0] = m_rA.x ; thisJoint.b.revoluteJointData.rA[1] = m_rA.y ; 
	thisJoint.b.revoluteJointData.rB[0] = m_rB.x ; thisJoint.b.revoluteJointData.rB[1] = m_rB.y ; 
	jointListBuffer[contactIndex] = thisJoint ; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// InitializePrismaticJointVelocityConstraint
//
// Initialize values of Prismatic joints for the solver computation.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void InitializePrismaticJointVelocityConstraint(
						__global clb2Velocity* velocities,
						const __global clb2Position* positions,
						const __global b2clBodyStatic* bodyStaticListBuffer,
						const __global b2clTransform* xfGlobal,
						__global b2clJoint* jointListBuffer,
						//int numContact, 
						int warmStarting,
						float dt,
						float dtRatio,
						const unsigned int offset,
						const unsigned int colorLength
						//__global testData* testBuffer 
						)
{


    unsigned int contactIndex = get_global_id(0) + offset;
    if(contactIndex>=offset+colorLength) return;

	b2clJoint thisJoint = jointListBuffer[contactIndex]; 
	b2clBodyStatic bodyStaticA = bodyStaticListBuffer[thisJoint.indexA];
	b2clBodyStatic bodyStaticB = bodyStaticListBuffer[thisJoint.indexB];
	b2clTransform xfA = xfGlobal[thisJoint.indexA];
	b2clTransform xfB = xfGlobal[thisJoint.indexB];

	float2 m_localAnchorA = (float2) (thisJoint.b.prismaticJointData.localAnchorA[0] , thisJoint.b.prismaticJointData.localAnchorA[1]);
	float2 m_localAnchorB = (float2) (thisJoint.b.prismaticJointData.localAnchorB[0] , thisJoint.b.prismaticJointData.localAnchorB[1]);
	float2 m_localCenterA = (float2) (bodyStaticA.m_localCenter.x, bodyStaticA.m_localCenter.y);
	float2 m_localCenterB = (float2) (bodyStaticB.m_localCenter.x, bodyStaticB.m_localCenter.y);
	float2 m_localXAxisA = (float2) (thisJoint.b.prismaticJointData.localXAxisA[0] , thisJoint.b.prismaticJointData.localXAxisA[1]);
	float2 m_localYAxisA = (float2) (thisJoint.b.prismaticJointData.localYAxisA[0] , thisJoint.b.prismaticJointData.localYAxisA[1]);
	thisJoint.b.prismaticJointData.localCenterA[0] = m_localCenterA.x;
	thisJoint.b.prismaticJointData.localCenterA[1] = m_localCenterA.y;
	thisJoint.b.prismaticJointData.localCenterB[0] = m_localCenterB.x;
	thisJoint.b.prismaticJointData.localCenterB[1] = m_localCenterB.y;
	thisJoint.b.prismaticJointData.invMassA = bodyStaticA.m_invMass;
	thisJoint.b.prismaticJointData.invMassB = bodyStaticB.m_invMass; 
	thisJoint.b.prismaticJointData.invIA = bodyStaticA.m_invI;
	thisJoint.b.prismaticJointData.invIB = bodyStaticB.m_invI;

	clb2Position positionA = positions[thisJoint.indexA]; clb2Velocity velocityA = velocities[thisJoint.indexA];  
	clb2Position positionB = positions[thisJoint.indexB]; clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 cA =  (float2)(positionA.cx, positionA.cy);   float aA = positionA.a;
	float2 vA =  (float2)(velocityA.vx, velocityA.vy);   float wA = velocityA.w;
	float2 cB =  (float2)(positionB.cx, positionB.cy);  float aB = positionB.a;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy);  float wB = velocityB.w;

	float2 rA = b2clMul_Rotate( xfA.q, m_localAnchorA - m_localCenterA);
	float2 rB = b2clMul_Rotate( xfB.q, m_localAnchorB - m_localCenterB);
	float2 d =  cB - cA + rB - rA ; 

	float mA = thisJoint.b.prismaticJointData.invMassA, mB = thisJoint.b.prismaticJointData.invMassB;
	float iA = thisJoint.b.prismaticJointData.invIA, iB = thisJoint.b.prismaticJointData.invIB;

	// Compute motor Jacobian and effective mass.
	float2 m_axis = b2clMul_Rotate(xfA.q, m_localXAxisA);
	thisJoint.b.prismaticJointData.a1 = b2clCross_VV(d + rA, m_axis);
	thisJoint.b.prismaticJointData.a2 = b2clCross_VV(rB, m_axis);

	thisJoint.b.prismaticJointData.motorMass = mA + mB + iA * thisJoint.b.prismaticJointData.a1 * thisJoint.b.prismaticJointData.a1 + iB * thisJoint.b.prismaticJointData.a2 * thisJoint.b.prismaticJointData.a2;
	if (thisJoint.b.prismaticJointData.motorMass > 0.0f)
	{
		thisJoint.b.prismaticJointData.motorMass = 1.0f / thisJoint.b.prismaticJointData.motorMass;
	}

	// Prismatic constraint.
	float2 m_perp = b2clMul_Rotate(xfA.q, m_localYAxisA);

	thisJoint.b.prismaticJointData.s1 = b2clCross_VV(d + rA, m_perp);
	thisJoint.b.prismaticJointData.s2 = b2clCross_VV(rB, m_perp);

	float k11 = mA + mB + iA * thisJoint.b.prismaticJointData.s1 * thisJoint.b.prismaticJointData.s1 + iB * thisJoint.b.prismaticJointData.s2 * thisJoint.b.prismaticJointData.s2;
	float k12 = iA * thisJoint.b.prismaticJointData.s1 + iB * thisJoint.b.prismaticJointData.s2;
	float k13 = iA * thisJoint.b.prismaticJointData.s1 * thisJoint.b.prismaticJointData.a1 + iB * thisJoint.b.prismaticJointData.s2 * thisJoint.b.prismaticJointData.a2;
	float k22 = iA + iB;
	if (k22 == 0.0f)
	{
		// For bodies with fixed rotation.
		k22 = 1.0f;
	}
	float k23 = iA * thisJoint.b.prismaticJointData.a1 + iB * thisJoint.b.prismaticJointData.a2;
	float k33 = mA + mB + iA * thisJoint.b.prismaticJointData.a1 * thisJoint.b.prismaticJointData.a1 + iB * thisJoint.b.prismaticJointData.a2 * thisJoint.b.prismaticJointData.a2;

	thisJoint.b.prismaticJointData.K.ex[0] = k11;
	thisJoint.b.prismaticJointData.K.ex[1] = k12;
	thisJoint.b.prismaticJointData.K.ex[2] = k13;
	thisJoint.b.prismaticJointData.K.ey[0] = k12;
	thisJoint.b.prismaticJointData.K.ey[1] = k22;
	thisJoint.b.prismaticJointData.K.ey[2] = k23;
	thisJoint.b.prismaticJointData.K.ez[0] = k13;
	thisJoint.b.prismaticJointData.K.ez[1] = k23;
	thisJoint.b.prismaticJointData.K.ez[2] = k33;

	// Compute motor and limit terms.
	if (thisJoint.b.prismaticJointData.enableLimit)
	{
		float jointTranslation = b2clDot(m_axis, d);
		if (b2clAbs(thisJoint.b.prismaticJointData.upperTranslation - thisJoint.b.prismaticJointData.lowerTranslation) < 2.0f * b2_linearSlop)
		{
			thisJoint.b.prismaticJointData.limitState = e_equalLimits;
		}
		else if (jointTranslation <= thisJoint.b.prismaticJointData.lowerTranslation)
		{
			if (thisJoint.b.prismaticJointData.limitState != e_atLowerLimit)
			{
				thisJoint.b.prismaticJointData.limitState = e_atLowerLimit;
				thisJoint.a.x.impulse[2] = 0.0f;
			}
		}
		else if (jointTranslation >= thisJoint.b.prismaticJointData.upperTranslation)
		{
			if (thisJoint.b.prismaticJointData.limitState != e_atUpperLimit)
			{
				thisJoint.b.prismaticJointData.limitState = e_atUpperLimit;
				thisJoint.a.x.impulse[2] = 0.0f;
			}
		}
		else
		{
			thisJoint.b.prismaticJointData.limitState = e_inactiveLimit;
			thisJoint.a.x.impulse[2] = 0.0f;
		}
	}
	else
	{
		thisJoint.b.prismaticJointData.limitState = e_inactiveLimit;
		thisJoint.a.x.impulse[2] = 0.0f;
	}

	if (thisJoint.b.prismaticJointData.enableMotor == false)
	{
		thisJoint.motorImpulse = 0.0f;
	}

	if (warmStarting)
	{
		// Account for variable time step.
		thisJoint.a.x.impulse[0] *= dtRatio;
		thisJoint.a.x.impulse[1] *= dtRatio;
		thisJoint.a.x.impulse[2] *= dtRatio;
		thisJoint.motorImpulse *= dtRatio;

		float2 P = thisJoint.a.x.impulse[0] * m_perp + (thisJoint.motorImpulse + thisJoint.a.x.impulse[2]) * m_axis;
		float LA = thisJoint.a.x.impulse[0] * thisJoint.b.prismaticJointData.s1 + thisJoint.a.x.impulse[1] + (thisJoint.motorImpulse + thisJoint.a.x.impulse[2]) * thisJoint.b.prismaticJointData.a1;
		float LB = thisJoint.a.x.impulse[0] * thisJoint.b.prismaticJointData.s2 + thisJoint.a.x.impulse[1] + (thisJoint.motorImpulse + thisJoint.a.x.impulse[2]) * thisJoint.b.prismaticJointData.a2;

		vA -= mA * P;
		wA -= iA * LA;

		vB += mB * P;
		wB += iB * LB;

		velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
		velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB;
	}
	else
	{
		thisJoint.a.x.impulse[0] = 0.0f;
		thisJoint.a.x.impulse[1] = 0.0f;
		thisJoint.a.x.impulse[2] = 0.0f;
		thisJoint.motorImpulse = 0.0f;
	}

	thisJoint.b.prismaticJointData.axis[0] = m_axis.x;
	thisJoint.b.prismaticJointData.axis[1] = m_axis.y;
	thisJoint.b.prismaticJointData.perp[0] = m_perp.x;
	thisJoint.b.prismaticJointData.perp[1] = m_perp.y;
	jointListBuffer[contactIndex] = thisJoint;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// InitializeGearJointVelocityConstraint
//
// Initialize values of Gear joints for the solver computation.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void InitializeGearJointVelocityConstraint(
						__global clb2Velocity* velocities,
						const __global clb2Position* positions,
						const __global b2clBodyStatic* bodyStaticListBuffer,
						const __global b2clTransform* xfGlobal,
						__global b2clJoint* jointListBuffer,
						//int numContact, 
						int warmStarting,
						float dt,
						float dtRatio,
						//__global testData* testBuffer 
						const unsigned int offset,
						const unsigned int colorLength
						)
{
    unsigned int contactIndex = get_global_id(0) + offset;
    if(contactIndex>=offset+colorLength) return;

	b2clJoint thisJoint = jointListBuffer[contactIndex]; 
	b2clBodyStatic bodyStaticA = bodyStaticListBuffer[thisJoint.indexA];
	b2clBodyStatic bodyStaticB = bodyStaticListBuffer[thisJoint.indexB];
	b2clBodyStatic bodyStaticC = bodyStaticListBuffer[thisJoint.indexC];
	b2clBodyStatic bodyStaticD = bodyStaticListBuffer[thisJoint.indexD];
	b2clTransform xfA = xfGlobal[thisJoint.indexA];
	b2clTransform xfB = xfGlobal[thisJoint.indexB];
	b2clTransform xfC = xfGlobal[thisJoint.indexC];
	b2clTransform xfD = xfGlobal[thisJoint.indexD];

	float2 m_localAnchorA = (float2) (thisJoint.b.gearJointData.localAnchorA[0] , thisJoint.b.gearJointData.localAnchorA[1]);
	float2 m_localAnchorB = (float2) (thisJoint.b.gearJointData.localAnchorB[0] , thisJoint.b.gearJointData.localAnchorB[1]);
	float2 m_localAnchorC = (float2) (thisJoint.b.gearJointData.localAnchorC[0] , thisJoint.b.gearJointData.localAnchorC[1]);
	float2 m_localAnchorD = (float2) (thisJoint.b.gearJointData.localAnchorD[0] , thisJoint.b.gearJointData.localAnchorD[1]);

	float2 m_lcA = (float2) (bodyStaticA.m_localCenter.x, bodyStaticA.m_localCenter.y);
	float2 m_lcB = (float2) (bodyStaticB.m_localCenter.x, bodyStaticB.m_localCenter.y);
	float2 m_lcC = (float2) (bodyStaticC.m_localCenter.x, bodyStaticC.m_localCenter.y);
	float2 m_lcD = (float2) (bodyStaticD.m_localCenter.x, bodyStaticD.m_localCenter.y);

	float2 localAxisC = (float2) (thisJoint.b.gearJointData.localAxisC[0] , thisJoint.b.gearJointData.localAxisC[1]);
	float2 localAxisD = (float2) (thisJoint.b.gearJointData.localAxisD[0] , thisJoint.b.gearJointData.localAxisD[1]);

	thisJoint.b.gearJointData.lcA[0] = m_lcA.x;
	thisJoint.b.gearJointData.lcA[1] = m_lcA.y;
	thisJoint.b.gearJointData.lcB[0] = m_lcB.x;
	thisJoint.b.gearJointData.lcB[1] = m_lcB.y;
	thisJoint.b.gearJointData.lcC[0] = m_lcC.x;
	thisJoint.b.gearJointData.lcC[1] = m_lcC.y;
	thisJoint.b.gearJointData.lcD[0] = m_lcD.x;
	thisJoint.b.gearJointData.lcD[1] = m_lcD.y;
	thisJoint.b.gearJointData.mA = bodyStaticA.m_invMass;
	thisJoint.b.gearJointData.mB = bodyStaticB.m_invMass; 
	thisJoint.b.gearJointData.mC = bodyStaticC.m_invMass;
	thisJoint.b.gearJointData.mD = bodyStaticD.m_invMass; 
	thisJoint.b.gearJointData.iA = bodyStaticA.m_invI;
	thisJoint.b.gearJointData.iB = bodyStaticB.m_invI;
	thisJoint.b.gearJointData.iC = bodyStaticC.m_invI;
	thisJoint.b.gearJointData.iD = bodyStaticD.m_invI;

	clb2Position positionA = positions[thisJoint.indexA]; clb2Velocity velocityA = velocities[thisJoint.indexA];  
	clb2Position positionB = positions[thisJoint.indexB]; clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	clb2Position positionC = positions[thisJoint.indexC]; clb2Velocity velocityC = velocities[thisJoint.indexC];  
	clb2Position positionD = positions[thisJoint.indexD]; clb2Velocity velocityD = velocities[thisJoint.indexD]; 
	float2 cA =  (float2)(positionA.cx, positionA.cy);   float aA = positionA.a;
	float2 vA =  (float2)(velocityA.vx, velocityA.vy);   float wA = velocityA.w;
	float2 cB =  (float2)(positionB.cx, positionB.cy);  float aB = positionB.a;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy);  float wB = velocityB.w;
	float2 cC =  (float2)(positionC.cx, positionC.cy);   float aC = positionC.a;
	float2 vC =  (float2)(velocityC.vx, velocityC.vy);   float wC = velocityC.w;
	float2 cD =  (float2)(positionD.cx, positionD.cy);  float aD = positionD.a;
    float2 vD =  (float2)(velocityD.vx, velocityD.vy);  float wD = velocityD.w;

	thisJoint.b.gearJointData.mass = 0.0f;

	float2 m_JvAC, m_JvBD;
	if (thisJoint.b.gearJointData.typeA == e_revoluteJoint)
	{
		m_JvAC = (float2)(0.0f, 0.0f);
		thisJoint.b.gearJointData.JwA = 1.0f;
		thisJoint.b.gearJointData.JwC = 1.0f;
		thisJoint.b.gearJointData.mass += thisJoint.b.gearJointData.iA + thisJoint.b.gearJointData.iC;
	}
	else
	{
		float2 u = b2clMul_Rotate(xfC.q, localAxisC);
		float2 rC = b2clMul_Rotate(xfC.q, m_localAnchorC - m_lcC);
		float2 rA = b2clMul_Rotate(xfA.q, m_localAnchorA - m_lcA);
		m_JvAC = u;
		thisJoint.b.gearJointData.JwC = b2clCross_VV(rC, u);
		thisJoint.b.gearJointData.JwA = b2clCross_VV(rA, u);
		thisJoint.b.gearJointData.mass += thisJoint.b.gearJointData.mC + thisJoint.b.gearJointData.mA + thisJoint.b.gearJointData.iC * thisJoint.b.gearJointData.JwC * thisJoint.b.gearJointData.JwC + thisJoint.b.gearJointData.iA * thisJoint.b.gearJointData.JwA * thisJoint.b.gearJointData.JwA;
	}

	if (thisJoint.b.gearJointData.typeB == e_revoluteJoint)
	{
		m_JvBD = (float2)(0.0f, 0.0f);
		thisJoint.b.gearJointData.JwB = thisJoint.b.gearJointData.ratio;
		thisJoint.b.gearJointData.JwD = thisJoint.b.gearJointData.ratio;
		thisJoint.b.gearJointData.mass += thisJoint.b.gearJointData.ratio * thisJoint.b.gearJointData.ratio * (thisJoint.b.gearJointData.iB + thisJoint.b.gearJointData.iD);
	}
	else
	{
		float2 u = b2clMul_Rotate(xfD.q, localAxisD);
		float2 rD = b2clMul_Rotate(xfD.q, m_localAnchorD - m_lcD);
		float2 rB = b2clMul_Rotate(xfB.q, m_localAnchorB - m_lcB);
		m_JvBD = thisJoint.b.gearJointData.ratio * u;
		thisJoint.b.gearJointData.JwD = thisJoint.b.gearJointData.ratio * b2clCross_VV(rD, u);
		thisJoint.b.gearJointData.JwB = thisJoint.b.gearJointData.ratio * b2clCross_VV(rB, u);
		thisJoint.b.gearJointData.mass += thisJoint.b.gearJointData.ratio * thisJoint.b.gearJointData.ratio * (thisJoint.b.gearJointData.mD + thisJoint.b.gearJointData.mB) + thisJoint.b.gearJointData.iD * thisJoint.b.gearJointData.JwD * thisJoint.b.gearJointData.JwD + thisJoint.b.gearJointData.iB * thisJoint.b.gearJointData.JwB * thisJoint.b.gearJointData.JwB;
	}

	// Compute effective mass.
	thisJoint.b.gearJointData.mass = thisJoint.b.gearJointData.mass > 0.0f ? 1.0f / thisJoint.b.gearJointData.mass : 0.0f;

	if (warmStarting)
	{
		vA += (thisJoint.b.gearJointData.mA * thisJoint.a.y.scalarImpulse) * m_JvAC;
		wA += thisJoint.b.gearJointData.iA * thisJoint.a.y.scalarImpulse * thisJoint.b.gearJointData.JwA;
		vB += (thisJoint.b.gearJointData.mB * thisJoint.a.y.scalarImpulse) * m_JvBD;
		wB += thisJoint.b.gearJointData.iB * thisJoint.a.y.scalarImpulse * thisJoint.b.gearJointData.JwB;
		vC -= (thisJoint.b.gearJointData.mC * thisJoint.a.y.scalarImpulse) * m_JvAC;
		wC -= thisJoint.b.gearJointData.iC * thisJoint.a.y.scalarImpulse * thisJoint.b.gearJointData.JwC;
		vD -= (thisJoint.b.gearJointData.mD * thisJoint.a.y.scalarImpulse) * m_JvBD;
		wD -= thisJoint.b.gearJointData.iD * thisJoint.a.y.scalarImpulse * thisJoint.b.gearJointData.JwD;

		velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
		velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 
		velocityC.vx = vC.x ; velocityC.vy = vC.y ; velocityC.w = wC ; velocities[thisJoint.indexC] = velocityC; 
		velocityD.vx = vD.x ; velocityD.vy = vD.y ; velocityD.w = wD ; velocities[thisJoint.indexD] = velocityD; 
	}
	else
	{
		thisJoint.a.y.scalarImpulse = 0.0f;
	}

	thisJoint.b.gearJointData.JvAC[0] = m_JvAC.x;
	thisJoint.b.gearJointData.JvAC[1] = m_JvAC.y;
	thisJoint.b.gearJointData.JvBD[0] = m_JvBD.x;
	thisJoint.b.gearJointData.JvBD[1] = m_JvBD.y;
	jointListBuffer[contactIndex] = thisJoint;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// InitializePulleyJointVelocityConstraint
//
// Initialize values of Pulley joints for the solver computation.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void InitializePulleyJointVelocityConstraint(
						__global clb2Velocity* velocities,
						const __global clb2Position* positions,
						const __global b2clBodyStatic* bodyStaticListBuffer,
						const __global b2clTransform* xfGlobal,
						__global b2clJoint* jointListBuffer,
						//int numContact, 
						int warmStarting,
						float dt,
						float dtRatio,
						const unsigned int offset,
						const unsigned int colorLength
						//__global testData* testBuffer 
						)
{
	 unsigned int contactIndex = get_global_id(0) + offset;
    if(contactIndex>=offset+colorLength) return;

	b2clJoint thisJoint = jointListBuffer[contactIndex]; 
	b2clBodyStatic bodyStaticA = bodyStaticListBuffer[thisJoint.indexA];
	b2clBodyStatic bodyStaticB = bodyStaticListBuffer[thisJoint.indexB];
	b2clTransform xfA = xfGlobal[thisJoint.indexA];
	b2clTransform xfB = xfGlobal[thisJoint.indexB];
	float2 m_localAnchorA = (float2) (thisJoint.b.pulleyJointData.localAnchorA[0] , thisJoint.b.pulleyJointData.localAnchorA[1]);
	float2 m_localAnchorB = (float2) (thisJoint.b.pulleyJointData.localAnchorB[0] , thisJoint.b.pulleyJointData.localAnchorB[1]);
	float2 m_groundAnchorA = (float2) (thisJoint.b.pulleyJointData.groundAnchorA[0], thisJoint.b.pulleyJointData.groundAnchorA[1]);
	float2 m_groundAnchorB = (float2) (thisJoint.b.pulleyJointData.groundAnchorB[0], thisJoint.b.pulleyJointData.groundAnchorB[1]); 
	float2 m_localCenterA = (float2) (bodyStaticA.m_localCenter.x, bodyStaticA.m_localCenter.y);
	float2 m_localCenterB = (float2) (bodyStaticB.m_localCenter.x, bodyStaticB.m_localCenter.y);
	thisJoint.b.pulleyJointData.invMassA = bodyStaticA.m_invMass;
	thisJoint.b.pulleyJointData.invMassB = bodyStaticB.m_invMass;  
	thisJoint.b.pulleyJointData.invIA = bodyStaticA.m_invI;
	thisJoint.b.pulleyJointData.invIB = bodyStaticB.m_invI;
	thisJoint.b.pulleyJointData.localCenterA[0] = m_localCenterA.x ; thisJoint.b.pulleyJointData.localCenterA[1] = m_localCenterA.y ;
	thisJoint.b.pulleyJointData.localCenterB[0] = m_localCenterB.x ; thisJoint.b.pulleyJointData.localCenterB[1] = m_localCenterB.y ;

	clb2Position positionA = positions[thisJoint.indexA]; clb2Velocity velocityA = velocities[thisJoint.indexA];  
	clb2Position positionB = positions[thisJoint.indexB]; clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 cA =  (float2)(positionA.cx, positionA.cy);   float aA = positionA.a;
	float2 vA =  (float2)(velocityA.vx, velocityA.vy);   float wA = velocityA.w;
	float2 cB =  (float2)(positionB.cx, positionB.cy);  float aB = positionB.a;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy);  float wB = velocityB.w;

	float2 rA = b2clMul_Rotate( xfA.q, m_localAnchorA - m_localCenterA);float2 rB = b2clMul_Rotate( xfB.q, m_localAnchorB - m_localCenterB);
	float2 uA = cA + rA - m_groundAnchorA ; float2 uB = cB + rB - m_groundAnchorB ; 

	float lengthA = uA.x * uA.x + uA.y * uA.y; lengthA = sqrt (lengthA); 
	float lengthB = uB.x * uB.x + uB.y * uB.y; lengthB = sqrt (lengthB);
	if (lengthA > 10.0f * b2_linearSlop) {
		uA *= 1.0f/lengthA ; 
	}
	else {
		uA.x = uA.y = 0 ; 
	}
	if (lengthB > 10.0f * b2_linearSlop) {
		uB *= 1.0f/lengthB ; 
	}
	else{
		uB.x = uB.y = 0 ; 
	}

	float ruA = b2clCross_VV (rA, uA);
	float ruB = b2clCross_VV (rB, uB);
	float mA = thisJoint.b.pulleyJointData.invMassA + thisJoint.b.pulleyJointData.invIA * ruA * ruA ; 
	float mB = thisJoint.b.pulleyJointData.invMassB + thisJoint.b.pulleyJointData.invIB * ruB * ruB ; 
	thisJoint.b.pulleyJointData.mass = mA + thisJoint.b.pulleyJointData.ratio* thisJoint.b.pulleyJointData.ratio*mB ; 
	if (thisJoint.b.pulleyJointData.mass > 0.0f) {
		thisJoint.b.pulleyJointData.mass = 1.0f/thisJoint.b.pulleyJointData.mass; 
	}
	if (warmStarting){
		// Scale impulses to support variable time steps.
		thisJoint.a.y.scalarImpulse *= dtRatio;

		// Warm starting.
		float2 PA = -(thisJoint.a.y.scalarImpulse) * uA;
		float2 PB = (-thisJoint.b.pulleyJointData.ratio * thisJoint.a.y.scalarImpulse) * uB;

		vA += thisJoint.b.pulleyJointData.invMassA * PA;
		wA += thisJoint.b.pulleyJointData.invIA * b2clCross_VV(rA, PA);
		vB += thisJoint.b.pulleyJointData.invMassB * PB;
		wB += thisJoint.b.pulleyJointData.invIB * b2clCross_VV(rB, PB);

		velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
		velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 
	}
	else {
		thisJoint.a.y.scalarImpulse = 0.0f ; 
	}
	thisJoint.b.pulleyJointData.rA[0] = rA.x ; thisJoint.b.pulleyJointData.rA[1] = rA.y ; 	thisJoint.b.pulleyJointData.rB[0] = rB.x ; thisJoint.b.pulleyJointData.rB[1] = rB.y ; 
	thisJoint.b.pulleyJointData.uA[0] = uA.x ; thisJoint.b.pulleyJointData.uA[1] = uA.y ; thisJoint.b.pulleyJointData.uB[0] = uB.x ; thisJoint.b.pulleyJointData.uB[1] = uB.y ; 
	jointListBuffer[contactIndex] = thisJoint; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// InitializeRopeJointVelocityConstraint
//
// Initialize values of Rope joints for the solver computation.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void InitializeRopeJointVelocityConstraint(
						__global clb2Velocity* velocities,
						const __global clb2Position* positions,
						const __global b2clBodyStatic* bodyStaticListBuffer,
						const __global b2clTransform* xfGlobal,
						__global b2clJoint* jointListBuffer,
						//int numContact, 
						int warmStarting,
						float dt,
						float dtRatio,
						const unsigned int offset,
						const unsigned int colorLength
						//__global testData* testBuffer 
						)
{
    unsigned int contactIndex = get_global_id(0) + offset;
    if(contactIndex>=offset+colorLength) return;

	b2clJoint thisJoint = jointListBuffer[contactIndex]; 
	b2clBodyStatic bodyStaticA = bodyStaticListBuffer[thisJoint.indexA];
	b2clBodyStatic bodyStaticB = bodyStaticListBuffer[thisJoint.indexB];
	b2clTransform xfA = xfGlobal[thisJoint.indexA];
	b2clTransform xfB = xfGlobal[thisJoint.indexB];
	float2 m_localAnchorA = (float2) (thisJoint.b.ropeJointData.localAnchorA[0] , thisJoint.b.ropeJointData.localAnchorA[1]);
	float2 m_localAnchorB = (float2) (thisJoint.b.ropeJointData.localAnchorB[0] , thisJoint.b.ropeJointData.localAnchorB[1]);
	float2 m_localCenterA = (float2) (bodyStaticA.m_localCenter.x, bodyStaticA.m_localCenter.y);
	float2 m_localCenterB = (float2) (bodyStaticB.m_localCenter.x, bodyStaticB.m_localCenter.y);
	thisJoint.b.ropeJointData.invMassA = bodyStaticA.m_invMass;
	thisJoint.b.ropeJointData.invMassB = bodyStaticB.m_invMass;  
	thisJoint.b.ropeJointData.invIA = bodyStaticA.m_invI;
	thisJoint.b.ropeJointData.invIB = bodyStaticB.m_invI;
	thisJoint.b.ropeJointData.localCenterA[0] = m_localCenterA.x ; thisJoint.b.ropeJointData.localCenterA[1] = m_localCenterA.y ;
	thisJoint.b.ropeJointData.localCenterB[0] = m_localCenterB.x ; thisJoint.b.ropeJointData.localCenterB[1] = m_localCenterB.y ;
	
	clb2Position positionA = positions[thisJoint.indexA]; clb2Velocity velocityA = velocities[thisJoint.indexA];  
	clb2Position positionB = positions[thisJoint.indexB]; clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 cA =  (float2)(positionA.cx, positionA.cy);   float aA = positionA.a;
	float2 vA =  (float2)(velocityA.vx, velocityA.vy);   float wA = velocityA.w;
	float2 cB =  (float2)(positionB.cx, positionB.cy);  float aB = positionB.a;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy);  float wB = velocityB.w;

	float2 rA = b2clMul_Rotate( xfA.q, m_localAnchorA - m_localCenterA);
	float2 rB = b2clMul_Rotate( xfB.q, m_localAnchorB - m_localCenterB);
	thisJoint.b.ropeJointData.rA[0] = rA.x ; thisJoint.b.ropeJointData.rA[1] = rA.y ; 	thisJoint.b.ropeJointData.rB[0] = rB.x ; thisJoint.b.ropeJointData.rB[1] = rB.y ; 
	float2 u = cB + rB - cA -  rA ; 
	 
	float length = sqrt (b2clDot (u,u));
	thisJoint.b.ropeJointData.nlength = length ; 
	float C = length - thisJoint.b.ropeJointData.maxLength ;
    
	if (C > 0.0f)
	{
		thisJoint.b.ropeJointData.limitState = e_atUpperLimit;
	}
	else
	{
		thisJoint.b.ropeJointData.limitState = e_inactiveLimit;
	}
	if ( thisJoint.b.ropeJointData.nlength > b2_linearSlop)
	{
		u *= 1.0f / thisJoint.b.ropeJointData.nlength;
	}
	else
	{
		u.x = u.y = 0;
		thisJoint.b.ropeJointData.u[0] = thisJoint.b.ropeJointData.u[1] = 0 ; 
		thisJoint.b.ropeJointData.mass = 0.0f;
		thisJoint.a.y.scalarImpulse = 0.0f;
		jointListBuffer[contactIndex] = thisJoint; 
		return;
	}
	thisJoint.b.ropeJointData.u[0] = u.x ; thisJoint.b.ropeJointData.u[1] = u.y ; 	
	float crA = b2clCross_VV(rA, u);
	float crB = b2clCross_VV(rB, u);
	float invMass = thisJoint.b.ropeJointData.invMassA + thisJoint.b.ropeJointData.invIA * crA * crA + thisJoint.b.ropeJointData.invMassB + thisJoint.b.ropeJointData.invIB * crB * crB;

	thisJoint.b.ropeJointData.mass = invMass != 0.0f ? 1.0f / invMass : 0.0f;

	if (warmStarting)
	{
		// Scale the impulse to support a variable time step.
		thisJoint.a.y.scalarImpulse *= dtRatio;
		float2 P = u * thisJoint.a.y.scalarImpulse; 
		vA -=  P * thisJoint.b.ropeJointData.invMassA;
		wA -= b2clCross_VV(rA, P) * thisJoint.b.ropeJointData.invIA;
		vB += P * thisJoint.b.ropeJointData.invMassB;
		wB += b2clCross_VV(rB, P) * thisJoint.b.ropeJointData.invIB;

		velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
		velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB;
	}
	else
	{
		thisJoint.a.y.scalarImpulse = 0.0f;
	}
	jointListBuffer[contactIndex] = thisJoint; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// InitializeWheelJointVelocityConstraint
//
// Initialize values of Wheel joints for the solver computation.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void InitializeWheelJointVelocityConstraint(
						__global clb2Velocity* velocities,
						const __global clb2Position* positions,
						const __global b2clBodyStatic* bodyStaticListBuffer,
						const __global b2clTransform* xfGlobal,
						__global b2clJoint* jointListBuffer,
						//int numContact, 
						int warmStarting,
						float dt,
						float dtRatio,
						const unsigned int offset,
						const unsigned int colorLength
						//__global testData* testBuffer 
						)
{
	 unsigned int contactIndex = get_global_id(0) + offset;
    if(contactIndex>=offset+colorLength) return;

	b2clJoint thisJoint = jointListBuffer[contactIndex]; 
	b2clBodyStatic bodyStaticA = bodyStaticListBuffer[thisJoint.indexA];
	b2clBodyStatic bodyStaticB = bodyStaticListBuffer[thisJoint.indexB];

	b2clTransform xfA = xfGlobal[thisJoint.indexA];
	b2clTransform xfB = xfGlobal[thisJoint.indexB];

	clb2Position positionA = positions[thisJoint.indexA]; clb2Velocity velocityA = velocities[thisJoint.indexA];  
	clb2Position positionB = positions[thisJoint.indexB]; clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 cA =  (float2)(positionA.cx, positionA.cy);   float aA = positionA.a;
	float2 vA =  (float2)(velocityA.vx, velocityA.vy);   float wA = velocityA.w;
	float2 cB =  (float2)(positionB.cx, positionB.cy);  float aB = positionB.a;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy);  float wB = velocityB.w;

	float2 m_localAnchorA = (float2) (thisJoint.b.wheelJointData.localAnchorA[0] , thisJoint.b.wheelJointData.localAnchorA[1]);
	float2 m_localAnchorB = (float2) (thisJoint.b.wheelJointData.localAnchorB[0] , thisJoint.b.wheelJointData.localAnchorB[1]);
	float2 m_localCenterA = (float2) (bodyStaticA.m_localCenter.x, bodyStaticA.m_localCenter.y);
	float2 m_localCenterB = (float2) (bodyStaticB.m_localCenter.x, bodyStaticB.m_localCenter.y);
	thisJoint.b.wheelJointData.localCenterA[0] = m_localCenterA.x;
	thisJoint.b.wheelJointData.localCenterA[1] = m_localCenterA.y;
	thisJoint.b.wheelJointData.localCenterB[0] = m_localCenterB.x;
	thisJoint.b.wheelJointData.localCenterB[1] = m_localCenterB.y;
	thisJoint.b.wheelJointData.invMassA = bodyStaticA.m_invMass;
	thisJoint.b.wheelJointData.invMassB = bodyStaticB.m_invMass; 
	thisJoint.b.wheelJointData.invIA = bodyStaticA.m_invI;
	thisJoint.b.wheelJointData.invIB = bodyStaticB.m_invI;
 
	float mA = thisJoint.b.wheelJointData.invMassA, mB = thisJoint.b.wheelJointData.invMassB;
	float iA = thisJoint.b.wheelJointData.invIA, iB = thisJoint.b.wheelJointData.invIB;

	// Compute the effective masses.
	float2 rA = b2clMul_Rotate( xfA.q, m_localAnchorA - m_localCenterA);
	float2 rB = b2clMul_Rotate( xfB.q, m_localAnchorB - m_localCenterB);
	float2 d = cB + rB - cA - rA;

	float2 m_ax, m_ay;
	float2 m_localXAxisA = (float2)(thisJoint.b.wheelJointData.localXAxisA[0], thisJoint.b.wheelJointData.localXAxisA[1]);
	float2 m_localYAxisA = (float2)(thisJoint.b.wheelJointData.localYAxisA[0], thisJoint.b.wheelJointData.localYAxisA[1]);
	// Point to line constraint
	{
		m_ay = b2clMul_Rotate(xfA.q, m_localYAxisA);
		thisJoint.b.wheelJointData.sAy = b2clCross_VV(d + rA, m_ay);
		thisJoint.b.wheelJointData.sBy = b2clCross_VV(rB, m_ay);

		thisJoint.b.wheelJointData.mass = mA + mB + iA * thisJoint.b.wheelJointData.sAy * thisJoint.b.wheelJointData.sAy + iB * thisJoint.b.wheelJointData.sBy * thisJoint.b.wheelJointData.sBy;

		if (thisJoint.b.wheelJointData.mass > 0.0f)
		{
			thisJoint.b.wheelJointData.mass = 1.0f / thisJoint.b.wheelJointData.mass;
		}
	}

	// Spring constraint
	thisJoint.b.wheelJointData.springMass = 0.0f;
	thisJoint.b.wheelJointData.bias = 0.0f;
	thisJoint.b.wheelJointData.gamma = 0.0f;
	if (thisJoint.b.wheelJointData.frequencyHz > 0.0f)
	{
		m_ax = b2clMul_Rotate(xfA.q, m_localXAxisA);
		thisJoint.b.wheelJointData.sAx = b2clCross_VV(d + rA, m_ax);
		thisJoint.b.wheelJointData.sBx = b2clCross_VV(rB, m_ax);

		float invMass = mA + mB + iA * thisJoint.b.wheelJointData.sAx * thisJoint.b.wheelJointData.sAx + iB * thisJoint.b.wheelJointData.sBx * thisJoint.b.wheelJointData.sBx;

		if (invMass > 0.0f)
		{
			thisJoint.b.wheelJointData.springMass = 1.0f / invMass;

			float C = b2clDot(d, m_ax);

			// Frequency
			float omega = 2.0f * b2_pi * thisJoint.b.wheelJointData.frequencyHz;

			// Damping coefficient
			float d = 2.0f * thisJoint.b.wheelJointData.springMass * thisJoint.b.wheelJointData.dampingRatio * omega;

			// Spring stiffness
			float k = thisJoint.b.wheelJointData.springMass * omega * omega;

			// magic formulas
			float h = dt;
			thisJoint.b.wheelJointData.gamma = h * (d + h * k);
			if (thisJoint.b.wheelJointData.gamma > 0.0f)
			{
				thisJoint.b.wheelJointData.gamma = 1.0f / thisJoint.b.wheelJointData.gamma;
			}

			thisJoint.b.wheelJointData.bias = C * h * k * thisJoint.b.wheelJointData.gamma;

			thisJoint.b.wheelJointData.springMass = invMass + thisJoint.b.wheelJointData.gamma;
			if (thisJoint.b.wheelJointData.springMass > 0.0f)
			{
				thisJoint.b.wheelJointData.springMass = 1.0f / thisJoint.b.wheelJointData.springMass;
			}
		}
	}
	else
	{
		thisJoint.a.y.springImpulse = 0.0f;
	}

	// Rotational motor
	if (thisJoint.b.wheelJointData.enableMotor)
	{
		thisJoint.b.wheelJointData.motorMass = iA + iB;
		if (thisJoint.b.wheelJointData.motorMass > 0.0f)
		{
			thisJoint.b.wheelJointData.motorMass = 1.0f / thisJoint.b.wheelJointData.motorMass;
		}
	}
	else
	{
		thisJoint.b.wheelJointData.motorMass = 0.0f;
		thisJoint.motorImpulse = 0.0f;
	}

	if (warmStarting)
	{
		// Account for variable time step.
		thisJoint.a.y.scalarImpulse *= dtRatio;
		thisJoint.a.y.springImpulse *= dtRatio;
		thisJoint.motorImpulse *= dtRatio;

		float2 P = thisJoint.a.y.scalarImpulse * m_ay + thisJoint.a.y.springImpulse * m_ax;
		float LA = thisJoint.a.y.scalarImpulse * thisJoint.b.wheelJointData.sAy + thisJoint.a.y.springImpulse * thisJoint.b.wheelJointData.sAx + thisJoint.motorImpulse;
		float LB = thisJoint.a.y.scalarImpulse * thisJoint.b.wheelJointData.sBy + thisJoint.a.y.springImpulse * thisJoint.b.wheelJointData.sBx + thisJoint.motorImpulse;

		vA -= thisJoint.b.wheelJointData.invMassA * P;
		wA -= thisJoint.b.wheelJointData.invIA * LA;

		vB += thisJoint.b.wheelJointData.invMassB * P;
		wB += thisJoint.b.wheelJointData.invIB * LB;

		velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
		velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB;
	}
	else
	{
		thisJoint.a.y.scalarImpulse = 0.0f;
		thisJoint.a.y.springImpulse = 0.0f;
		thisJoint.motorImpulse = 0.0f;
	}

	thisJoint.b.wheelJointData.ax[0] = m_ax.x;
	thisJoint.b.wheelJointData.ax[1] = m_ax.y;
	thisJoint.b.wheelJointData.ay[0] = m_ay.x;
	thisJoint.b.wheelJointData.ay[1] = m_ay.y;

	jointListBuffer[contactIndex] = thisJoint;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// InitializeWeldJointVelocityConstraint
//
// Initialize values of Weld joints for the solver computation.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void InitializeWeldJointVelocityConstraint(
						__global clb2Velocity* velocities,
						const __global clb2Position* positions,
						const __global b2clBodyStatic* bodyStaticListBuffer,
						const __global b2clTransform* xfGlobal,
						__global b2clJoint* jointListBuffer,
						//int numContact, 
						int warmStarting,
						float dt,
						float dtRatio,
						const unsigned int offset,
                        const unsigned int colorLength
						//__global testData* testBuffer 
						)
{
	unsigned int contactIndex = get_global_id(0) + offset;

    if(contactIndex >= offset + colorLength) 
		return;
	
	b2clJoint thisJoint = jointListBuffer[contactIndex]; 
	b2clBodyStatic bodyStaticA = bodyStaticListBuffer[thisJoint.indexA];
	b2clBodyStatic bodyStaticB = bodyStaticListBuffer[thisJoint.indexB];

	b2clTransform xfA = xfGlobal[thisJoint.indexA];
	b2clTransform xfB = xfGlobal[thisJoint.indexB];

	clb2Position positionA = positions[thisJoint.indexA]; clb2Velocity velocityA = velocities[thisJoint.indexA];  
	clb2Position positionB = positions[thisJoint.indexB]; clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 cA =  (float2)(positionA.cx, positionA.cy);   float aA = positionA.a;
	float2 vA =  (float2)(velocityA.vx, velocityA.vy);   float wA = velocityA.w;
	float2 cB =  (float2)(positionB.cx, positionB.cy);  float aB = positionB.a;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy);  float wB = velocityB.w;

	float2 m_localAnchorA = (float2) (thisJoint.b.weldJointData.localAnchorA[0] , thisJoint.b.weldJointData.localAnchorA[1]);
	float2 m_localAnchorB = (float2) (thisJoint.b.weldJointData.localAnchorB[0] , thisJoint.b.weldJointData.localAnchorB[1]);
	float2 m_localCenterA = (float2) (bodyStaticA.m_localCenter.x, bodyStaticA.m_localCenter.y);
	float2 m_localCenterB = (float2) (bodyStaticB.m_localCenter.x, bodyStaticB.m_localCenter.y);
	thisJoint.b.weldJointData.localCenterA[0] = m_localCenterA.x;
	thisJoint.b.weldJointData.localCenterA[1] = m_localCenterA.y;
	thisJoint.b.weldJointData.localCenterB[0] = m_localCenterB.x;
	thisJoint.b.weldJointData.localCenterB[1] = m_localCenterB.y;
	thisJoint.b.weldJointData.invMassA = bodyStaticA.m_invMass;
	thisJoint.b.weldJointData.invMassB = bodyStaticB.m_invMass; 
	thisJoint.b.weldJointData.invIA = bodyStaticA.m_invI;
	thisJoint.b.weldJointData.invIB = bodyStaticB.m_invI;

	float2 m_rA = b2clMul_Rotate( xfA.q, m_localAnchorA - m_localCenterA);
	float2 m_rB = b2clMul_Rotate( xfB.q, m_localAnchorB - m_localCenterB);

	// J = [-I -r1_skew I r2_skew]
	//     [ 0       -1 0       1]
	// r_skew = [-ry; rx]

	// Matlab
	// K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]
	//     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]
	//     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]

	float mA = thisJoint.b.weldJointData.invMassA, mB = thisJoint.b.weldJointData.invMassB;
	float iA = thisJoint.b.weldJointData.invIA, iB = thisJoint.b.weldJointData.invIB;

	b2clMat33 K;
	K.ex[0] = mA + mB + m_rA.y * m_rA.y * iA + m_rB.y * m_rB.y * iB;
	K.ey[0] = -m_rA.y * m_rA.x * iA - m_rB.y * m_rB.x * iB;
	K.ez[0] = -m_rA.y * iA - m_rB.y * iB;
	K.ex[1] = K.ey[0];
	K.ey[1] = mA + mB + m_rA.x * m_rA.x * iA + m_rB.x * m_rB.x * iB;
	K.ez[1] = m_rA.x * iA + m_rB.x * iB;
	K.ex[2] = K.ez[0];
	K.ey[2] = K.ez[1];
	K.ez[2] = iA + iB;

	if (thisJoint.b.weldJointData.frequencyHz > 0.0f)
	{
		b2clGetInverse22(K, &thisJoint.b.weldJointData.mass);

		float invM = iA + iB;
		float m = invM > 0.0f ? 1.0f / invM : 0.0f;

		float C = aB - aA - thisJoint.b.weldJointData.referenceAngle;

		// Frequency
		float omega = 2.0f * b2_pi * thisJoint.b.weldJointData.frequencyHz;

		// Damping coefficient
		float d = 2.0f * m * thisJoint.b.weldJointData.dampingRatio * omega;

		// Spring stiffness
		float k = m * omega * omega;

		// magic formulas
		float h = dt;
		thisJoint.b.weldJointData.gamma = h * (d + h * k);
		thisJoint.b.weldJointData.gamma = thisJoint.b.weldJointData.gamma != 0.0f ? 1.0f / thisJoint.b.weldJointData.gamma : 0.0f;
		thisJoint.b.weldJointData.bias = C * h * k * thisJoint.b.weldJointData.gamma;

		invM += thisJoint.b.weldJointData.gamma;
		thisJoint.b.weldJointData.mass.ez[2] = invM != 0.0f ? 1.0f / invM : 0.0f;
	}
	else
	{
		b2clGetSymInverse33(K, &thisJoint.b.weldJointData.mass);
		thisJoint.b.weldJointData.gamma = 0.0f;
		thisJoint.b.weldJointData.bias = 0.0f;
	}

	if (warmStarting)
	{
		// Scale impulses to support a variable time step.
		thisJoint.a.x.impulse[0] *= dtRatio;
		thisJoint.a.x.impulse[1] *= dtRatio;
		thisJoint.a.x.impulse[2] *= dtRatio;

		float2 P = (float2)(thisJoint.a.x.impulse[0], thisJoint.a.x.impulse[1]);

		vA -= mA * P;
		wA -= iA * (b2clCross_VV(m_rA, P) + thisJoint.a.x.impulse[2]);

		vB += mB * P;
		wB += iB * (b2clCross_VV(m_rB, P) + thisJoint.a.x.impulse[2]);

		velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
		velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 
	}
	else
	{
		thisJoint.a.x.impulse[0] = 0.0f;
		thisJoint.a.x.impulse[1] = 0.0f;
		thisJoint.a.x.impulse[2] = 0.0f;
	}

	thisJoint.b.weldJointData.rA[0] = m_rA.x;
	thisJoint.b.weldJointData.rA[1] = m_rA.y;
	thisJoint.b.weldJointData.rB[0] = m_rB.x;
	thisJoint.b.weldJointData.rB[1] = m_rB.y;

	jointListBuffer[contactIndex] = thisJoint;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// InitializeMouseJointVelocityConstraint
//
// Initialize values of Mouse joints for the solver computation.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void InitializeMouseJointVelocityConstraint(
						__global clb2Velocity* velocities,
						const __global clb2Position* positions,
						const __global b2clBodyStatic* bodyStaticListBuffer,
						const __global b2clTransform* xfGlobal,
						__global b2clJoint* jointListBuffer,
						//int numContact, 
						int warmStarting,
						float dt,
						float dtRatio,
						const unsigned int offset,
						const unsigned int colorLength
						//__global testData* testBuffer 
						)
{
	unsigned int contactIndex = get_global_id(0) + offset;

    if(contactIndex >= offset + colorLength) 
		return;
		
	b2clJoint thisJoint = jointListBuffer[contactIndex]; 
	b2clBodyStatic bodyStaticB = bodyStaticListBuffer[thisJoint.indexB];
	b2clTransform xfB = xfGlobal[thisJoint.indexB];

	float2 m_localAnchorB = (float2) (thisJoint.b.mouseJointData.localAnchorB[0] , thisJoint.b.mouseJointData.localAnchorB[1]);
	float2 m_localCenterB = (float2) (bodyStaticB.m_localCenter.x, bodyStaticB.m_localCenter.y);

	float2 m_targetA = (float2) (thisJoint.b.mouseJointData.targetA[0], thisJoint.b.mouseJointData.targetA[1]);

	thisJoint.b.mouseJointData.localCenterB[0] = m_localCenterB.x;
	thisJoint.b.mouseJointData.localCenterB[1] = m_localCenterB.y;
	thisJoint.b.mouseJointData.invMassB = bodyStaticB.m_invMass; 
	thisJoint.b.mouseJointData.invIB = bodyStaticB.m_invI;

	clb2Position positionB = positions[thisJoint.indexB]; clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 cB =  (float2)(positionB.cx, positionB.cy);  float aB = positionB.a;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy);  float wB = velocityB.w;

	float mB = thisJoint.b.mouseJointData.invMassB;
	float iB = thisJoint.b.mouseJointData.invIB;

	float mass = 1.0f / mB;

	// Frequency
	float omega = 2.0f * b2_pi * thisJoint.b.mouseJointData.frequencyHz;

	// Damping coefficient
	float d = 2.0f * mass * thisJoint.b.mouseJointData.dampingRatio * omega;

	// Spring stiffness
	float k = mass * (omega * omega);

	// magic formulas
	// gamma has units of inverse mass.
	// beta has units of inverse time.
	float h = dt;
	thisJoint.b.mouseJointData.gamma = h * (d + h * k);
	if (thisJoint.b.mouseJointData.gamma != 0.0f)
	{
		thisJoint.b.mouseJointData.gamma = 1.0f / thisJoint.b.mouseJointData.gamma;
	}
	thisJoint.b.mouseJointData.beta = h * k * thisJoint.b.mouseJointData.gamma;

	// Compute the effective mass matrix.
	float2 m_rB = b2clMul_Rotate( xfB.q, m_localAnchorB - m_localCenterB);

	// K    = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) * invI2 * skew(r2)]
	//      = [1/m1+1/m2     0    ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y -r1.x*r1.y]
	//        [    0     1/m1+1/m2]           [-r1.x*r1.y r1.x*r1.x]           [-r1.x*r1.y r1.x*r1.x]
	b2clMat22 K;
	K.ex[0] = thisJoint.b.mouseJointData.invMassB + thisJoint.b.mouseJointData.invIB * m_rB.y * m_rB.y + thisJoint.b.mouseJointData.gamma;
	K.ex[1] = -thisJoint.b.mouseJointData.invIB * m_rB.x * m_rB.y;
	K.ey[0] = K.ex[1];
	K.ey[1] = thisJoint.b.mouseJointData.invMassB + thisJoint.b.mouseJointData.invIB * m_rB.x * m_rB.x + thisJoint.b.mouseJointData.gamma;

	b2clMat22GetInverse(K, &thisJoint.b.mouseJointData.mass);

	float2 m_C = cB + m_rB - m_targetA;
	m_C *= thisJoint.b.mouseJointData.beta;

	// Cheat with some damping
	wB *= 0.98f;

	if (warmStarting)
	{
		float2 m_impulse = (float2)(thisJoint.a.x.impulse[0], thisJoint.a.x.impulse[1]);
		m_impulse *= dtRatio;
		vB += thisJoint.b.mouseJointData.invMassB * m_impulse;
		wB += thisJoint.b.mouseJointData.invIB * b2clCross_VV(m_rB, m_impulse);

		thisJoint.a.x.impulse[0] = m_impulse.x;
		thisJoint.a.x.impulse[1] = m_impulse.y;

		velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 
	}
	else
	{
		thisJoint.a.x.impulse[0] = 0.0f;
		thisJoint.a.x.impulse[1] = 0.0f;
	}

	thisJoint.b.mouseJointData.rB[0] = m_rB.x;
	thisJoint.b.mouseJointData.rB[1] = m_rB.y;
	thisJoint.b.mouseJointData.C[0] = m_C.x;
	thisJoint.b.mouseJointData.C[1] = m_C.y;
	jointListBuffer[contactIndex] = thisJoint;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// InitializeFrictionJointVelocityConstraint
//
// Initialize values of Friction joints for the solver computation.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void InitializeFrictionJointVelocityConstraint(
						__global clb2Velocity* velocities,
						const __global clb2Position* positions,
						const __global b2clBodyStatic* bodyStaticListBuffer,
						const __global b2clTransform* xfGlobal,
						__global b2clJoint* jointListBuffer,
						//int numContact, 
						const int warmStarting,
						const float dt,
						const float dtRatio,
						const unsigned int offset,
						const unsigned int colorLength
						//__global testData* testBuffer 
						)
{
	unsigned int contactIndex = get_global_id(0) + offset;

    if(contactIndex >= offset + colorLength) 
		return;
	
	b2clJoint thisJoint = jointListBuffer[contactIndex]; 
	b2clBodyStatic bodyStaticA = bodyStaticListBuffer[thisJoint.indexA];
	b2clBodyStatic bodyStaticB = bodyStaticListBuffer[thisJoint.indexB];

	b2clTransform xfA = xfGlobal[thisJoint.indexA];
	b2clTransform xfB = xfGlobal[thisJoint.indexB];

	clb2Position positionA = positions[thisJoint.indexA]; clb2Velocity velocityA = velocities[thisJoint.indexA];  
	clb2Position positionB = positions[thisJoint.indexB]; clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 cA =  (float2)(positionA.cx, positionA.cy);   float aA = positionA.a;
	float2 vA =  (float2)(velocityA.vx, velocityA.vy);   float wA = velocityA.w;
	float2 cB =  (float2)(positionB.cx, positionB.cy);  float aB = positionB.a;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy);  float wB = velocityB.w;

	float2 m_localAnchorA = (float2) (thisJoint.b.frictionJointData.localAnchorA[0] , thisJoint.b.frictionJointData.localAnchorA[1]);
	float2 m_localAnchorB = (float2) (thisJoint.b.frictionJointData.localAnchorB[0] , thisJoint.b.frictionJointData.localAnchorB[1]);
	float2 m_localCenterA = (float2) (bodyStaticA.m_localCenter.x, bodyStaticA.m_localCenter.y);
	float2 m_localCenterB = (float2) (bodyStaticB.m_localCenter.x, bodyStaticB.m_localCenter.y);
	thisJoint.b.frictionJointData.localCenterA[0] = m_localCenterA.x;
	thisJoint.b.frictionJointData.localCenterA[1] = m_localCenterA.y;
	thisJoint.b.frictionJointData.localCenterB[0] = m_localCenterB.x;
	thisJoint.b.frictionJointData.localCenterB[1] = m_localCenterB.y;
	thisJoint.b.frictionJointData.invMassA = bodyStaticA.m_invMass;
	thisJoint.b.frictionJointData.invMassB = bodyStaticB.m_invMass; 
	thisJoint.b.frictionJointData.invIA = bodyStaticA.m_invI;
	thisJoint.b.frictionJointData.invIB = bodyStaticB.m_invI;

	float2 m_rA = b2clMul_Rotate( xfA.q, m_localAnchorA - m_localCenterA);
	float2 m_rB = b2clMul_Rotate( xfB.q, m_localAnchorB - m_localCenterB);

	// J = [-I -r1_skew I r2_skew]
	//     [ 0       -1 0       1]
	// r_skew = [-ry; rx]

	// Matlab
	// K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]
	//     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]
	//     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]

	float mA = thisJoint.b.frictionJointData.invMassA, mB = thisJoint.b.frictionJointData.invMassB;
	float iA = thisJoint.b.frictionJointData.invIA, iB = thisJoint.b.frictionJointData.invIB;

	b2clMat22 K;
	K.ex[0] = mA + mB + iA * m_rA.y * m_rA.y + iB * m_rB.y * m_rB.y;
	K.ex[1] = -iA * m_rA.x * m_rA.y - iB * m_rB.x * m_rB.y;
	K.ey[0] = K.ex[1];
	K.ey[1] = mA + mB + iA * m_rA.x * m_rA.x + iB * m_rB.x * m_rB.x;

	b2clMat22GetInverse(K, &thisJoint.b.frictionJointData.linearMass);

	thisJoint.b.frictionJointData.angularMass = iA + iB;
	if (thisJoint.b.frictionJointData.angularMass > 0.0f)
	{
		thisJoint.b.frictionJointData.angularMass = 1.0f / thisJoint.b.frictionJointData.angularMass;
	}

	if (warmStarting)
	{
		// Scale impulses to support a variable time step.
		thisJoint.a.z.linearImpulse[0] *= dtRatio;
		thisJoint.a.z.linearImpulse[1] *= dtRatio;
		thisJoint.a.z.angularImpulse *= dtRatio;

		float2 P = (float2)(thisJoint.a.z.linearImpulse[0], thisJoint.a.z.linearImpulse[1]);
		vA -= mA * P;
		wA -= iA * (b2clCross_VV(m_rA, P) + thisJoint.a.z.angularImpulse);
		vB += mB * P;
		wB += iB * (b2clCross_VV(m_rB, P) + thisJoint.a.z.angularImpulse);

		velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
		velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 
	}
	else
	{
		thisJoint.a.z.linearImpulse[0] = 0.0f;
		thisJoint.a.z.linearImpulse[1] = 0.0f;
		thisJoint.a.z.angularImpulse = 0.0f;
	}

	thisJoint.b.frictionJointData.rA[0] = m_rA.x;
	thisJoint.b.frictionJointData.rA[1] = m_rA.y;
	thisJoint.b.frictionJointData.rB[0] = m_rB.x;
	thisJoint.b.frictionJointData.rB[1] = m_rB.y;

	jointListBuffer[contactIndex] = thisJoint;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolveDistanceJointVelocityConstraint
//
// Compute velocities of bodies which are constrained by a Distance joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolveDistanceJointVelocityConstraint(
                                 __global clb2Velocity* velocities,
                                 __global b2clJoint* jointList,
								 float dt, 
                                 const unsigned int offset,
                                 const unsigned int colorLength
								// __global testData* testBuffer                                 
								 )

{

 //printf ("impulse \n");
    unsigned int contactIndex = get_global_id(0) + offset;

    if(contactIndex>=offset+colorLength) return;

	b2clJoint thisJoint = jointList[contactIndex]; 

	clb2Velocity velocityA = velocities[thisJoint.indexA];  clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 vA =  (float2)(velocityA.vx, velocityA.vy);   float wA = velocityA.w;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy); float wB = velocityB.w;

	float2 m_rA = (float2) (thisJoint.b.distanceJointData.rA[0] , thisJoint.b.distanceJointData.rA[1]);
	float2 m_rB = (float2) (thisJoint.b.distanceJointData.rB[0] , thisJoint.b.distanceJointData.rB[1]); 
	float2 m_u  = (float2) (thisJoint.b.distanceJointData.u[0] , thisJoint.b.distanceJointData.u[1] );

	float2 vpA = vA +  b2clCross_SV(wA, m_rA); 
	float2 vpB = vB +  b2clCross_SV(wB, m_rB);
	float Cdot =  b2clDot ( m_u, vpB - vpA );
	
	float impulse = -thisJoint.b.distanceJointData.mass * (Cdot + thisJoint.b.distanceJointData.bias + thisJoint.b.distanceJointData.gamma * thisJoint.a.y.scalarImpulse) ;
	thisJoint.a.y.scalarImpulse += impulse ; 
	 

	float2 P = (float2) (impulse * m_u.x, impulse * m_u.y);

	vA -= (float2)(thisJoint.b.distanceJointData.invMassA* P.x , thisJoint.b.distanceJointData.invMassA* P.y);
	wA -=  thisJoint.b.distanceJointData.invIA * b2clCross_VV(m_rA, P) ; 
	vB += (float2)(thisJoint.b.distanceJointData.invMassB* P.x , thisJoint.b.distanceJointData.invMassB * P.y);
	wB += thisJoint.b.distanceJointData.invIB * b2clCross_VV(m_rB, P); 
	
	velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
	velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 
	jointList[contactIndex] = thisJoint; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolveRevoluteJointVelocityConstraint
//
// Compute velocities of bodies which are constrained by a Revolute joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolveRevoluteJointVelocityConstraint(
                                 __global clb2Velocity* velocities,
                                 __global b2clJoint* jointList,
								 const float dt,
                                 const unsigned int offset,
                                 const unsigned int colorLength
			
								// __global testData* testBuffer                                 
								 )

{
	unsigned int contactIndex = get_global_id(0) + offset;
	

    if(contactIndex>=offset+colorLength) 
		return;
	b2clJoint thisJoint = jointList[contactIndex]; 

	clb2Velocity velocityA = velocities[thisJoint.indexA];  clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 vA =  (float2)(velocityA.vx, velocityA.vy);   float wA = velocityA.w;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy); float wB = velocityB.w;
	float2 m_rA = (float2) (thisJoint.b.revoluteJointData.rA[0] , thisJoint.b.revoluteJointData.rA[1]);
	float2 m_rB = (float2) (thisJoint.b.revoluteJointData.rB[0] , thisJoint.b.revoluteJointData.rB[1]); 

	float mA = thisJoint.b.revoluteJointData.invMassA, mB = thisJoint.b.revoluteJointData.invMassB;
	float iA = thisJoint.b.revoluteJointData.invIA, iB = thisJoint.b.revoluteJointData.invIB;

	bool fixedRotation = (iA + iB == 0.0f);

	// Solve motor constraint.
	if (thisJoint.b.revoluteJointData.enableMotor && thisJoint.b.revoluteJointData.limitState != e_equalLimits && fixedRotation == false)
	{
		float Cdot = wB - wA - thisJoint.b.revoluteJointData.motorSpeed;
		float impulse = -thisJoint.b.revoluteJointData.motorMass * Cdot;
		float oldImpulse = thisJoint.motorImpulse;
		float maxImpulse = dt * thisJoint.b.revoluteJointData.maxMotorTorque;
		thisJoint.motorImpulse = b2clClamp(thisJoint.motorImpulse + impulse, -maxImpulse, maxImpulse);
		impulse = thisJoint.motorImpulse - oldImpulse;

		wA -= iA * impulse;
		wB += iB * impulse;
	}

	// Solve limit constraint.
	if (thisJoint.b.revoluteJointData.enableLimit && thisJoint.b.revoluteJointData.limitState != e_inactiveLimit && fixedRotation == false)
	{
		float2 Cdot1 = vB + b2clCross_SV(wB, m_rB) - vA - b2clCross_SV(wA, m_rA);
		float Cdot2 = wB - wA;
		float3 Cdot = (float3)(Cdot1.x, Cdot1.y, Cdot2);

		float3 impulse = -b2clMat33Solve(thisJoint.b.revoluteJointData.mass, Cdot);

		if (thisJoint.b.revoluteJointData.limitState == e_equalLimits)
		{
			thisJoint.a.x.impulse[0] += impulse.x;
			thisJoint.a.x.impulse[1] += impulse.y;
			thisJoint.a.x.impulse[2] += impulse.z;
		}
		else if (thisJoint.b.revoluteJointData.limitState == e_atLowerLimit)
		{
			float newImpulse = thisJoint.a.x.impulse[2] + impulse.z;
			if (newImpulse < 0.0f)
			{
				float2 rhs = -Cdot1 + thisJoint.a.x.impulse[2] * (float2)(thisJoint.b.revoluteJointData.mass.ez[0], thisJoint.b.revoluteJointData.mass.ez[1]);
				float2 reduced = b2clMat33Solve22(thisJoint.b.revoluteJointData.mass, rhs);
				impulse.x = reduced.x;
				impulse.y = reduced.y;
				impulse.z = -thisJoint.a.x.impulse[2];
				thisJoint.a.x.impulse[0] += reduced.x;
				thisJoint.a.x.impulse[1] += reduced.y;
				thisJoint.a.x.impulse[2] = 0.0f;
			}
			else
			{
				thisJoint.a.x.impulse[0] += impulse.x;
				thisJoint.a.x.impulse[1] += impulse.y;
				thisJoint.a.x.impulse[2] += impulse.z;
			}
		}
		else if (thisJoint.b.revoluteJointData.limitState == e_atUpperLimit)
		{
			float newImpulse = thisJoint.a.x.impulse[2] + impulse.z;
			if (newImpulse > 0.0f)
			{
				float2 rhs = -Cdot1 + thisJoint.a.x.impulse[2] * (float2)(thisJoint.b.revoluteJointData.mass.ez[0], thisJoint.b.revoluteJointData.mass.ez[1]);
				float2 reduced = b2clMat33Solve22(thisJoint.b.revoluteJointData.mass, rhs);
				impulse.x = reduced.x;
				impulse.y = reduced.y;
				impulse.z = -thisJoint.a.x.impulse[2];
				thisJoint.a.x.impulse[0] += reduced.x;
				thisJoint.a.x.impulse[1] += reduced.y;
				thisJoint.a.x.impulse[2] = 0.0f;
			}
			else
			{
				thisJoint.a.x.impulse[0] += impulse.x;
				thisJoint.a.x.impulse[1] += impulse.y;
				thisJoint.a.x.impulse[2] += impulse.z;
			}
		}

		float2 P = (float2)(impulse.x, impulse.y);

		vA -= mA * P;
		wA -= iA * (b2clCross_VV(m_rA, P) + impulse.z);

		vB += mB * P;
		wB += iB * (b2clCross_VV(m_rB, P) + impulse.z);
	}
	else
	{
		// Solve point-to-point constraint
		float2 Cdot = vB + b2clCross_SV(wB, m_rB) - vA - b2clCross_SV(wA, m_rA);
		float2 impulse = b2clMat33Solve22(thisJoint.b.revoluteJointData.mass, -Cdot);

		thisJoint.a.x.impulse[0] += impulse.x;
		thisJoint.a.x.impulse[1] += impulse.y;

		vA -= mA * impulse;
		wA -= iA * b2clCross_VV(m_rA, impulse);

		vB += mB * impulse;
		wB += iB * b2clCross_VV(m_rB, impulse);
	}
	
	velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
	velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 

	jointList[contactIndex] = thisJoint; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolvePrismaticJointVelocityConstraint
//
// Compute velocities of bodies which are constrained by a Prismatic joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolvePrismaticJointVelocityConstraint(
                                 __global clb2Velocity* velocities,
                                 __global b2clJoint* jointList,
								  const float dt,
                                 const unsigned int offset,
                                 const unsigned int colorLength
								
								// __global testData* testBuffer                                 
								 )

{
	unsigned int contactIndex = get_global_id(0) + offset;

    if(contactIndex>=offset+colorLength) 
		return;

	b2clJoint thisJoint = jointList[contactIndex]; 

	clb2Velocity velocityA = velocities[thisJoint.indexA];  clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 vA =  (float2)(velocityA.vx, velocityA.vy); float wA = velocityA.w;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy); float wB = velocityB.w; 

	float mA = thisJoint.b.prismaticJointData.invMassA, mB = thisJoint.b.prismaticJointData.invMassB;
	float iA = thisJoint.b.prismaticJointData.invIA, iB = thisJoint.b.prismaticJointData.invIB;

	const float2 m_axis = (float2) (thisJoint.b.prismaticJointData.axis[0] , thisJoint.b.prismaticJointData.axis[1]);
	const float2 m_perp = (float2) (thisJoint.b.prismaticJointData.perp[0] , thisJoint.b.prismaticJointData.perp[1]);

	// Solve linear motor constraint.
	if (thisJoint.b.prismaticJointData.enableMotor && thisJoint.b.prismaticJointData.limitState != e_equalLimits)
	{
		float Cdot = b2clDot(m_axis, vB - vA) + thisJoint.b.prismaticJointData.a2 * wB - thisJoint.b.prismaticJointData.a1 * wA;
		float impulse = thisJoint.b.prismaticJointData.motorMass * (thisJoint.b.prismaticJointData.motorSpeed - Cdot);
		float oldImpulse = thisJoint.motorImpulse;
		float maxImpulse = dt * thisJoint.b.prismaticJointData.maxMotorForce;
		thisJoint.motorImpulse = b2clClamp(thisJoint.motorImpulse + impulse, -maxImpulse, maxImpulse);
		impulse = thisJoint.motorImpulse - oldImpulse;

		float2 P = impulse * m_axis;
		float LA = impulse * thisJoint.b.prismaticJointData.a1;
		float LB = impulse * thisJoint.b.prismaticJointData.a2;

		vA -= mA * P;
		wA -= iA * LA;

		vB += mB * P;
		wB += iB * LB;
	}

	float2 Cdot1;
	Cdot1.x = b2clDot(m_perp, vB - vA) + thisJoint.b.prismaticJointData.s2 * wB - thisJoint.b.prismaticJointData.s1 * wA;
	Cdot1.y = wB - wA;

	if (thisJoint.b.prismaticJointData.enableLimit && thisJoint.b.prismaticJointData.limitState != e_inactiveLimit)
	{
		// Solve prismatic and limit constraint in block form.
		float Cdot2;
		Cdot2 = b2clDot(m_axis, vB - vA) + thisJoint.b.prismaticJointData.a2 * wB - thisJoint.b.prismaticJointData.a1 * wA;
		float3 Cdot = (float3)(Cdot1.x, Cdot1.y, Cdot2);

		float3 f1 = (float3)(thisJoint.a.x.impulse[0], thisJoint.a.x.impulse[1], thisJoint.a.x.impulse[2]);
		float3 df =  b2clMat33Solve(thisJoint.b.prismaticJointData.K, -Cdot);
		thisJoint.a.x.impulse[0] += df.x;
		thisJoint.a.x.impulse[1] += df.y;
		thisJoint.a.x.impulse[2] += df.z;

		if (thisJoint.b.prismaticJointData.limitState == e_atLowerLimit)
		{
			thisJoint.a.x.impulse[2] = max(thisJoint.a.x.impulse[2], 0.0f);
		}
		else if (thisJoint.b.prismaticJointData.limitState == e_atUpperLimit)
		{
			thisJoint.a.x.impulse[2] = min(thisJoint.a.x.impulse[2], 0.0f);
		}

		// f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) + f1(1:2)
		float2 b = -Cdot1 - (thisJoint.a.x.impulse[2] - f1.z) * (float2)(thisJoint.b.prismaticJointData.K.ez[0], thisJoint.b.prismaticJointData.K.ez[1]);
		float2 f2r = b2clMat33Solve22(thisJoint.b.prismaticJointData.K, b) + (float2)(f1.x, f1.y);
		thisJoint.a.x.impulse[0] = f2r.x;
		thisJoint.a.x.impulse[1] = f2r.y;

		df.x = thisJoint.a.x.impulse[0] - f1.x;
		df.y = thisJoint.a.x.impulse[1] - f1.y;
		df.z = thisJoint.a.x.impulse[2] - f1.z;

		float2 P = df.x * m_perp + df.z * m_axis;
		float LA = df.x * thisJoint.b.prismaticJointData.s1 + df.y + df.z * thisJoint.b.prismaticJointData.a1;
		float LB = df.x * thisJoint.b.prismaticJointData.s2 + df.y + df.z * thisJoint.b.prismaticJointData.a2;

		vA -= mA * P;
		wA -= iA * LA;

		vB += mB * P;
		wB += iB * LB;
	}
	else
	{
		// Limit is inactive, just solve the prismatic constraint in block form.
		float2 df = b2clMat33Solve22(thisJoint.b.prismaticJointData.K, -Cdot1);
		thisJoint.a.x.impulse[0] += df.x;
		thisJoint.a.x.impulse[1] += df.y;

		float2 P = df.x * m_perp;
		float LA = df.x * thisJoint.b.prismaticJointData.s1 + df.y;
		float LB = df.x * thisJoint.b.prismaticJointData.s2 + df.y;

		vA -= mA * P;
		wA -= iA * LA;

		vB += mB * P;
		wB += iB * LB;

		float2 Cdot10 = Cdot1;

		Cdot1.x = b2clDot(m_perp, vB - vA) + thisJoint.b.prismaticJointData.s2 * wB - thisJoint.b.prismaticJointData.s1 * wA;
		Cdot1.y = wB - wA;

		if (b2clAbs(Cdot1.x) > 0.01f || b2clAbs(Cdot1.y) > 0.01f)
		{
			float2 test = b2clMat33Mul22(thisJoint.b.prismaticJointData.K, df);
			Cdot1.x += 0.0f;
		}
	}
	
	velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
	velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 

	jointList[contactIndex] = thisJoint; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolveGearJointVelocityConstraint
//
// Compute velocities of bodies which are constrained by a Gear joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolveGearJointVelocityConstraint(
                                 __global clb2Velocity* velocities,
                                 __global b2clJoint* jointList,
								 const float dt,
                                 const unsigned int offset,
                                 const unsigned int colorLength
								 
								// __global testData* testBuffer                                 
								 )

{
	unsigned int contactIndex = get_global_id(0) + offset;

    if(contactIndex>=offset+colorLength) 
		return;

	b2clJoint thisJoint = jointList[contactIndex]; 

	clb2Velocity velocityA = velocities[thisJoint.indexA];  
	clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	clb2Velocity velocityC = velocities[thisJoint.indexC];  
	clb2Velocity velocityD = velocities[thisJoint.indexD];
	float2 vA =  (float2)(velocityA.vx, velocityA.vy); float wA = velocityA.w;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy); float wB = velocityB.w; 
	float2 vC =  (float2)(velocityC.vx, velocityC.vy); float wC = velocityC.w;
    float2 vD =  (float2)(velocityD.vx, velocityD.vy); float wD = velocityD.w; 

	float2 m_JvAC = (float2)(thisJoint.b.gearJointData.JvAC[0], thisJoint.b.gearJointData.JvAC[1]);
	float2 m_JvBD = (float2)(thisJoint.b.gearJointData.JvBD[0], thisJoint.b.gearJointData.JvBD[1]);

	float Cdot = b2clDot(m_JvAC, vA - vC) + b2clDot(m_JvBD, vB - vD);
	Cdot += (thisJoint.b.gearJointData.JwA * wA - thisJoint.b.gearJointData.JwC * wC) + (thisJoint.b.gearJointData.JwB * wB - thisJoint.b.gearJointData.JwD * wD);

	float impulse = -thisJoint.b.gearJointData.mass * Cdot;
	thisJoint.a.y.scalarImpulse += impulse;

	vA += (thisJoint.b.gearJointData.mA * impulse) * m_JvAC;
	wA += thisJoint.b.gearJointData.iA * impulse * thisJoint.b.gearJointData.JwA;
	vB += (thisJoint.b.gearJointData.mB * impulse) * m_JvBD;
	wB += thisJoint.b.gearJointData.iB * impulse * thisJoint.b.gearJointData.JwB;
	vC -= (thisJoint.b.gearJointData.mC * impulse) * m_JvAC;
	wC -= thisJoint.b.gearJointData.iC * impulse * thisJoint.b.gearJointData.JwC;
	vD -= (thisJoint.b.gearJointData.mD * impulse) * m_JvBD;
	wD -= thisJoint.b.gearJointData.iD * impulse * thisJoint.b.gearJointData.JwD;
	
	velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
	velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 
	velocityC.vx = vC.x ; velocityC.vy = vC.y ; velocityC.w = wC ; velocities[thisJoint.indexC] = velocityC; 
	velocityD.vx = vD.x ; velocityD.vy = vD.y ; velocityD.w = wD ; velocities[thisJoint.indexD] = velocityD; 

	jointList[contactIndex] = thisJoint; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolvePulleyJointVelocityConstraint
//
// Compute velocities of bodies which are constrained by a Pulley joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolvePulleyJointVelocityConstraint(
                                 __global clb2Velocity* velocities,
                                 __global b2clJoint* jointList,
								 float dt,	
                                 unsigned int offset,
                                 unsigned int colorLength
								// __global testData* testBuffer                                 
								 )

{
	unsigned int contactIndex = get_global_id(0) + offset;

    if(contactIndex>=offset+colorLength) 
		return;

	b2clJoint thisJoint = jointList[contactIndex]; 
	clb2Velocity velocityA = velocities[thisJoint.indexA];  
	clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 vA =  (float2)(velocityA.vx, velocityA.vy); float wA = velocityA.w;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy); float wB = velocityB.w; 
	float2 rA = (float2)(thisJoint.b.pulleyJointData.rA[0] , thisJoint.b.pulleyJointData.rA[1]); float2 rB = (float2) (thisJoint.b.pulleyJointData.rB[0], thisJoint.b.pulleyJointData.rB[1]);
	float2 uA = (float2)(thisJoint.b.pulleyJointData.uA[0] , thisJoint.b.pulleyJointData.uA[1]); float2 uB = (float2) (thisJoint.b.pulleyJointData.uB[0], thisJoint.b.pulleyJointData.uB[1]);

	float2 vpA = vA + b2clCross_SV (wA,rA);
	float2 vpB = vB + b2clCross_SV (wB,rB);
	
	float Cdot = 0 - b2clDot (uA, vpA) - thisJoint.b.pulleyJointData.ratio * b2clDot (uB, vpB); 
	float impulse = -thisJoint.b.pulleyJointData.mass * Cdot ; 
	thisJoint.a.y.scalarImpulse += impulse ; 
	

	float2 PA = -impulse * uA ; 
	float2 PB = -thisJoint.b.pulleyJointData.ratio*impulse * uB ; 
	vA += (float2) (thisJoint.b.pulleyJointData.invMassA * PA.x, thisJoint.b.pulleyJointData.invMassA * PA.y ); 
	wA += thisJoint.b.pulleyJointData.invIA * b2clCross_VV( rA, PA ) ; 
	vB += (float2) (thisJoint.b.pulleyJointData.invMassB * PB.x , thisJoint.b.pulleyJointData.invMassB * PB.y); 
	wB += thisJoint.b.pulleyJointData.invIB * b2clCross_VV (rB, PB);
	
	velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
	velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 
	jointList[contactIndex] = thisJoint ; 

}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolveRopeJointVelocityConstraint
//
// Compute velocities of bodies which are constrained by a Rope joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolveRopeJointVelocityConstraint(
                                 __global clb2Velocity* velocities,
                                 __global b2clJoint* jointList,
								 const float dt,
                                 const unsigned int offset,
                                 const unsigned int colorLength
								// __global testData* testBuffer                                 
								 )

{
	unsigned int contactIndex = get_global_id(0) + offset;

    if(contactIndex>=offset+colorLength) 
		return;

	b2clJoint thisJoint = jointList[contactIndex]; 
	clb2Velocity velocityA = velocities[thisJoint.indexA];  
	clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 vA =  (float2)(velocityA.vx, velocityA.vy); float wA = velocityA.w;
    float2 vB =  (float2)(velocityB.vx, velocityB.vy); float wB = velocityB.w; 
	float2 rA = (float2)(thisJoint.b.ropeJointData.rA[0] , thisJoint.b.ropeJointData.rA[1]); float2 rB = (float2) (thisJoint.b.ropeJointData.rB[0], thisJoint.b.ropeJointData.rB[1]);
	float2 u = (float2)(thisJoint.b.ropeJointData.u[0] , thisJoint.b.ropeJointData.u[1]);  

	
	float2 vpA = vA + b2clCross_SV (wA,rA);
	float2 vpB = vB + b2clCross_SV (wB,rB);
	float C = thisJoint.b.ropeJointData.nlength - thisJoint.b.ropeJointData.maxLength ; 
		
	float Cdot =  b2clDot (u, vpB- vpA) ; 
	if (C < 0.0f) {
		float inv_dt =   dt!=0 ?1/dt:0; 
		Cdot += C * inv_dt ; 
	}
	float impulse = -thisJoint.b.ropeJointData.mass * Cdot ; 
	float oldImpulse = thisJoint.a.y.scalarImpulse ; 
	float newImpulse = thisJoint.a.y.scalarImpulse + impulse;
	thisJoint.a.y.scalarImpulse =   newImpulse < 0 ? newImpulse : 0 ;
	impulse = thisJoint.a.y.scalarImpulse - oldImpulse ; 


	
	
	float2 P = impulse * u ; 
	
	vA -= (float2) (thisJoint.b.ropeJointData.invMassA * P.x, thisJoint.b.ropeJointData.invMassA * P.y ); 
	wA -= thisJoint.b.ropeJointData.invIA * b2clCross_VV( rA, P ) ; 
	vB += (float2) (thisJoint.b.ropeJointData.invMassB * P.x , thisJoint.b.ropeJointData.invMassB * P.y); 
	wB += thisJoint.b.ropeJointData.invIB * b2clCross_VV (rB, P);
	
	
	velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
	velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 
	jointList[contactIndex] = thisJoint ; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolveWheelJointVelocityConstraint
//
// Compute velocities of bodies which are constrained by a Wheel joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolveWheelJointVelocityConstraint(
                                 __global clb2Velocity* velocities,
                                 __global b2clJoint* jointList,
								 float dt,
                                 const unsigned int offset,
                                 const unsigned int colorLength
								// __global testData* testBuffer                                 
								 )

{
	unsigned int contactIndex = get_global_id(0) + offset;

    if(contactIndex>=offset+colorLength) 
		return;

	b2clJoint thisJoint = jointList[contactIndex]; 

	clb2Velocity velocityA = velocities[thisJoint.indexA];  clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 vA = (float2)(velocityA.vx, velocityA.vy); float wA = velocityA.w;
    float2 vB = (float2)(velocityB.vx, velocityB.vy); float wB = velocityB.w;

	float mA = thisJoint.b.wheelJointData.invMassA, mB = thisJoint.b.wheelJointData.invMassB;
	float iA = thisJoint.b.wheelJointData.invIA, iB = thisJoint.b.wheelJointData.invIB;

	const float2 m_ax = (float2)(thisJoint.b.wheelJointData.ax[0], thisJoint.b.wheelJointData.ax[1]);
	const float2 m_ay = (float2)(thisJoint.b.wheelJointData.ay[0], thisJoint.b.wheelJointData.ay[1]);
	
	// Solve spring constraint
	{
		float Cdot = b2clDot(m_ax, vB - vA) + thisJoint.b.wheelJointData.sBx * wB - thisJoint.b.wheelJointData.sAx * wA;
		float impulse = -thisJoint.b.wheelJointData.springMass * (Cdot + thisJoint.b.wheelJointData.bias + thisJoint.b.wheelJointData.gamma * thisJoint.a.y.springImpulse);
		thisJoint.a.y.springImpulse += impulse;

		float2 P = impulse * m_ax;
		float LA = impulse * thisJoint.b.wheelJointData.sAx;
		float LB = impulse * thisJoint.b.wheelJointData.sBx;

		vA -= mA * P;
		wA -= iA * LA;

		vB += mB * P;
		wB += iB * LB;
	}
	
	// Solve rotational motor constraint
	{
		float Cdot = wB - wA - thisJoint.b.wheelJointData.motorSpeed;
		float impulse = -thisJoint.b.wheelJointData.motorMass * Cdot;

		float oldImpulse = thisJoint.motorImpulse;
		float maxImpulse = dt * thisJoint.b.wheelJointData.maxMotorTorque;
		thisJoint.motorImpulse = b2clClamp(thisJoint.motorImpulse + impulse, -maxImpulse, maxImpulse);
		impulse = thisJoint.motorImpulse - oldImpulse;

		wA -= iA * impulse;
		wB += iB * impulse;
	}
	
	// Solve point to line constraint
	{
		float Cdot = b2clDot(m_ay, vB - vA) + thisJoint.b.wheelJointData.sBy * wB - thisJoint.b.wheelJointData.sAy * wA;
		float impulse = -thisJoint.b.wheelJointData.mass * Cdot;
		thisJoint.a.y.scalarImpulse += impulse;

		float2 P = impulse * m_ay;
		float LA = impulse * thisJoint.b.wheelJointData.sAy;
		float LB = impulse * thisJoint.b.wheelJointData.sBy;

		vA -= mA * P;
		wA -= iA * LA;

		vB += mB * P;
		wB += iB * LB;
	}
	
	velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
	velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 
	
	jointList[contactIndex] = thisJoint; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolveWeldJointVelocityConstraint
//
// Compute velocities of bodies which are constrained by a Weld joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolveWeldJointVelocityConstraint(
                                 __global clb2Velocity* velocities,
                                 __global b2clJoint* jointList,
								  const float dt,
                                 const unsigned int offset,
                                 const unsigned int colorLength
								// __global testData* testBuffer                                 
								 )

{
	unsigned int contactIndex = get_global_id(0) + offset;

    if(contactIndex>=offset+colorLength) 
		return;

	b2clJoint thisJoint = jointList[contactIndex]; 
	
	clb2Velocity velocityA = velocities[thisJoint.indexA];  clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 vA = (float2)(velocityA.vx, velocityA.vy); float wA = velocityA.w;
    float2 vB = (float2)(velocityB.vx, velocityB.vy); float wB = velocityB.w;

	float mA = thisJoint.b.weldJointData.invMassA, mB = thisJoint.b.weldJointData.invMassB;
	float iA = thisJoint.b.weldJointData.invIA, iB = thisJoint.b.weldJointData.invIB;

	float2 m_rA = (float2)(thisJoint.b.weldJointData.rA[0], thisJoint.b.weldJointData.rA[1]);
	float2 m_rB = (float2)(thisJoint.b.weldJointData.rB[0], thisJoint.b.weldJointData.rB[1]);

	if (thisJoint.b.weldJointData.frequencyHz > 0.0f)
	{
		float Cdot2 = wB - wA;

		float impulse2 = -thisJoint.b.weldJointData.mass.ez[2] * (Cdot2 + thisJoint.b.weldJointData.bias + thisJoint.b.weldJointData.gamma * thisJoint.a.x.impulse[2]);
		thisJoint.a.x.impulse[2] += impulse2;

		wA -= iA * impulse2;
		wB += iB * impulse2;

		float2 Cdot1 = vB + b2clCross_SV(wB, m_rB) - vA - b2clCross_SV(wA, m_rA);

		float2 impulse1 = -b2clMat33MulV2(thisJoint.b.weldJointData.mass, Cdot1);
		thisJoint.a.x.impulse[0] += impulse1.x;
		thisJoint.a.x.impulse[1] += impulse1.y;

		float2 P = impulse1;

		vA -= mA * P;
		wA -= iA * b2clCross_VV(m_rA, P);

		vB += mB * P;
		wB += iB * b2clCross_VV(m_rB, P);
	}
	else
	{
		float2 Cdot1 = vB + b2clCross_SV(wB, m_rB) - vA - b2clCross_SV(wA, m_rA);
		float Cdot2 = wB - wA;
		float3 Cdot = (float3)(Cdot1.x, Cdot1.y, Cdot2);

		float3 impulse = -b2clMat33MulV3(thisJoint.b.weldJointData.mass, Cdot);
		thisJoint.a.x.impulse[0] += impulse.x;
		thisJoint.a.x.impulse[1] += impulse.y;
		thisJoint.a.x.impulse[2] += impulse.z;

		float2 P = (float2)(impulse.x, impulse.y);

		vA -= mA * P;
		wA -= iA * (b2clCross_VV(m_rA, P) + impulse.z);

		vB += mB * P;
		wB += iB * (b2clCross_VV(m_rB, P) + impulse.z);
	}
	
	velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
	velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 
	
	jointList[contactIndex] = thisJoint; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolveMouseJointVelocityConstraint
//
// Compute velocities of bodies which are constrained by a Mouse joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolveMouseJointVelocityConstraint(
                                 __global clb2Velocity* velocities,
                                 __global b2clJoint* jointList,
								 float dt,
                                 const unsigned int offset,
                                 const unsigned int colorLength
								// __global testData* testBuffer                                 
								 )

{
	unsigned int contactIndex = get_global_id(0) + offset;

    if(contactIndex>=offset+colorLength) 
		return;
		
	b2clJoint thisJoint = jointList[contactIndex]; 

	clb2Velocity velocityB = velocities[thisJoint.indexB]; 
    float2 vB =  (float2)(velocityB.vx, velocityB.vy); float wB = velocityB.w; 

	float2 m_impulse = (float2)(thisJoint.a.x.impulse[0], thisJoint.a.x.impulse[1]);
	const float2 m_rB = (float2)(thisJoint.b.mouseJointData.rB[0], thisJoint.b.mouseJointData.rB[1]);
	const float2 m_C = (float2)(thisJoint.b.mouseJointData.C[0], thisJoint.b.mouseJointData.C[1]);

	// Cdot = v + cross(w, r)
	float2 Cdot = vB + b2clCross_SV(wB, m_rB);
	float2 impulse = b2clMat22Mul(thisJoint.b.mouseJointData.mass, -(Cdot + m_C + thisJoint.b.mouseJointData.gamma * m_impulse));

	float2 oldImpulse = m_impulse;
	m_impulse += impulse;
	float maxImpulse = dt * thisJoint.b.mouseJointData.maxForce;
	if (b2clDot(m_impulse, m_impulse) > maxImpulse * maxImpulse)
	{
		m_impulse *= maxImpulse / sqrt(b2clDot(m_impulse, m_impulse));
	}
	impulse = m_impulse - oldImpulse;

	vB += thisJoint.b.mouseJointData.invMassB * impulse;
	wB += thisJoint.b.mouseJointData.invIB * b2clCross_VV(m_rB, impulse);
	
	velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 

	thisJoint.a.x.impulse[0] = m_impulse.x;
	thisJoint.a.x.impulse[1] = m_impulse.y;
	jointList[contactIndex] = thisJoint; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SolveFrictionJointVelocityConstraint
//
// Compute velocities of bodies which are constrained by a Friction joint.
////////////////////////////////////////////////////////////////////////////////////////////////////
__kernel void SolveFrictionJointVelocityConstraint(
                                 __global clb2Velocity* velocities,
                                 __global b2clJoint* jointList,
								 float dt,
                                 const unsigned int offset,
                                 const unsigned int colorLength
								// __global testData* testBuffer                                 
								 )

{
	unsigned int contactIndex = get_global_id(0) + offset;

    if(contactIndex>=offset+colorLength) 
		return;

	b2clJoint thisJoint = jointList[contactIndex]; 
	
	clb2Velocity velocityA = velocities[thisJoint.indexA];  clb2Velocity velocityB = velocities[thisJoint.indexB]; 
	float2 vA = (float2)(velocityA.vx, velocityA.vy); float wA = velocityA.w;
    float2 vB = (float2)(velocityB.vx, velocityB.vy); float wB = velocityB.w;

	float mA = thisJoint.b.frictionJointData.invMassA, mB = thisJoint.b.frictionJointData.invMassB;
	float iA = thisJoint.b.frictionJointData.invIA, iB = thisJoint.b.frictionJointData.invIB;

	float2 m_rA = (float2)(thisJoint.b.frictionJointData.rA[0], thisJoint.b.frictionJointData.rA[1]);
	float2 m_rB = (float2)(thisJoint.b.frictionJointData.rB[0], thisJoint.b.frictionJointData.rB[1]);

	float2 m_linearImpulse = (float2) (thisJoint.a.z.linearImpulse[0], thisJoint.a.z.linearImpulse[1]);

	float h = dt;

	// Solve angular friction
	{
		float Cdot = wB - wA;
		float impulse = -thisJoint.b.frictionJointData.angularMass * Cdot;

		float oldImpulse = thisJoint.a.z.angularImpulse;
		float maxImpulse = h * thisJoint.b.frictionJointData.maxTorque;
		thisJoint.a.z.angularImpulse = b2clClamp(thisJoint.a.z.angularImpulse + impulse, -maxImpulse, maxImpulse);
		impulse = thisJoint.a.z.angularImpulse - oldImpulse;

		wA -= iA * impulse;
		wB += iB * impulse;
	}

	// Solve linear friction
	{
		float2 Cdot = vB + b2clCross_SV(wB, m_rB) - vA - b2clCross_SV(wA, m_rA);

		float2 impulse = -b2clMat22Mul(thisJoint.b.frictionJointData.linearMass, Cdot);
		float2 oldImpulse = m_linearImpulse;
		m_linearImpulse += impulse;

		float maxImpulse = h * thisJoint.b.frictionJointData.maxForce;

		// TODO: can be optimized
		if (b2clDot(m_linearImpulse, m_linearImpulse) > maxImpulse * maxImpulse)
		{
			m_linearImpulse /= b2clDot(m_linearImpulse, m_linearImpulse);
			m_linearImpulse *= maxImpulse;
		}

		impulse = m_linearImpulse - oldImpulse;

		vA -= mA * impulse;
		wA -= iA * b2clCross_VV(m_rA, impulse);

		vB += mB * impulse;
		wB += iB * b2clCross_VV(m_rB, impulse);
	}
	
	thisJoint.a.z.linearImpulse[0] = m_linearImpulse.x;
	thisJoint.a.z.linearImpulse[1] = m_linearImpulse.y;
	velocityA.vx = vA.x ; velocityA.vy = vA.y ; velocityA.w = wA ; velocities[thisJoint.indexA] = velocityA; 
	velocityB.vx = vB.x ; velocityB.vy = vB.y ; velocityB.w = wB ; velocities[thisJoint.indexB] = velocityB; 
	
	jointList[contactIndex] = thisJoint; 
}





/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * Please refer to the NVIDIA end user license agreement (EULA) associated
 * with this source code for terms and conditions that govern your use of
 * this software. Any use, reproduction, disclosure, or distribution of
 * this software and related documentation outside the terms of the EULA
 * is strictly prohibited.
 *
 */

#define LOCAL_SIZE_LIMIT 512U

inline void ComparatorPrivate(
    float *keyA,
    uint *valA,
    float *keyB,
    uint *valB,
    uint dir
){
    if( (*keyA > *keyB) == dir ){
        float t;
        t = *keyA; *keyA = *keyB; *keyB = t;
        t = *valA; *valA = *valB; *valB = t;
    }
}

inline void ComparatorLocal(
    __local float *keyA,
    __local uint *valA,
    __local float *keyB,
    __local uint *valB,
    uint dir
){
    if( (*keyA > *keyB) == dir ){
        float t;
        t = *keyA; *keyA = *keyB; *keyB = t;
        t = *valA; *valA = *valB; *valB = t;
    }
}

////////////////////////////////////////////////////////////////////////////////
// Monolithic bitonic sort kernel for short arrays fitting into local memory
////////////////////////////////////////////////////////////////////////////////
__kernel void bitonicSortLocal(
    __global float *d_DstKey,
    __global uint *d_DstVal,
    __global float *d_SrcKey,
    __global uint *d_SrcVal,
    uint arrayLength,
    uint dir
){
    __local  float l_key[LOCAL_SIZE_LIMIT];
    __local  uint l_val[LOCAL_SIZE_LIMIT];

    //Offset to the beginning of subbatch and load data
    d_SrcKey += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_SrcVal += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_DstKey += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_DstVal += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    l_key[get_local_id(0) +                      0] = d_SrcKey[                     0];
    l_val[get_local_id(0) +                      0] = d_SrcVal[                     0];
    l_key[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)] = d_SrcKey[(LOCAL_SIZE_LIMIT / 2)];
    l_val[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)] = d_SrcVal[(LOCAL_SIZE_LIMIT / 2)];

    for(uint size = 2; size < arrayLength; size <<= 1){
        //Bitonic merge
        uint ddd = dir ^ ( (get_local_id(0) & (size / 2)) != 0 );
        for(uint stride = size / 2; stride > 0; stride >>= 1){
            barrier(CLK_LOCAL_MEM_FENCE);
            uint pos = 2 * get_local_id(0) - (get_local_id(0) & (stride - 1));
            ComparatorLocal(
                &l_key[pos +      0], &l_val[pos +      0],
                &l_key[pos + stride], &l_val[pos + stride],
                ddd
            );
        }
    }

    //ddd == dir for the last bitonic merge step
    {
        for(uint stride = arrayLength / 2; stride > 0; stride >>= 1){
            barrier(CLK_LOCAL_MEM_FENCE);
            uint pos = 2 * get_local_id(0) - (get_local_id(0) & (stride - 1));
            ComparatorLocal(
                &l_key[pos +      0], &l_val[pos +      0],
                &l_key[pos + stride], &l_val[pos + stride],
                dir
            );
        }
    }

    barrier(CLK_LOCAL_MEM_FENCE);
    d_DstKey[                     0] = l_key[get_local_id(0) +                      0];
    d_DstVal[                     0] = l_val[get_local_id(0) +                      0];
    d_DstKey[(LOCAL_SIZE_LIMIT / 2)] = l_key[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)];
    d_DstVal[(LOCAL_SIZE_LIMIT / 2)] = l_val[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)];
}

////////////////////////////////////////////////////////////////////////////////
// Bitonic sort kernel for large arrays (not fitting into local memory)
////////////////////////////////////////////////////////////////////////////////
//Bottom-level bitonic sort
//Almost the same as bitonicSortLocal with the only exception
//of even / odd subarrays (of LOCAL_SIZE_LIMIT points) being
//sorted in opposite directions
__kernel void bitonicSortLocal1(
    __global float *d_DstKey,
    __global uint *d_DstVal,
    __global float *d_SrcKey,
    __global uint *d_SrcVal
){
    __local float l_key[LOCAL_SIZE_LIMIT];
    __local uint l_val[LOCAL_SIZE_LIMIT];

    //Offset to the beginning of subarray and load data
    d_SrcKey += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_SrcVal += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_DstKey += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_DstVal += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    l_key[get_local_id(0) +                      0] = d_SrcKey[                     0];
    l_val[get_local_id(0) +                      0] = d_SrcVal[                     0];
    l_key[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)] = d_SrcKey[(LOCAL_SIZE_LIMIT / 2)];
    l_val[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)] = d_SrcVal[(LOCAL_SIZE_LIMIT / 2)];

    uint comparatorI = get_global_id(0) & ((LOCAL_SIZE_LIMIT / 2) - 1);

    for(uint size = 2; size < LOCAL_SIZE_LIMIT; size <<= 1){
        //Bitonic merge
        uint ddd = (comparatorI & (size / 2)) != 0;
        for(uint stride = size / 2; stride > 0; stride >>= 1){
            barrier(CLK_LOCAL_MEM_FENCE);
            uint pos = 2 * get_local_id(0) - (get_local_id(0) & (stride - 1));
            ComparatorLocal(
                &l_key[pos +      0], &l_val[pos +      0],
                &l_key[pos + stride], &l_val[pos + stride],
                ddd
            );
        }
    }

    //Odd / even arrays of LOCAL_SIZE_LIMIT elements
    //sorted in opposite directions
    {
        uint ddd = (get_group_id(0) & 1);
        for(uint stride = LOCAL_SIZE_LIMIT / 2; stride > 0; stride >>= 1){
            barrier(CLK_LOCAL_MEM_FENCE);
            uint pos = 2 * get_local_id(0) - (get_local_id(0) & (stride - 1));
            ComparatorLocal(
                &l_key[pos +      0], &l_val[pos +      0],
                &l_key[pos + stride], &l_val[pos + stride],
               ddd
            );
        }
    }

    barrier(CLK_LOCAL_MEM_FENCE);
    d_DstKey[                     0] = l_key[get_local_id(0) +                      0];
    d_DstVal[                     0] = l_val[get_local_id(0) +                      0];
    d_DstKey[(LOCAL_SIZE_LIMIT / 2)] = l_key[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)];
    d_DstVal[(LOCAL_SIZE_LIMIT / 2)] = l_val[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)];
}

//Bitonic merge iteration for 'stride' >= LOCAL_SIZE_LIMIT
__kernel void bitonicMergeGlobal(
    __global float *d_DstKey,
    __global uint *d_DstVal,
    __global float *d_SrcKey,
    __global uint *d_SrcVal,
    uint arrayLength,
    uint size,
    uint stride,
    uint dir
){
    uint global_comparatorI = get_global_id(0);
    uint        comparatorI = global_comparatorI & (arrayLength / 2 - 1);

    //Bitonic merge
    uint ddd = dir ^ ( (comparatorI & (size / 2)) != 0 );
    uint pos = 2 * global_comparatorI - (global_comparatorI & (stride - 1));

    float keyA = d_SrcKey[pos +      0];
    uint valA = d_SrcVal[pos +      0];
    float keyB = d_SrcKey[pos + stride];
    uint valB = d_SrcVal[pos + stride];

    ComparatorPrivate(
        &keyA, &valA,
        &keyB, &valB,
        ddd
    );

    d_DstKey[pos +      0] = keyA;
    d_DstVal[pos +      0] = valA;
    d_DstKey[pos + stride] = keyB;
    d_DstVal[pos + stride] = valB;
}

//Combined bitonic merge steps for
//'size' > LOCAL_SIZE_LIMIT and 'stride' = [1 .. LOCAL_SIZE_LIMIT / 2]
__kernel void bitonicMergeLocal(
    __global float *d_DstKey,
    __global uint *d_DstVal,
    __global float *d_SrcKey,
    __global uint *d_SrcVal,
    uint arrayLength,
    uint stride,
    uint size,
    uint dir
){
    __local float l_key[LOCAL_SIZE_LIMIT];
    __local uint l_val[LOCAL_SIZE_LIMIT];

    d_SrcKey += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_SrcVal += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_DstKey += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    d_DstVal += get_group_id(0) * LOCAL_SIZE_LIMIT + get_local_id(0);
    l_key[get_local_id(0) +                      0] = d_SrcKey[                     0];
    l_val[get_local_id(0) +                      0] = d_SrcVal[                     0];
    l_key[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)] = d_SrcKey[(LOCAL_SIZE_LIMIT / 2)];
    l_val[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)] = d_SrcVal[(LOCAL_SIZE_LIMIT / 2)];

    //Bitonic merge
    uint comparatorI = get_global_id(0) & ((arrayLength / 2) - 1);
    uint         ddd = dir ^ ( (comparatorI & (size / 2)) != 0 );
    for(; stride > 0; stride >>= 1){
        barrier(CLK_LOCAL_MEM_FENCE);
        uint pos = 2 * get_local_id(0) - (get_local_id(0) & (stride - 1));
        ComparatorLocal(
            &l_key[pos +      0], &l_val[pos +      0],
            &l_key[pos + stride], &l_val[pos + stride],
            ddd
        );
    }

    barrier(CLK_LOCAL_MEM_FENCE);
    d_DstKey[                     0] = l_key[get_local_id(0) +                      0];
    d_DstVal[                     0] = l_val[get_local_id(0) +                      0];
    d_DstKey[(LOCAL_SIZE_LIMIT / 2)] = l_key[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)];
    d_DstVal[(LOCAL_SIZE_LIMIT / 2)] = l_val[get_local_id(0) + (LOCAL_SIZE_LIMIT / 2)];
}
